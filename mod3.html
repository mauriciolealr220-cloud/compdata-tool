<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Competition Architect</title>
  <style>
    :root {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: light dark;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: #f1f5f9;
      color: #0f172a;
    }
    body.dark {
      background: #0f172a;
      color: #e2e8f0;
    }
    body.dark .card { background: #1e293b; border-color: #334155; box-shadow: none; }
    body.dark .bg-slate-50 { background: #1f2937; }
    body.dark .bg-slate-100 { background: #16213b; }
    body.dark .border-slate-200 { border-color: #334155; }
    body.dark .text-slate-600 { color: #cbd5f5; }
    body.dark .text-slate-500 { color: #94a3b8; }
    body.dark input,
    body.dark textarea,
    body.dark select {
      background: #0f172a;
      color: #e2e8f0;
      border-color: #475569;
    }
    a { color: inherit; }
    button { font: inherit; cursor: pointer; border: none; background: none; }
    input, textarea, select { font: inherit; border: 1px solid #cbd5f5; border-radius: 0.55rem; padding: 0.55rem 0.75rem; }
    textarea { resize: vertical; }
    ::placeholder { color: #94a3b8; }

    .min-h-screen { min-height: 100vh; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .flex-row { flex-direction: row; }
    .flex-wrap { flex-wrap: wrap; }
    .items-center { align-items: center; }
    .items-start { align-items: flex-start; }
    .justify-between { justify-content: space-between; }
    .justify-start { justify-content: flex-start; }
    .justify-center { justify-content: center; }
    .justify-end { justify-content: flex-end; }
    .gap-1 { gap: 0.25rem; }
    .gap-2 { gap: 0.5rem; }
    .gap-3 { gap: 0.75rem; }
    .gap-4 { gap: 1rem; }
    .gap-5 { gap: 1.25rem; }
    .gap-6 { gap: 1.5rem; }
    .gap-8 { gap: 2rem; }
    .gap-10 { gap: 2.5rem; }
    .p-2 { padding: 0.5rem; }
    .p-3 { padding: 0.75rem; }
    .p-4 { padding: 1rem; }
    .p-5 { padding: 1.25rem; }
    .p-6 { padding: 1.5rem; }
    .p-8 { padding: 2rem; }
    .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .px-4 { padding-left: 1rem; padding-right: 1rem; }
    .px-5 { padding-left: 1.25rem; padding-right: 1.25rem; }
    .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
    .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
    .py-4 { padding-top: 1rem; padding-bottom: 1rem; }
    .py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mt-4 { margin-top: 1rem; }
    .mt-5 { margin-top: 1.25rem; }
    .mt-6 { margin-top: 1.5rem; }
    .mt-8 { margin-top: 2rem; }
    .mt-10 { margin-top: 2.5rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-3 { margin-bottom: 0.75rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .w-full { width: 100%; }
    .w-1\/3 { width: 33.333%; }
    .w-2\/3 { width: 66.666%; }
    .shrink-0 { flex-shrink: 0; }
    .grow { flex-grow: 1; }
    .text-xs { font-size: 0.75rem; }
    .text-sm { font-size: 0.875rem; }
    .text-base { font-size: 1rem; }
    .text-lg { font-size: 1.125rem; }
    .text-xl { font-size: 1.25rem; }
    .text-2xl { font-size: 1.5rem; }
    .text-3xl { font-size: 1.75rem; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }
    .uppercase { text-transform: uppercase; letter-spacing: 0.08em; }
    .rounded { border-radius: 0.5rem; }
    .rounded-md { border-radius: 0.65rem; }
    .rounded-lg { border-radius: 0.85rem; }
    .rounded-full { border-radius: 9999px; }
    .border { border: 1px solid #e2e8f0; }
    .border-slate-200 { border-color: #e2e8f0; }
    .shadow-sm { box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08); }
    .shadow { box-shadow: 0 22px 45px -18px rgba(15, 23, 42, 0.35); }
    .bg-white { background: #ffffff; }
    .bg-slate-50 { background: #f8fafc; }
    .bg-slate-100 { background: #f1f5f9; }
    .bg-slate-800 { background: #1e293b; }
    .text-slate-500 { color: #64748b; }
    .text-slate-600 { color: #475569; }
    .text-slate-700 { color: #334155; }
    .text-slate-900 { color: #0f172a; }
    .text-emerald-600 { color: #059669; }
    .text-red-600 { color: #dc2626; }
    .text-blue-600 { color: #2563eb; }
    .text-amber-500 { color: #f59e0b; }
    .bg-emerald-500 { background: #10b981; }
    .bg-emerald-600 { background: #059669; }
    .bg-blue-600 { background: #2563eb; }
    .bg-blue-700 { background: #1d4ed8; }
    .bg-red-600 { background: #dc2626; }
    .bg-red-700 { background: #b91c1c; }
    .bg-amber-500 { background: #f59e0b; }
    .bg-amber-600 { background: #d97706; }
    .text-white { color: #ffffff; }
    .text-center { text-align: center; }
    .text-right { text-align: right; }
    .whitespace-nowrap { white-space: nowrap; }
    .leading-tight { line-height: 1.3; }
    .tracking-wide { letter-spacing: 0.08em; }
    .hidden { display: none !important; }

    .page { max-width: 1320px; margin: 0 auto; padding: 2.5rem 1.75rem 4rem; display: flex; flex-direction: column; gap: 2rem; }
    header.page-header { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: space-between; align-items: flex-start; }
    header.page-header h1 { margin: 0; }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.6rem 1.05rem;
      border-radius: 0.75rem;
      font-size: 0.9rem;
      font-weight: 600;
      border: none;
      background: #e2e8f0;
      color: #0f172a;
      transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 14px 32px -18px rgba(15, 23, 42, 0.35); }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .btn-primary { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; }
    .btn-accent { background: linear-gradient(135deg, #10b981, #059669); color: #ffffff; }
    .btn-ghost { background: transparent; border: 1px solid #cbd5f5; color: inherit; }
    .btn-outline { background: transparent; border: 1px solid rgba(37,99,235,0.35); color: #1d4ed8; }

    .card { background: #ffffff; border-radius: 1rem; border: 1px solid #e2e8f0; box-shadow: 0 18px 40px -24px rgba(15, 23, 42, 0.35); display: flex; flex-direction: column; }
    .card-header { display: flex; justify-content: space-between; align-items: center; padding: 1.25rem 1.5rem; border-bottom: 1px solid #e2e8f0; }
    .card-body { padding: 1.5rem; display: flex; flex-direction: column; gap: 1rem; }

    .selector-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.85rem; }
    .selector-card { position: relative; overflow: hidden; border-radius: 0.95rem; border: 1px solid #e2e8f0; padding: 1rem; background: #f8fafc; display: flex; flex-direction: column; gap: 0.65rem; text-align: left; transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease; }
    .selector-card:hover { transform: translateY(-2px); box-shadow: 0 18px 35px -22px rgba(15, 23, 42, 0.35); }
    .selector-card-active { border-color: #1d4ed8; box-shadow: 0 18px 30px -22px rgba(37, 99, 235, 0.45); background: linear-gradient(135deg, rgba(37,99,235,0.12), rgba(15,23,42,0.03)); }
    .selector-card-add { border: 1px dashed #94a3b8; background: #ffffff; justify-content: center; align-items: center; font-weight: 600; color: #64748b; }
    .selector-card-add:hover { border-color: #1d4ed8; color: #1d4ed8; box-shadow: none; transform: translateY(0); }
    .selector-card-static { pointer-events: none; background: #e2e8f0; color: #1e293b; }
    body.dark .selector-card-static { background: #1f2937; color: #e2e8f0; border-color: #334155; }
    .selector-icon { font-size: 1.5rem; }
    .selector-title { font-weight: 600; font-size: 1rem; }
    .selector-sub { font-size: 0.8rem; color: #475569; }
    .selector-dev { font-size: 0.75rem; color: #94a3b8; }

    .wizard { display: flex; flex-direction: column; gap: 1.5rem; }
    .stepper { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .step-pill { padding: 0.55rem 0.95rem; border-radius: 999px; background: #e2e8f0; color: #475569; display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; font-weight: 600; transition: background 0.2s ease, color 0.2s ease; }
    .step-pill span { font-size: 0.75rem; font-weight: 500; opacity: 0.7; }
    .step-pill-active { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; box-shadow: 0 14px 32px -20px rgba(37,99,235,0.8); }

    .pill-button { border-radius: 999px; padding: 0.45rem 0.9rem; font-size: 0.8rem; background: #e2e8f0; color: #0f172a; font-weight: 600; }
    .pill-button-active { background: #2563eb; color: #ffffff; }

    .input-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; }
    .field { display: flex; flex-direction: column; gap: 0.45rem; }
    .field label { font-weight: 600; font-size: 0.85rem; }
    .field small { color: #64748b; font-size: 0.75rem; }

    .stage-list { display: flex; flex-direction: column; gap: 0.85rem; }
    .stage-details { border-radius: 0.85rem; border: 1px solid #e2e8f0; background: #ffffff; padding: 0.75rem 1rem; }
    .stage-header { display: flex; align-items: center; gap: 0.75rem; }
    .stage-icon { font-size: 1.25rem; }
    .stage-summary { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 0.5rem; }
    .badge { display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.3rem 0.7rem; border-radius: 999px; background: #e2e8f0; font-size: 0.75rem; font-weight: 600; color: #334155; }
    body.dark .badge { background: #273347; color: #cbd5f5; }

    details summary { list-style: none; cursor: pointer; display: flex; align-items: center; gap: 0.75rem; font-weight: 600; }
    details summary::-webkit-details-marker { display: none; }
    details[open] { border-color: #2563eb; box-shadow: 0 18px 35px -24px rgba(37,99,235,0.45); }
    details .details-body { margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px dashed #cbd5f5; display: flex; flex-direction: column; gap: 0.6rem; }

    .toggle-row { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; border-radius: 0.8rem; border: 1px solid #e2e8f0; background: #f8fafc; }
    .toggle-row .toggle-info { display: flex; flex-direction: column; gap: 0.25rem; }

    .switch { position: relative; width: 48px; height: 26px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #cbd5f5; transition: .2s; border-radius: 26px; }
    .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .2s; border-radius: 50%; box-shadow: 0 2px 6px rgba(15,23,42,0.2); }
    .switch input:checked + .slider { background-color: #2563eb; }
    .switch input:checked + .slider:before { transform: translateX(22px); }

    .range-row { display: flex; flex-direction: column; gap: 0.4rem; }
    .range-row label { display: flex; justify-content: space-between; font-size: 0.85rem; font-weight: 600; }
    input[type=range] { -webkit-appearance: none; width: 100%; height: 6px; border-radius: 999px; background: #e2e8f0; outline: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #2563eb; cursor: pointer; box-shadow: 0 4px 12px rgba(37,99,235,0.45); }
    input[type=range]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: #2563eb; cursor: pointer; box-shadow: 0 4px 12px rgba(37,99,235,0.45); }

    .message { border-radius: 0.8rem; padding: 0.65rem 0.9rem; font-size: 0.85rem; display: inline-flex; align-items: center; gap: 0.5rem; }
    .message-info { background: #dbeafe; color: #1d4ed8; }
    .message-success { background: #dcfce7; color: #047857; }
    .message-error { background: #fee2e2; color: #b91c1c; }

    .export-panel { border-radius: 1rem; border: 1px solid #e2e8f0; padding: 1.25rem; background: #ffffff; display: flex; flex-direction: column; gap: 1rem; }
    .export-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 0.75rem; }
    .export-chip { padding: 0.45rem 0.75rem; border-radius: 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center; }
    .export-text { white-space: pre; overflow-x: auto; background: #0f172a; color: #e2e8f0; border-radius: 0.75rem; padding: 1rem; font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace; font-size: 0.8rem; }

    .callout { border-radius: 0.9rem; padding: 0.9rem 1rem; background: #fef3c7; color: #92400e; font-size: 0.85rem; }
    .callout-error { background: #fee2e2; color: #b91c1c; }

    .file-button-grid { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .file-status-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 0.75rem; }
    .file-status-card { padding: 0.75rem; border-radius: 0.85rem; background: #f8fafc; border: 1px solid #e2e8f0; display: flex; flex-direction: column; gap: 0.25rem; }
    body.dark .file-status-card { background: #1f2937; border-color: #334155; }
    .file-status-card .title { font-weight: 600; font-size: 0.85rem; }
    .file-status-card .meta { font-size: 0.75rem; color: #64748b; }
    body.dark .file-status-card .meta { color: #cbd5f5; }
    .validation-log { border-radius: 0.85rem; border: 1px solid #e2e8f0; padding: 0.9rem; display: flex; flex-direction: column; gap: 0.5rem; }
    .validation-log ul { margin: 0; padding-left: 1.25rem; }
    body.dark .validation-log { border-color: #334155; }

    @media (max-width: 960px) {
      .page { padding: 1.75rem 1.25rem 3rem; }
      .layout { display: flex; flex-direction: column; gap: 1.5rem; }
    }
  </style>
</head>
<body class="min-h-screen" id="pageBody">
  <div class="page">
    <header class="page-header">
      <div>
        <p class="uppercase text-xs tracking-wide text-slate-600">Unified Competition Builder</p>
        <h1 class="text-3xl font-bold mt-2">Competition Architect</h1>
        <p class="text-sm text-slate-600 mt-1">Plan federations, design league structures, and export synchronized data packs without touching raw IDs.</p>
      </div>
      <div class="flex flex-wrap items-center gap-2">
        <button id="developerToggle" class="btn btn-ghost">Developer Mode</button>
        <button id="themeToggle" class="btn btn-ghost">Toggle Dark</button>
        <button id="buildExportBtn" class="btn btn-primary">Build &amp; Export</button>
      </div>
    </header>

    <div id="globalMessage" class="hidden"></div>

    <section class="card" id="fileManager">
      <div class="card-header">
        <div>
          <h2 class="text-xl font-semibold">Data Files</h2>
          <p class="text-xs text-slate-600 mt-1">Import, validate, and export synchronized text packs before diving into editing.</p>
        </div>
        <div class="flex items-center gap-2">
          <button id="validateAllBtn" class="btn btn-outline">Validate All</button>
          <button id="importZipBtn" class="btn btn-ghost">Load ZIP</button>
        </div>
      </div>
      <div class="card-body">
        <div class="flex flex-col gap-4">
          <div class="file-button-grid" id="fileButtonGrid">
            <button type="button" class="btn" data-file="compobj">Import compobj.txt</button>
            <button type="button" class="btn" data-file="settings">Import settings.txt</button>
            <button type="button" class="btn" data-file="tasks">Import tasks.txt</button>
            <button type="button" class="btn" data-file="advancement">Import advancement.txt</button>
            <button type="button" class="btn" data-file="standings">Import standings.txt</button>
            <button type="button" class="btn" data-file="schedule">Import schedule.txt</button>
            <button type="button" class="btn" data-file="weather">Import weather.txt</button>
            <button type="button" class="btn" data-file="objectives">Import objectives.txt</button>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-slate-600 mb-2">Loaded Files</h3>
            <div id="fileStatusList" class="file-status-grid"></div>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-slate-600 mb-2">Export</h3>
            <div class="file-button-grid" id="fileExportButtons"></div>
          </div>
          <div id="validationOutput" class="validation-log hidden"></div>
        </div>
        <input id="fileInput-compobj" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-settings" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-tasks" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-advancement" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-standings" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-schedule" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-weather" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-objectives" type="file" accept=".txt" class="hidden" />
        <input id="zipInput" type="file" accept=".zip" class="hidden" />
      </div>
    </section>

    <section class="layout" style="display:grid; grid-template-columns: 320px 320px 1fr; gap:1.5rem; align-items:start;">
      <article class="card" id="federationPanel">
        <div class="card-header">
          <div>
            <h2 class="text-xl font-semibold">Federation Selector</h2>
            <p class="text-xs text-slate-600 mt-1">Pick a confederation to browse its competitions.</p>
          </div>
        </div>
        <div class="card-body">
          <div id="federationList" class="selector-grid"></div>
        </div>
      </article>

      <article class="card" id="leaguePanel">
        <div class="card-header">
          <div>
            <h2 class="text-xl font-semibold">League Browser</h2>
            <p id="leaguePanelSummary" class="text-xs text-slate-600 mt-1"></p>
          </div>
          <button id="addLeagueBtn" class="btn btn-ghost">New Competition</button>
        </div>
        <div class="card-body">
          <div class="field">
            <label for="leagueSearch" class="text-sm font-semibold">Search</label>
            <input id="leagueSearch" type="search" placeholder="Search competitions by name or code" />
          </div>
          <div class="field">
            <h3 class="text-sm font-semibold text-slate-600 mb-2">Nations</h3>
            <div id="nationList" class="selector-grid"></div>
          </div>
          <div class="field">
            <h3 class="text-sm font-semibold text-slate-600 mb-2">Competitions</h3>
            <div id="leagueList" class="selector-grid"></div>
          </div>
        </div>
      </article>

      <article class="card" id="editorPanel">
        <div class="card-header">
          <div>
            <h2 class="text-xl font-semibold">Competition Editor</h2>
            <p id="editorSummary" class="text-xs text-slate-600 mt-1"></p>
          </div>
          <div class="flex items-center gap-2">
            <button id="prevStepBtn" class="btn btn-ghost">Back</button>
            <button id="nextStepBtn" class="btn btn-ghost">Next</button>
          </div>
        </div>
        <div class="card-body">
          <div id="editorContent" class="wizard"></div>
        </div>
      </article>
    </section>

    <section class="card">
      <div class="card-header">
        <div>
          <h2 class="text-xl font-semibold">Build Output</h2>
          <p class="text-xs text-slate-600 mt-1">Validated data files appear here after each build.</p>
        </div>
        <div class="flex items-center gap-2">
          <button id="downloadZipBtn" class="btn btn-outline">Download ZIP</button>
          <button id="copyTextBtn" class="btn btn-outline">Copy All Text</button>
        </div>
      </div>
      <div class="card-body">
        <div id="exportResults" class="export-panel"></div>
      </div>
    </section>
  </div>

  <script>
    (() => {
      const $ = (id) => document.getElementById(id);
      const stepLabels = ['Overview', 'Structure', 'Stages', 'Review'];

      function createWorldRoot() {
        return {
          uuid: 'world-root',
          name: 'World',
          code: 'WORLD',
          level: '0',
          parent: '-1',
          id: null,
          federations: []
        };
      }

      const state = {
        world: createWorldRoot(),
        federations: [],
        selectedFederation: null,
        selectedNation: null,
        selectedCompetition: null,
        dataLoaded: false,
        developerMode: false,
        stepIndex: 0,
        leagueSearch: '',
        lastBuild: null
      };

      state.federations = state.world.federations;

      let compRows = [];
      let setRows = [];
      let taskRows = [];
      let advRows = [];
      let standRows = [];
      let schedRows = [];
      let weatherRows = [];
      let objectiveRows = [];

      const fileStatus = new Map();
      const textDecoder = new TextDecoder();

      const fileDefinitions = [
        { key: 'compobj', fileName: 'compobj.txt', arrayKey: 'compRows', parser: parseCompobj, formatter: formatCompRow, label: 'Competition Objects' },
        { key: 'settings', fileName: 'settings.txt', arrayKey: 'setRows', parser: parseSettings, formatter: formatSettingRow, label: 'Settings' },
        { key: 'tasks', fileName: 'tasks.txt', arrayKey: 'taskRows', parser: parseTasks, formatter: formatTaskRow, label: 'Tasks' },
        { key: 'advancement', fileName: 'advancement.txt', arrayKey: 'advRows', parser: parseAdvancement, formatter: formatAdvRow, label: 'Advancement' },
        { key: 'standings', fileName: 'standings.txt', arrayKey: 'standRows', parser: parseStandings, formatter: formatStandRow, label: 'Standings' },
        { key: 'schedule', fileName: 'schedule.txt', arrayKey: 'schedRows', parser: parseSchedule, formatter: formatSchedRow, label: 'Schedule' },
        { key: 'weather', fileName: 'weather.txt', arrayKey: 'weatherRows', parser: parseWeather, formatter: formatWeatherRow, label: 'Weather' },
        { key: 'objectives', fileName: 'objectives.txt', arrayKey: 'objectiveRows', parser: parseObjectives, formatter: formatObjectiveRow, label: 'Objectives' }
      ];

      function getRowsForArray(arrayKey) {
        switch (arrayKey) {
          case 'compRows': return compRows;
          case 'setRows': return setRows;
          case 'taskRows': return taskRows;
          case 'advRows': return advRows;
          case 'standRows': return standRows;
          case 'schedRows': return schedRows;
          case 'weatherRows': return weatherRows;
          case 'objectiveRows': return objectiveRows;
          default: return [];
        }
      }

      function setRowsForArray(arrayKey, rows) {
        switch (arrayKey) {
          case 'compRows': compRows = rows; break;
          case 'setRows': setRows = rows; break;
          case 'taskRows': taskRows = rows; break;
          case 'advRows': advRows = rows; break;
          case 'standRows': standRows = rows; break;
          case 'schedRows': schedRows = rows; break;
          case 'weatherRows': weatherRows = rows; break;
          case 'objectiveRows': objectiveRows = rows; break;
          default: break;
        }
      }

      const editorConfigs = new Map();
      const idRegistry = new Map();
      let uidCounter = 1;
      let idSeed = 1200;

      const structureTypes = [
        { key: 'league', label: 'League Stage', description: 'Single table, round-robin competition with standings.', icon: '⚽' },
        { key: 'groups', label: 'Group Phase', description: 'Multiple pools with advancement to later rounds.', icon: '🧩' },
        { key: 'playoffs', label: 'Playoffs', description: 'Knockout bracket with configurable rounds.', icon: '🏆' }
      ];

      const stageIcons = {
        league: '⚽',
        groups: '🧩',
        playoff: '🏆',
        qualifying: '🎯',
        final: '🥇'
      };

      function parseLines(content, buildRow) {
        const rows = [];
        if (!content) return rows;
        const lines = content.split(/\r?\n/);
        lines.forEach((line, index) => {
          if (!line.trim()) return;
          const parts = line.split(',');
          rows.push(buildRow(parts, line, index));
        });
        return rows;
      }

      function parseCompobj(content) {
        return parseLines(content, (parts, raw, index) => ({
          id: (parts[0] || '').trim(),
          level: (parts[1] || '').trim(),
          code: (parts[2] || '').trim(),
          name: (parts[3] || '').trim(),
          parent: (parts[4] || '').trim(),
          raw,
          index
        }));
      }

      function parseSettings(content) {
        return parseLines(content, (parts, raw, index) => ({
          id: (parts[0] || '').trim(),
          settingKey: (parts[1] || '').trim(),
          value: (parts[2] || '').trim(),
          raw,
          index
        }));
      }

      function parseTasks(content) {
        return parseLines(content, (parts, raw, index) => ({
          trophyId: (parts[0] || '').trim(),
          phase: (parts[1] || '').trim(),
          command: (parts[2] || '').trim(),
          target: (parts[3] || '').trim(),
          ref1: (parts[4] || '').trim(),
          ref2: (parts[5] || '').trim(),
          ref3: (parts[6] || '').trim(),
          raw,
          index
        }));
      }

      function parseAdvancement(content) {
        return parseLines(content, (parts, raw, index) => ({
          fromId: (parts[0] || '').trim(),
          placement: (parts[1] || '').trim(),
          toId: (parts[2] || '').trim(),
          slot: (parts[3] || '').trim(),
          raw,
          index
        }));
      }

      function parseStandings(content) {
        return parseLines(content, (parts, raw, index) => ({
          groupId: (parts[0] || '').trim(),
          teamCount: (parts[1] || '').trim(),
          raw,
          index
        }));
      }

      function parseSchedule(content) {
        return parseLines(content, (parts, raw, index) => ({
          stageId: (parts[0] || '').trim(),
          dateId: (parts[1] || '').trim(),
          matchDay: (parts[2] || '').trim(),
          minGames: (parts[3] || '').trim(),
          maxGames: (parts[4] || '').trim(),
          time: (parts[5] || '').trim(),
          raw,
          index
        }));
      }

      function parseWeather(content) {
        return parseLines(content, (parts, raw, index) => ({
          fedId: (parts[0] || '').trim(),
          dayId: (parts[1] || '').trim(),
          weatherType: (parts[2] || '').trim(),
          param1: (parts[3] || '').trim(),
          param2: (parts[4] || '').trim(),
          param3: (parts[5] || '').trim(),
          param4: (parts[6] || '').trim(),
          start: (parts[7] || '').trim(),
          end: (parts[8] || '').trim(),
          raw,
          index
        }));
      }

      function parseObjectives(content) {
        return parseLines(content, (parts, raw, index) => ({
          groupId: (parts[0] || '').trim(),
          objective: (parts[1] || '').trim(),
          value: (parts[2] || '').trim(),
          raw,
          index
        }));
      }

      function formatCompRow(row) {
        return [row.id, row.level, row.code, row.name, row.parent].join(',');
      }

      function formatSettingRow(row) {
        return [row.id, row.settingKey, row.value].join(',');
      }

      function formatTaskRow(row) {
        return [row.trophyId, row.phase, row.command, row.target, row.ref1, row.ref2, row.ref3].join(',');
      }

      function formatAdvRow(row) {
        return [row.fromId, row.placement, row.toId, row.slot].join(',');
      }

      function formatStandRow(row) {
        return [row.groupId, row.teamCount].join(',');
      }

      function formatSchedRow(row) {
        return [row.stageId, row.dateId, row.matchDay, row.minGames, row.maxGames, row.time].join(',');
      }

      function formatWeatherRow(row) {
        return [row.fedId, row.dayId, row.weatherType, row.param1, row.param2, row.param3, row.param4, row.start, row.end].join(',');
      }

      function formatObjectiveRow(row) {
        return [row.groupId, row.objective, row.value].join(',');
      }

      function rowsToText(rows, formatter) {
        return rows.map((row) => row.raw || formatter(row)).join('\n');
      }

      function createUuid(prefix = 'id') {
        return `${prefix}-${uidCounter++}`;
      }

      function getIdForKey(key) {
        if (!idRegistry.has(key)) {
          idRegistry.set(key, allocateId());
        }
        return idRegistry.get(key);
      }

      function allocateId() {
        const used = new Set(idRegistry.values());
        while (used.has(String(idSeed))) {
          idSeed += 1;
        }
        const assigned = String(idSeed);
        idSeed += 1;
        return assigned;
      }

      function setIdForKey(key, desiredId) {
        const normalized = String(desiredId || '').trim();
        if (!normalized) return false;
        const takenBy = Array.from(idRegistry.entries()).find(([, value]) => value === normalized && value !== idRegistry.get(key));
        if (takenBy) return false;
        idRegistry.set(key, normalized);
        return true;
      }

      function ensureConfig(league) {
        if (!editorConfigs.has(league.uuid)) {
          editorConfigs.set(league.uuid, createDefaultConfig());
        }
        return editorConfigs.get(league.uuid);
      }

      function createDefaultConfig() {
        return {
          structureType: 'league',
          teamCount: 20,
          groupCount: 1,
          rounds: 2,
          homeAndAway: true,
          includePlayoffs: false,
          playoffTeams: 8,
          gamesPerMatchup: 2,
          includeThirdPlace: false,
          matchTime: '20:00',
          planOverrides: null
        };
      }

      function invalidatePlanOverrides(config) {
        if (config && config.planOverrides) {
          config.planOverrides = null;
        }
      }

      function resetRegistries() {
        idRegistry.clear();
        uidCounter = 1;
        idSeed = 1200;
      }

      function convertContextRows(rows, formatter) {
        return rows.map((row, index) => ({ ...row, raw: formatter(row), index }));
      }

      function updateLastBuildFromArrays() {
        state.lastBuild = {
          files: fileDefinitions.map((def) => ({
            name: def.fileName,
            content: rowsToText(getRowsForArray(def.arrayKey), def.formatter)
          })),
          context: {
            compRows,
            setRows,
            taskRows,
            advRows,
            standRows,
            schedRows,
            weatherRows,
            objectiveRows
          }
        };
      }

      function renderFileStatus() {
        const container = $('fileStatusList');
        if (!container) return;
        container.innerHTML = '';
        fileDefinitions.forEach((def) => {
          const status = fileStatus.get(def.key);
          const card = document.createElement('div');
          card.className = 'file-status-card';
          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = def.fileName;
          const meta = document.createElement('div');
          meta.className = 'meta';
          if (status && typeof status.lines === 'number') {
            meta.textContent = `✅ ${status.lines} lines loaded`;
          } else {
            meta.textContent = 'Not loaded yet';
          }
          card.appendChild(title);
          card.appendChild(meta);
          if (status?.message) {
            const note = document.createElement('div');
            note.className = 'meta';
            note.textContent = status.message;
            card.appendChild(note);
          }
          container.appendChild(card);
        });
        renderExportButtons();
      }

      function renderExportButtons() {
        const container = $('fileExportButtons');
        if (!container) return;
        container.innerHTML = '';
        fileDefinitions.forEach((def) => {
          const rows = getRowsForArray(def.arrayKey);
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'btn btn-ghost';
          button.textContent = `Download ${def.fileName}`;
          button.dataset.export = def.key;
          if (!rows.length) {
            button.disabled = true;
            button.classList.add('text-slate-500');
          }
          container.appendChild(button);
        });
        const anyData = fileDefinitions.some((def) => getRowsForArray(def.arrayKey).length);
        const zipButton = document.createElement('button');
        zipButton.type = 'button';
        zipButton.dataset.export = 'zip-all';
        if (anyData) {
          zipButton.className = 'btn btn-primary';
        } else {
          zipButton.className = 'btn btn-ghost text-slate-500';
          zipButton.disabled = true;
        }
        zipButton.textContent = 'Download All (ZIP)';
        container.appendChild(zipButton);
      }

      function hydrateStateFromFiles() {
        resetRegistries();
        editorConfigs.clear();
        state.world = createWorldRoot();
        state.world.federations = [];
        state.federations = state.world.federations;
        state.selectedFederation = null;
        state.selectedNation = null;
        state.selectedCompetition = null;

        if (!compRows.length) {
          state.dataLoaded = false;
          renderAll();
          return;
        }

        const worldMatch = compRows.find((row) => {
          const level = Number(row.level);
          const code = (row.code || '').trim().toUpperCase();
          const parent = String(row.parent ?? '').trim();
          return level <= 0 || code === 'WORLD' || parent === '-1';
        });

        if (worldMatch) {
          const world = createWorldRoot();
          world.name = worldMatch.name || world.name;
          world.code = worldMatch.code || world.code;
          world.level = String(worldMatch.level ?? world.level ?? '0');
          world.parent = String(worldMatch.parent ?? world.parent ?? '-1');
          world.id = String(worldMatch.id ?? '');
          state.world = world;
          setIdForKey('world:root', worldMatch.id);
        } else {
          state.world = createWorldRoot();
        }

        state.world.federations = [];
        state.federations = state.world.federations;
        state.dataLoaded = true;

        const rowById = new Map();
        const children = new Map();
        compRows.forEach((row) => {
          rowById.set(row.id, row);
          const parent = row.parent || '';
          if (!children.has(parent)) children.set(parent, []);
          children.get(parent).push(row);
        });
        children.forEach((list) => list.sort((a, b) => (a.index || 0) - (b.index || 0)));

        const settingsMap = new Map();
        setRows.forEach((row) => {
          if (!settingsMap.has(row.id)) settingsMap.set(row.id, new Map());
          settingsMap.get(row.id).set(row.settingKey, row.value);
        });
        const standingsMap = new Map();
        standRows.forEach((row) => standingsMap.set(row.groupId, Number(row.teamCount) || 0));
        const scheduleByStage = new Map();
        schedRows.forEach((row) => {
          if (!scheduleByStage.has(row.stageId)) scheduleByStage.set(row.stageId, []);
          scheduleByStage.get(row.stageId).push(row);
        });
        const objectiveMap = new Map();
        objectiveRows.forEach((row) => {
          if (!objectiveMap.has(row.groupId)) objectiveMap.set(row.groupId, []);
          objectiveMap.get(row.groupId).push(row);
        });
        const tasksByLeague = new Map();
        taskRows.forEach((row) => {
          if (!tasksByLeague.has(row.trophyId)) tasksByLeague.set(row.trophyId, []);
          tasksByLeague.get(row.trophyId).push(row);
        });

        const federationNameOverrides = new Map([
          ['FIFA', 'FIFA'],
          ['UEFA', 'UEFA'],
          ['AFC', 'AFC'],
          ['CCAF', 'CONCACAF'],
          ['CNBL', 'CONMEBOL']
        ]);

        const topLevelParents = new Set(['', '0', '-1']);
        if (worldRow) topLevelParents.add(String(worldRow.id));

        const getFederationDisplayName = (row) => {
          if (!row) return 'Federation';
          const code = (row.code || '').trim();
          if (federationNameOverrides.has(code)) return federationNameOverrides.get(code);
          const name = (row.name || '').trim();
          return name || code || `Federation ${row.id}`;
        };

        const getNationDisplayName = (row) => {
          if (!row) return 'Nation';
          const name = (row.name || '').trim();
          if (name) return name;
          const code = (row.code || '').trim();
          return code || `Nation ${row.id}`;
        };

        const federationMap = new Map();
        const nationMap = new Map();

        const ensureFederation = (row) => {
          if (!row) return null;
          if (federationMap.has(row.id)) return federationMap.get(row.id);
          const level = Number(row.level);
          const parent = String(row.parent ?? '').trim();
          const code = (row.code || '').trim().toUpperCase();
          if (level !== 1 || code === 'WORLD' || !topLevelParents.has(parent)) return null;
          const federation = {
            uuid: createUuid('fed'),
            id: row.id,
            name: getFederationDisplayName(row),
            code: row.code,
            region: '',
            level,
            order: row.index || 0,
            nations: []
          };
          setIdForKey(`fed:${federation.uuid}`, row.id);
          federationMap.set(row.id, federation);
          state.federations.push(federation);
          return federation;
        };

        const ensureNation = (row) => {
          if (!row) return null;
          if (nationMap.has(row.id)) return nationMap.get(row.id);
          const level = Number(row.level);
          if (level !== 2) return null;
          const parentRow = rowById.get(row.parent);
          const federation = ensureFederation(parentRow);
          if (!federation) return null;
          const nation = {
            uuid: createUuid('nation'),
            id: row.id,
            name: getNationDisplayName(row),
            code: row.code,
            order: row.index || 0,
            competitions: []
          };
          setIdForKey(`nation:${nation.uuid}`, row.id);
          nationMap.set(row.id, nation);
          federation.nations.push(nation);
          return nation;
        };

        const federationRows = compRows
          .filter((row) => ensureFederation(row))
          .sort((a, b) => (a.index || 0) - (b.index || 0));
        // ensureFederation already added them; this loop is to guarantee ordering
        federationRows.forEach((row) => ensureFederation(row));

        const nationRows = compRows
          .filter((row) => Number(row.level) === 2)
          .sort((a, b) => (a.index || 0) - (b.index || 0));
        nationRows.forEach((row) => ensureNation(row));

        const competitionRows = compRows
          .filter((row) => Number(row.level) === 3 && /^c/i.test(row.code || ''))
          .sort((a, b) => (a.index || 0) - (b.index || 0));

        competitionRows.forEach((row) => {
          const parentRow = rowById.get(row.parent);
          const nation = ensureNation(parentRow);
          if (!nation) return;
          const league = {
            uuid: createUuid('league'),
            id: row.id,
            name: row.name,
            code: row.code,
            season: '',
            notes: '',
            order: row.index || 0
          };
          const leagueSettings = settingsMap.get(row.id);
          if (leagueSettings) {
            if (leagueSettings.has('season')) league.season = leagueSettings.get('season');
            if (leagueSettings.has('notes')) league.notes = leagueSettings.get('notes');
          }
          setIdForKey(`league:${league.uuid}`, row.id);
          const config = deriveConfigFromData(
            league,
            row,
            children,
            settingsMap,
            standingsMap,
            scheduleByStage,
            objectiveMap,
            advRows,
            tasksByLeague
          );
          editorConfigs.set(league.uuid, config);
          nation.competitions.push(league);
        });

        state.world.federations.forEach((fed) => {
          fed.nations.forEach((nation) => {
            nation.competitions.sort((a, b) => (a.order || 0) - (b.order || 0));
          });
          fed.nations.sort((a, b) => (a.order || 0) - (b.order || 0));
        });

        state.world.federations.sort((a, b) => (a.order || 0) - (b.order || 0));
        state.federations = state.world.federations;

        const firstFederation = state.federations.find((fed) => fed.nations.some((nation) => nation.competitions.length))
          || state.federations[0]
          || null;
        const firstNation = firstFederation
          ? firstFederation.nations.find((nation) => nation.competitions.length) || firstFederation.nations[0] || null
          : null;
        state.selectedFederation = firstFederation?.uuid || null;
        state.selectedNation = firstNation?.uuid || null;
        state.selectedCompetition = firstNation?.competitions[0]?.uuid || null;
        state.stepIndex = 0;
        renderAll();
      }

      function summarizeScheduleRows(rows) {
        if (!rows || !rows.length) return null;
        return rows.reduce((summary, row, index) => {
          const next = summary;
          next.minGames += Number(row.minGames || 0);
          next.maxGames += Number(row.maxGames || 0);
          if (index === 0 && row.time) next.time = row.time;
          return next;
        }, { minGames: 0, maxGames: 0, time: rows[0]?.time || '' });
      }

      function mapSettingsEntries(settingsMap) {
        const entries = [];
        if (!settingsMap) return entries;
        settingsMap.forEach((value, key) => {
          entries.push({ key, value });
        });
        return entries;
      }

      function cloneScheduleRows(rows) {
        return (rows || []).map((row) => ({
          stageId: row.stageId,
          dateId: row.dateId,
          matchDay: row.matchDay,
          minGames: row.minGames,
          maxGames: row.maxGames,
          time: row.time
        }));
      }

      function cloneObjectiveRows(rows) {
        return (rows || []).map((row) => ({
          objective: row.objective || '',
          value: row.value || ''
        }));
      }

      function cloneTaskRows(rows) {
        return (rows || []).map((row) => ({
          trophyId: row.trophyId,
          phase: row.phase,
          command: row.command,
          target: row.target,
          ref1: row.ref1,
          ref2: row.ref2,
          ref3: row.ref3
        }));
      }

      function deriveConfigFromData(
        league,
        leagueRow,
        children,
        settingsMap,
        standingsMap,
        scheduleByStage,
        objectiveMap,
        advRows,
        tasksByLeague
      ) {
        const config = createDefaultConfig();
        const stageRows = (children.get(leagueRow.id) || [])
          .filter((row) => Number(row.level) === 4 && /^s/i.test(row.code || ''))
          .sort((a, b) => (a.index || 0) - (b.index || 0));
        const isPlayoffStage = (row) => /^s.*po/i.test(row.code || '') || /(playoff|knockout)/i.test(row.name || '');
        const playoffStage = stageRows.find((row) => isPlayoffStage(row)) || null;
        const mainStage = stageRows.find((row) => !isPlayoffStage(row)) || (playoffStage ? null : stageRows[0] || null);

        const groupsForStage = (stage) => (
          stage
            ? (children.get(stage.id) || [])
                .filter((row) => Number(row.level) === 5 && /^g/i.test(row.code || ''))
                .sort((a, b) => (a.index || 0) - (b.index || 0))
            : []
        );
        const mainGroups = groupsForStage(mainStage);
        const playoffGroups = groupsForStage(playoffStage);

        const overrides = { stages: {}, advancements: [], finalTargetId: null, tasks: [], leagueSettings: mapSettingsEntries(settingsMap.get(leagueRow.id)) };

        if (mainStage) {
          const stageKey = `league:${league.uuid}:stage:main`;
          setIdForKey(stageKey, mainStage.id);
          let teamCount = 0;
          const groupOverrides = [];
          mainGroups.forEach((group, index) => {
            setIdForKey(`${stageKey}:group:${index + 1}`, group.id);
            const teams = standingsMap.get(group.id) || Number(group.teamCount) || 0;
            teamCount += teams;
            const objectives = cloneObjectiveRows(objectiveMap.get(group.id) || []);
            groupOverrides.push({
              id: group.id,
              code: group.code,
              name: group.name,
              teamCount: teams,
              objective: objectives[0]?.objective || '',
              objectiveValue: objectives[0]?.value || '',
              objectives
            });
          });
          if (teamCount) config.teamCount = teamCount;
          const groupCount = mainGroups.length || 1;
          config.groupCount = groupCount;
          config.structureType = groupCount > 1 ? 'groups' : 'league';
          const stageSettings = settingsMap.get(mainStage.id);
          if (stageSettings) {
            const rounds = Number(stageSettings.get('rounds'));
            if (rounds) config.rounds = rounds;
            const gamesPerMatch = Number(stageSettings.get('games_per_matchup'));
            if (gamesPerMatch) config.homeAndAway = gamesPerMatch >= 2;
          }
          const scheduleRows = scheduleByStage.get(mainStage.id) || [];
          const scheduleSummary = summarizeScheduleRows(scheduleRows);
          if (scheduleSummary?.time) config.matchTime = scheduleSummary.time;
          overrides.stages.main = {
            id: mainStage.id,
            code: mainStage.code,
            name: mainStage.name,
            settings: mapSettingsEntries(stageSettings),
            scheduleRows: cloneScheduleRows(scheduleRows),
            groups: groupOverrides,
            entryTargetId: groupOverrides[0]?.id || mainStage.id,
            finalGroupId: groupOverrides[groupOverrides.length - 1]?.id || mainStage.id,
            estimatedMinGames: scheduleSummary?.minGames,
            estimatedMaxGames: scheduleSummary?.maxGames,
            includeThird: false
          };
        } else if (playoffGroups.length) {
          const firstGroup = playoffGroups.find((group) => (group.code || '').toUpperCase() !== '3P');
          const teams = firstGroup ? (standingsMap.get(firstGroup.id) || Number(firstGroup.teamCount) || 0) : 0;
          if (teams) config.teamCount = teams;
          config.structureType = 'playoffs';
        }

        if (playoffStage) {
          const stageKey = `league:${league.uuid}:stage:playoff`;
          setIdForKey(stageKey, playoffStage.id);
          let entrants = 0;
          let roundIndex = 1;
          const groupOverrides = [];
          playoffGroups.forEach((group) => {
            const code = (group.code || '').toUpperCase();
            if (code === '3P') {
              config.includeThirdPlace = true;
              setIdForKey(`${stageKey}:third`, group.id);
            } else {
              setIdForKey(`${stageKey}:round:${roundIndex}`, group.id);
              roundIndex += 1;
            }
            const teams = standingsMap.get(group.id) || Number(group.teamCount) || 0;
            entrants = Math.max(entrants, teams);
            const objectives = cloneObjectiveRows(objectiveMap.get(group.id) || []);
            groupOverrides.push({
              id: group.id,
              code: group.code,
              name: group.name,
              teamCount: teams,
              objective: objectives[0]?.objective || '',
              objectiveValue: objectives[0]?.value || '',
              objectives
            });
          });
          if (entrants) config.playoffTeams = entrants;
          const stageSettings = settingsMap.get(playoffStage.id);
          if (stageSettings) {
            const gamesPerMatch = Number(stageSettings.get('games_per_matchup'));
            if (gamesPerMatch) config.gamesPerMatchup = gamesPerMatch;
          }
          const scheduleRows = scheduleByStage.get(playoffStage.id) || [];
          const scheduleSummary = summarizeScheduleRows(scheduleRows);
          if (!mainStage && scheduleSummary?.time) config.matchTime = scheduleSummary.time;
          overrides.stages.playoff = {
            id: playoffStage.id,
            code: playoffStage.code,
            name: playoffStage.name,
            settings: mapSettingsEntries(stageSettings),
            scheduleRows: cloneScheduleRows(scheduleRows),
            groups: groupOverrides,
            entryTargetId: groupOverrides.find((g) => (g.code || '').toUpperCase() !== '3P')?.id || groupOverrides[0]?.id || playoffStage.id,
            finalGroupId: groupOverrides.find((g) => (g.code || '').toUpperCase() === 'GFIN' || (g.code || '').toUpperCase() === 'GPO1')?.id
              || groupOverrides[groupOverrides.length - 1]?.id
              || playoffStage.id,
            estimatedMinGames: scheduleSummary?.minGames,
            estimatedMaxGames: scheduleSummary?.maxGames,
            includeThird: config.includeThirdPlace || false
          };
          if (mainStage) config.includePlayoffs = true;
        } else {
          config.includePlayoffs = false;
        }

        const relevantIds = new Set([
          ...(mainGroups.map((group) => group.id)),
          ...(playoffGroups.map((group) => group.id)),
          ...(playoffStage ? [playoffStage.id] : []),
          ...(mainStage ? [mainStage.id] : [])
        ]);
        overrides.advancements = advRows
          .filter((row) => relevantIds.has(row.fromId) || relevantIds.has(row.toId))
          .map((row) => ({ fromId: row.fromId, placement: row.placement, toId: row.toId, slot: row.slot }));

        const taskList = cloneTaskRows(tasksByLeague.get(leagueRow.id) || []);
        overrides.tasks = taskList;
        const awardTask = taskList.find((row) => (row.command || '').toUpperCase() === 'AWARD_TROPHY');
        if (awardTask?.target) {
          overrides.finalTargetId = awardTask.target;
        }

        config.planOverrides = overrides;
        return config;
      }

      function syncDataFromState() {
        const build = buildProjectFiles();
        compRows = convertContextRows(build.context.compRows, formatCompRow);
        setRows = convertContextRows(build.context.setRows, formatSettingRow);
        taskRows = convertContextRows(build.context.taskRows, formatTaskRow);
        advRows = convertContextRows(build.context.advRows, formatAdvRow);
        standRows = convertContextRows(build.context.standRows, formatStandRow);
        schedRows = convertContextRows(build.context.schedRows, formatSchedRow);
        objectiveRows = convertContextRows(build.context.objectiveRows, formatObjectiveRow);
        weatherRows = convertContextRows(build.context.weatherRows, formatWeatherRow);
        state.lastBuild = build;
        fileDefinitions.forEach((def) => {
          const rows = getRowsForArray(def.arrayKey);
          fileStatus.set(def.key, { lines: rows.length, message: 'Synced from editor' });
        });
        const validationOutput = $('validationOutput');
        if (validationOutput) validationOutput.classList.add('hidden');
        renderFileStatus();
        renderExportResults();
      }

      async function handleFileSelection(definition, file) {
        const text = await file.text();
        const rows = definition.parser(text).map((row, index) => ({ ...row, index }));
        rows.forEach((row) => { if (!row.raw) row.raw = definition.formatter(row); });
        setRowsForArray(definition.arrayKey, rows);
        fileStatus.set(definition.key, { lines: rows.length, message: `Loaded from ${file.name}` });
        updateLastBuildFromArrays();
        const validationOutput = $('validationOutput');
        if (validationOutput) validationOutput.classList.add('hidden');
        renderFileStatus();
        renderExportResults();
        if (compRows.length) {
          hydrateStateFromFiles();
        } else {
          renderAll();
        }
        showMessage(`✅ Loaded ${rows.length} lines from ${definition.fileName}`, 'success');
      }

      async function handleZipSelection(file) {
        const buffer = await file.arrayBuffer();
        const entries = extractZipEntries(buffer);
        const loaded = [];
        fileDefinitions.forEach((def) => {
          const match = entries[def.fileName.toLowerCase()];
          if (match) {
            const text = textDecoder.decode(match);
            const rows = def.parser(text).map((row, index) => ({ ...row, index }));
            rows.forEach((row) => { if (!row.raw) row.raw = def.formatter(row); });
            setRowsForArray(def.arrayKey, rows);
            fileStatus.set(def.key, { lines: rows.length, message: `Loaded from ${file.name}` });
            loaded.push(`${def.fileName} (${rows.length} lines)`);
          }
        });
        if (!loaded.length) {
          showMessage('ZIP did not contain recognizable data files.', 'error');
          return;
        }
        updateLastBuildFromArrays();
        const validationOutput = $('validationOutput');
        if (validationOutput) validationOutput.classList.add('hidden');
        renderFileStatus();
        renderExportResults();
        hydrateStateFromFiles();
        showMessage(`✅ Loaded ${loaded.length} files from ZIP`, 'success');
      }

      function extractZipEntries(buffer) {
        const view = new DataView(buffer);
        let offset = buffer.byteLength - 22;
        let endFound = false;
        while (offset >= 0) {
          if (view.getUint32(offset, true) === 0x06054b50) {
            endFound = true;
            break;
          }
          offset -= 1;
        }
        if (!endFound) return {};
        const total = view.getUint16(offset + 10, true);
        const centralOffset = view.getUint32(offset + 16, true);
        const entries = {};
        let ptr = centralOffset;
        for (let i = 0; i < total; i += 1) {
          if (view.getUint32(ptr, true) !== 0x02014b50) break;
          const nameLength = view.getUint16(ptr + 28, true);
          const extraLength = view.getUint16(ptr + 30, true);
          const commentLength = view.getUint16(ptr + 32, true);
          const compression = view.getUint16(ptr + 10, true);
          const localHeaderOffset = view.getUint32(ptr + 42, true);
          const nameBytes = new Uint8Array(buffer, ptr + 46, nameLength);
          const rawName = textDecoder.decode(nameBytes);
          const normalized = rawName.split('/').pop() || rawName;
          const fileName = normalized.toLowerCase();
          ptr += 46 + nameLength + extraLength + commentLength;
          if (compression !== 0) continue; // Only support stored entries
          if (view.getUint32(localHeaderOffset, true) !== 0x04034b50) continue;
          const localNameLength = view.getUint16(localHeaderOffset + 26, true);
          const localExtraLength = view.getUint16(localHeaderOffset + 28, true);
          const size = view.getUint32(localHeaderOffset + 18, true);
          const dataStart = localHeaderOffset + 30 + localNameLength + localExtraLength;
          entries[fileName] = new Uint8Array(buffer, dataStart, size);
        }
        return entries;
      }

      function downloadText(name, text) {
        const blob = new Blob([text], { type: 'text/plain' });
        downloadBlob(name, blob);
      }

      function validateFiles() {
        const issues = [];
        const compIdSet = new Set(compRows.map((row) => row.id));
        const stageIdSet = new Set(
          compRows
            .filter((row) => {
              const level = Number(row.level);
              return level >= 4 || level === 2;
            })
            .map((row) => row.id)
        );
        const groupIdSet = new Set(
          compRows
            .filter((row) => {
              const level = Number(row.level);
              return level >= 5 || level === 3;
            })
            .map((row) => row.id)
        );
        const leagueIdSet = new Set(
          compRows
            .filter((row) => {
              const level = Number(row.level);
              return level === 3 || level === 1;
            })
            .map((row) => row.id)
        );
        const federationIdSet = new Set(
          compRows
            .filter((row) => {
              const level = Number(row.level);
              return level === 2 || level === 0;
            })
            .map((row) => row.id)
        );
        compRows.forEach((row) => {
          if (Number(row.level) > 1 && row.parent && !compIdSet.has(row.parent)) {
            issues.push(`Competition entry ${row.id} references missing parent ${row.parent}.`);
          }
        });
        setRows.forEach((row) => {
          if (row.id && !compIdSet.has(row.id)) {
            issues.push(`Setting ${row.settingKey} references unknown node ${row.id}.`);
          }
        });
        standRows.forEach((row) => {
          if (row.groupId && !groupIdSet.has(row.groupId)) {
            issues.push(`Standings entry references missing group ${row.groupId}.`);
          }
        });
        objectiveRows.forEach((row) => {
          if (row.groupId && !groupIdSet.has(row.groupId)) {
            issues.push(`Objective ${row.objective} references missing group ${row.groupId}.`);
          }
        });
        schedRows.forEach((row) => {
          if (row.stageId && !stageIdSet.has(row.stageId)) {
            issues.push(`Schedule ${row.dateId} references missing stage ${row.stageId}.`);
          }
        });
        advRows.forEach((row) => {
          if (row.fromId && !groupIdSet.has(row.fromId)) {
            issues.push(`Advancement ${row.fromId} references missing group ${row.fromId}.`);
          }
          if (row.toId && !groupIdSet.has(row.toId)) {
            issues.push(`Advancement ${row.fromId} references missing group ${row.toId}.`);
          }
        });
        taskRows.forEach((row) => {
          if (row.trophyId && !leagueIdSet.has(row.trophyId)) {
            issues.push(`Task trophy ${row.trophyId} does not match a competition.`);
          }
          if (row.target && !compIdSet.has(row.target)) {
            issues.push(`Task target ${row.target} is missing from compobj.`);
          }
        });
        weatherRows.forEach((row) => {
          if (row.fedId && !federationIdSet.has(row.fedId)) {
            issues.push(`Weather pattern references missing federation ${row.fedId}.`);
          }
        });
        return issues;
      }

      function ensureDefaultWeatherTemplates() {
        const result = { addedRows: 0, federationCount: 0 };
        if (!compRows.length) return result;
        const federationIds = Array.from(
          new Set(
            compRows
              .filter((row) => Number(row.level) === 1 && row.id)
              .map((row) => row.id)
          )
        );
        if (!federationIds.length) return result;
        const coveredFederations = new Set(
          weatherRows
            .filter((row) => row.fedId)
            .map((row) => row.fedId)
        );
        const generatedRows = [];
        federationIds.forEach((fedId) => {
          if (coveredFederations.has(fedId)) return;
          result.federationCount += 1;
          for (let month = 1; month <= 12; month += 1) {
            const newRow = {
              fedId,
              dayId: String(month),
              weatherType: '80',
              param1: '0',
              param2: '0',
              param3: '0',
              param4: '20',
              start: '1600',
              end: '1900'
            };
            newRow.raw = formatWeatherRow(newRow);
            generatedRows.push(newRow);
          }
        });
        if (!generatedRows.length) return result;
        const startIndex = weatherRows.length;
        generatedRows.forEach((row, offset) => {
          weatherRows.push({ ...row, index: startIndex + offset });
        });
        weatherRows.forEach((row, index) => {
          row.index = index;
          if (!row.raw) row.raw = formatWeatherRow(row);
        });
        result.addedRows = generatedRows.length;
        updateLastBuildFromArrays();
        fileStatus.set('weather', {
          lines: weatherRows.length,
          message: `Auto-generated default weather for ${result.federationCount} federation${
            result.federationCount === 1 ? '' : 's'
          }.`
        });
        renderFileStatus();
        renderExportResults();
        return result;
      }

      function handleValidateAll() {
        let issues = validateFiles();
        const weatherUpdate = ensureDefaultWeatherTemplates();
        if (weatherUpdate.addedRows) {
          issues = validateFiles();
        }
        const output = $('validationOutput');
        if (!output) return;
        output.classList.remove('hidden');
        const autoWeatherNotice = weatherUpdate.addedRows
          ? `<div class="text-xs text-slate-600 mt-2">Added default neutral weather for ${weatherUpdate.federationCount} federation${
              weatherUpdate.federationCount === 1 ? '' : 's'
            }.</div>`
          : '';
        if (!issues.length) {
          output.innerHTML = `<div class="text-emerald-600 font-semibold">All references look good.</div><div class="text-sm text-slate-600">Every linked ID resolves correctly.</div>${autoWeatherNotice}`;
          showMessage('Validation complete — all references resolved.', 'success');
        } else {
          output.innerHTML = `<div class="text-red-600 font-semibold">${issues.length} issue${issues.length === 1 ? '' : 's'} detected:</div><ul>${issues
            .map((issue) => `<li>${issue}</li>`)
            .join('')}</ul>${autoWeatherNotice}`;
          showMessage('Validation finished with warnings.', 'error');
        }
      }

      function describeCompetitionType(config) {
        if (!config) return 'Unknown';
        if (config.structureType === 'playoffs' && !config.includePlayoffs) return 'Cup';
        if (config.structureType === 'playoffs') return 'Hybrid';
        if (config.includePlayoffs) return 'Hybrid';
        return 'League';
      }


      function createFederation(name, code, region) {
        const federation = {
          uuid: createUuid('fed'),
          name,
          code,
          region,
          nations: []
        };
        getIdForKey(`fed:${federation.uuid}`);
        return federation;
      }

      function createNation(name, code) {
        const nation = {
          uuid: createUuid('nation'),
          name,
          code,
          competitions: []
        };
        getIdForKey(`nation:${nation.uuid}`);
        return nation;
      }

      function createCompetition(name, code, season) {
        const league = {
          uuid: createUuid('league'),
          name,
          code,
          season,
          notes: ''
        };
        getIdForKey(`league:${league.uuid}`);
        editorConfigs.set(league.uuid, createDefaultConfig());
        return league;
      }

      function getSelectedFederation() {
        return state.federations.find((f) => f.uuid === state.selectedFederation) || null;
      }

      function getSelectedNation() {
        const federation = getSelectedFederation();
        if (!federation) return null;
        return federation.nations.find((nation) => nation.uuid === state.selectedNation) || null;
      }

      function getSelectedCompetition() {
        const nation = getSelectedNation();
        if (!nation) return null;
        return nation.competitions.find((league) => league.uuid === state.selectedCompetition) || null;
      }

      function showMessage(text, tone = 'info') {
        const box = $('globalMessage');
        if (!box) return;
        const classMap = {
          info: 'message message-info',
          success: 'message message-success',
          error: 'message message-error'
        };
        box.className = classMap[tone] || classMap.info;
        box.textContent = text;
        box.classList.remove('hidden');
        clearTimeout(showMessage.timer);
        showMessage.timer = setTimeout(() => box.classList.add('hidden'), 4000);
      }

      function renderFederations() {
        const container = $('federationList');
        if (!container) return;
        container.innerHTML = '';
        const worldCard = document.createElement('div');
        worldCard.className = 'selector-card selector-card-static';
        const worldCount = state.federations.length;
        worldCard.innerHTML = `
          <div class="selector-icon">🌐</div>
          <div class="selector-title">${state.world.name}</div>
          <div class="selector-sub">${worldCount} federation${worldCount === 1 ? '' : 's'}</div>
        `;
        container.appendChild(worldCard);
        if (!state.dataLoaded) {
          const notice = document.createElement('div');
          notice.className = 'callout';
          notice.textContent = 'Import competition data to populate federations.';
          container.appendChild(notice);
          return;
        }
        state.federations.forEach((fed) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.fedId = fed.uuid;
          btn.className = 'selector-card' + (state.selectedFederation === fed.uuid ? ' selector-card-active' : '');
          const nationCount = fed.nations.length;
          const leagueCount = fed.nations.reduce((sum, nation) => sum + nation.competitions.length, 0);
          const idInfo = state.developerMode ? `<div class="selector-dev">ID ${getIdForKey(`fed:${fed.uuid}`)}</div>` : '';
          btn.innerHTML = `
            <div class="selector-icon">🌍</div>
            <div class="selector-title">${fed.name || 'Untitled Federation'}</div>
            <div class="selector-sub">${fed.code || 'No code'} • ${nationCount} nation${nationCount === 1 ? '' : 's'} • ${leagueCount} competition${leagueCount === 1 ? '' : 's'}</div>
            ${fed.region ? `<div class="selector-sub">${fed.region}</div>` : ''}
            ${idInfo}
          `;
          container.appendChild(btn);
        });

        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'selector-card selector-card-add';
        addBtn.textContent = '+ New Federation';
        addBtn.onclick = () => {
          const name = prompt('Federation name', 'New Federation');
          if (!name) return;
          const code = prompt('Federation code', name.slice(0, 4).toUpperCase());
          const region = prompt('Region or description', '');
          const federation = createFederation(name, code || name.slice(0, 4).toUpperCase(), region || '');
          const nationName = `${name} Nation`;
          const nationCode = `${(code || name.slice(0, 4)).toUpperCase()}_N`;
          const defaultNation = createNation(nationName, nationCode);
          federation.nations.push(defaultNation);
          state.federations.push(federation);
          state.selectedFederation = federation.uuid;
          state.selectedNation = defaultNation.uuid;
          state.selectedCompetition = null;
          syncDataFromState();
          renderAll();
          showMessage('Federation added.', 'success');
        };
        container.appendChild(addBtn);
      }

      function renderCompetitions() {
        const nationContainer = $('nationList');
        const competitionContainer = $('leagueList');
        const summary = $('leaguePanelSummary');
        if (!nationContainer || !competitionContainer || !summary) return;
        nationContainer.innerHTML = '';
        competitionContainer.innerHTML = '';
        const searchInput = $('leagueSearch');
        if (searchInput) {
          searchInput.disabled = !state.dataLoaded;
          searchInput.classList.toggle('text-slate-500', !state.dataLoaded);
        }
        const addLeagueButton = $('addLeagueBtn');
        if (addLeagueButton) {
          addLeagueButton.disabled = !state.dataLoaded;
          addLeagueButton.classList.toggle('text-slate-500', !state.dataLoaded);
        }
        if (!state.dataLoaded) {
          summary.textContent = 'Import competition data to browse nations and competitions.';
          const notice = document.createElement('div');
          notice.className = 'callout';
          notice.textContent = 'No data loaded. Use the Import tools to load compobj, settings, and related files.';
          nationContainer.appendChild(notice.cloneNode(true));
          competitionContainer.appendChild(notice);
          return;
        }
        const federation = getSelectedFederation();
        if (!federation) {
          summary.textContent = 'Select a federation to browse its nations and competitions.';
          return;
        }

        if (!federation.nations.length) {
          summary.textContent = `${federation.name} has no nations defined yet.`;
          const empty = document.createElement('div');
          empty.className = 'callout';
          empty.textContent = 'No nations available. Import data or add nations to continue.';
          nationContainer.appendChild(empty);
          return;
        }

        let nation = getSelectedNation();
        if (!nation && federation.nations.length) {
          nation = federation.nations[0];
          state.selectedNation = nation.uuid;
        }
        const activeNationId = nation?.uuid || state.selectedNation;

        federation.nations.forEach((nationItem) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.nationId = nationItem.uuid;
          btn.className = 'selector-card' + (activeNationId === nationItem.uuid ? ' selector-card-active' : '');
          const leagueCount = nationItem.competitions.length;
          const idInfo = state.developerMode ? `<div class="selector-dev">ID ${getIdForKey(`nation:${nationItem.uuid}`)}</div>` : '';
          btn.innerHTML = `
            <div class="selector-icon">🏳️</div>
            <div class="selector-title">${nationItem.name || 'Untitled Nation'}</div>
            <div class="selector-sub">${nationItem.code || 'No code'} • ${leagueCount} competition${leagueCount === 1 ? '' : 's'}</div>
            ${idInfo}
          `;
          nationContainer.appendChild(btn);
        });

        if (!nation) {
          summary.textContent = `Select a nation within ${federation.name} to view competitions.`;
          return;
        }

        if (!nation.competitions.some((league) => league.uuid === state.selectedCompetition)) {
          state.selectedCompetition = nation.competitions[0]?.uuid || null;
        }

        const filtered = nation.competitions.filter((league) => {
          if (!state.leagueSearch) return true;
          const q = state.leagueSearch.toLowerCase();
          return (
            (league.name || '').toLowerCase().includes(q) ||
            (league.code || '').toLowerCase().includes(q)
          );
        });

        summary.textContent = `${filtered.length} competition${filtered.length === 1 ? '' : 's'} in ${nation.name} • ${federation.name}`;

        filtered.forEach((league) => {
          const config = ensureConfig(league);
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.competitionId = league.uuid;
          btn.className = 'selector-card' + (state.selectedCompetition === league.uuid ? ' selector-card-active' : '');
          const stageIcon = structureTypes.find((s) => s.key === config.structureType)?.icon || '⚙️';
          const typeLabel = describeCompetitionType(config);
          const teamLabel = `${config.teamCount} team${config.teamCount === 1 ? '' : 's'}`;
          const idInfo = state.developerMode ? `<div class="selector-dev">ID ${getIdForKey(`league:${league.uuid}`)}</div>` : '';
          btn.innerHTML = `
            <div class="selector-icon">${stageIcon}</div>
            <div class="selector-title">${league.name || 'Untitled Competition'}</div>
            <div class="selector-sub">${league.code || 'No code'} • ${typeLabel} • ${teamLabel}</div>
            ${league.season ? `<div class="selector-sub">Season ${league.season}</div>` : ''}
            ${idInfo}
          `;
          competitionContainer.appendChild(btn);
        });

        if (!filtered.length) {
          const empty = document.createElement('div');
          empty.className = 'callout';
          empty.textContent = 'No competitions yet. Create one to begin designing.';
          competitionContainer.appendChild(empty);
        }
      }

      function updateStepControls(hasData, hasCompetition) {
        const prevStepBtn = $('prevStepBtn');
        const nextStepBtn = $('nextStepBtn');
        const maxIndex = stepLabels.length - 1;
        const enabled = hasData && hasCompetition;
        if (state.stepIndex > maxIndex) state.stepIndex = maxIndex;
        if (state.stepIndex < 0) state.stepIndex = 0;
        if (prevStepBtn) {
          prevStepBtn.disabled = !enabled || state.stepIndex <= 0;
        }
        if (nextStepBtn) {
          nextStepBtn.disabled = !enabled || state.stepIndex >= maxIndex;
        }
      }

      function renderEditor() {
        const editor = $('editorContent');
        const summary = $('editorSummary');
        if (!editor || !summary) return;
        editor.innerHTML = '';
        if (!state.dataLoaded) {
          summary.textContent = 'Import competition data to unlock the guided editor.';
          const placeholder = document.createElement('div');
          placeholder.className = 'callout';
          placeholder.textContent = 'Upload competition files to begin editing stages and structures.';
          editor.appendChild(placeholder);
          updateStepControls(false, false);
          return;
        }
        const federation = getSelectedFederation();
        const nation = getSelectedNation();
        const league = getSelectedCompetition();
        if (!federation || !nation || !league) {
          summary.textContent = 'Choose a competition to unlock the guided editor.';
          const placeholder = document.createElement('div');
          placeholder.className = 'callout';
          placeholder.textContent = 'Select a competition card from the League Browser to begin editing its structure.';
          editor.appendChild(placeholder);
          updateStepControls(true, false);
          return;
        }
        const config = ensureConfig(league);
        summary.textContent = `${federation.name} • ${nation.name} • ${league.name}`;
        updateStepControls(true, true);
        renderStepper(editor);
        renderStepContent(editor, league, config, federation, nation);
      }

      function renderStepper(editor) {
        const stepper = document.createElement('div');
        stepper.className = 'stepper';
        stepLabels.forEach((label, index) => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'step-pill' + (state.stepIndex === index ? ' step-pill-active' : '');
          pill.innerHTML = `<span>${index + 1}</span>${label}`;
          pill.onclick = () => {
            state.stepIndex = index;
            renderEditor();
          };
          stepper.appendChild(pill);
        });
        editor.appendChild(stepper);
      }

      function renderStepContent(editor, league, config, federation, nation) {
        const content = document.createElement('div');
        content.className = 'flex flex-col gap-6';
        const step = state.stepIndex;
        if (step === 0) {
          content.appendChild(renderOverviewStep(league, config, federation, nation));
        } else if (step === 1) {
          content.appendChild(renderStructureStep(league, config));
        } else if (step === 2) {
          content.appendChild(renderStagesStep(league, config));
        } else {
          content.appendChild(renderReviewStep(league, config, federation, nation));
        }
        editor.appendChild(content);
      }

      function renderOverviewStep(league, config, federation, nation) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-6';

        const breadcrumb = document.createElement('div');
        breadcrumb.className = 'badge';
        breadcrumb.textContent = `${federation.name} • ${nation.name} • ${league.name}`;
        container.appendChild(breadcrumb);

        const grid = document.createElement('div');
        grid.className = 'input-grid';

        grid.appendChild(createField('Competition Name', league.name, 'text', (value) => {
          league.name = value;
          renderCompetitions();
          renderEditor();
        }));

        grid.appendChild(createField('Short Code', league.code, 'text', (value) => {
          league.code = value.toUpperCase();
          renderCompetitions();
        }, 'Uppercase identifier used in generated files.'));

        grid.appendChild(createField('Season', league.season, 'text', (value) => {
          league.season = value;
          renderCompetitions();
        }, 'Optional season label for settings.'));

        grid.appendChild(createField('Notes', league.notes, 'textarea', (value) => {
          league.notes = value;
        }, 'Internal notes for collaborators.'));

        container.appendChild(grid);

        if (state.developerMode) {
          const devBox = document.createElement('div');
          devBox.className = 'callout';
          const fedId = getIdForKey(`fed:${federation.uuid}`);
          const leagueId = getIdForKey(`league:${league.uuid}`);
          devBox.innerHTML = `
            <div class="font-semibold mb-2">Developer identifiers</div>
            <div class="flex flex-wrap gap-3">
              <div>Federation ID: <code>${fedId}</code></div>
              <div>Competition ID: <input id="leagueIdInput" value="${leagueId}" class="px-2 py-1" style="width:6rem" /></div>
            </div>
          `;
          setTimeout(() => {
            const input = $('leagueIdInput');
            if (input) {
              input.addEventListener('change', () => {
                const ok = setIdForKey(`league:${league.uuid}`, input.value);
                if (!ok) {
                  showMessage('ID already in use or invalid.', 'error');
                  input.value = getIdForKey(`league:${league.uuid}`);
                } else {
                  showMessage('Competition ID updated.', 'success');
                  syncDataFromState();
                }
              });
            }
          }, 10);
          container.appendChild(devBox);
        }

        return container;
      }

      function createField(label, value, type, onChange, helper) {
        const wrapper = document.createElement('div');
        wrapper.className = 'field';
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        wrapper.appendChild(labelEl);
        let input;
        if (type === 'textarea') {
          input = document.createElement('textarea');
          input.rows = 3;
        } else {
          input = document.createElement('input');
          input.type = type;
        }
        input.value = value || '';
        input.addEventListener('input', (event) => {
          onChange(event.target.value);
          syncDataFromState();
        });
        wrapper.appendChild(input);
        if (helper) {
          const helperEl = document.createElement('small');
          helperEl.textContent = helper;
          wrapper.appendChild(helperEl);
        }
        return wrapper;
      }

      function renderStructureStep(league, config) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-6';

        const structureRow = document.createElement('div');
        structureRow.className = 'flex flex-wrap gap-2';
        structureTypes.forEach((type) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'pill-button' + (config.structureType === type.key ? ' pill-button-active' : '');
          button.innerHTML = `${type.icon} ${type.label}`;
          button.onclick = () => {
            invalidatePlanOverrides(config);
            config.structureType = type.key;
            if (type.key === 'league') config.groupCount = 1;
            syncDataFromState();
            renderEditor();
          };
          button.title = type.description;
          structureRow.appendChild(button);
        });
        container.appendChild(structureRow);

        const sliders = document.createElement('div');
        sliders.className = 'flex flex-col gap-4';
        sliders.appendChild(createRange('Teams', 2, 64, config.teamCount, 1, (value) => {
          invalidatePlanOverrides(config);
          config.teamCount = value;
          renderCompetitions();
        }));

        const groupDisabled = config.structureType === 'league' || config.structureType === 'playoffs';
        sliders.appendChild(createRange('Groups', 1, 16, config.groupCount, 1, (value) => {
          invalidatePlanOverrides(config);
          config.groupCount = value;
        }, groupDisabled, groupDisabled ? 'Group count is fixed for this structure.' : 'Distribute teams evenly across groups.'));

        sliders.appendChild(createRange('Rounds', 1, 6, config.rounds, 1, (value) => {
          invalidatePlanOverrides(config);
          config.rounds = value;
        }, false, 'Number of round-robin cycles.'));

        container.appendChild(sliders);

        const toggles = document.createElement('div');
        toggles.className = 'flex flex-col gap-3';
        toggles.appendChild(createToggle('Home & Away fixtures', config.homeAndAway, (checked) => {
          invalidatePlanOverrides(config);
          config.homeAndAway = checked;
        }));
        toggles.appendChild(createToggle('Include playoff stage', config.includePlayoffs, (checked) => {
          invalidatePlanOverrides(config);
          config.includePlayoffs = checked;
          renderEditor();
        }, 'Generates a knockout bracket after the main stage.'));
        container.appendChild(toggles);

        return container;
      }

      function createRange(label, min, max, value, step, onChange, disabled = false, helper) {
        const wrapper = document.createElement('div');
        wrapper.className = 'range-row';
        const labelRow = document.createElement('label');
        labelRow.innerHTML = `<span>${label}</span><span>${value}</span>`;
        wrapper.appendChild(labelRow);
        const input = document.createElement('input');
        input.type = 'range';
        input.min = String(min);
        input.max = String(max);
        input.step = String(step);
        input.value = String(value);
        input.disabled = disabled;
        input.addEventListener('input', (event) => {
          const newValue = Number(event.target.value);
          labelRow.innerHTML = `<span>${label}</span><span>${newValue}</span>`;
        });
        input.addEventListener('change', (event) => {
          const newValue = Number(event.target.value);
          onChange(newValue);
          syncDataFromState();
        });
        wrapper.appendChild(input);
        if (helper) {
          const helperEl = document.createElement('small');
          helperEl.textContent = helper;
          wrapper.appendChild(helperEl);
        }
        return wrapper;
      }

      function createToggle(label, value, onChange, helper) {
        const row = document.createElement('div');
        row.className = 'toggle-row';
        const info = document.createElement('div');
        info.className = 'toggle-info';
        const title = document.createElement('div');
        title.className = 'font-semibold';
        title.textContent = label;
        info.appendChild(title);
        if (helper) {
          const helperEl = document.createElement('small');
          helperEl.textContent = helper;
          info.appendChild(helperEl);
        }
        const toggle = document.createElement('label');
        toggle.className = 'switch';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = value;
        input.addEventListener('change', (event) => {
          onChange(event.target.checked);
          syncDataFromState();
        });
        const slider = document.createElement('span');
        slider.className = 'slider';
        toggle.appendChild(input);
        toggle.appendChild(slider);
        row.appendChild(info);
        row.appendChild(toggle);
        return row;
      }

      function renderStagesStep(league, config) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-5';

        if (config.includePlayoffs || config.structureType === 'playoffs') {
          container.appendChild(createRange('Playoff entrants', 2, Math.max(2, config.teamCount), config.playoffTeams, 2, (value) => {
            invalidatePlanOverrides(config);
            config.playoffTeams = value;
            renderEditor();
          }, false, 'Number of teams advancing to the knockout bracket.'));

          container.appendChild(createRange('Games per matchup', 1, 3, config.gamesPerMatchup, 1, (value) => {
            invalidatePlanOverrides(config);
            config.gamesPerMatchup = value;
          }, false, 'Best-of series length for playoff rounds.'));

          container.appendChild(createToggle('Third-place match', config.includeThirdPlace, (checked) => {
            invalidatePlanOverrides(config);
            config.includeThirdPlace = checked;
            renderEditor();
          }));
        }

        const plan = createCompetitionPlan(league, config);
        const stageList = document.createElement('div');
        stageList.className = 'stage-list';

        plan.stages.forEach((stage) => {
          const details = document.createElement('details');
          details.className = 'stage-details';
          details.open = stage.key === 'main';
          const summary = document.createElement('summary');
          const header = document.createElement('div');
          header.className = 'stage-header';
          const icon = document.createElement('div');
          icon.className = 'stage-icon';
          icon.textContent = stage.icon || '⚙️';
          const title = document.createElement('div');
          title.className = 'flex flex-col';
          title.innerHTML = `<span class="font-semibold">${stage.name}</span><span class="text-sm text-slate-600">${stage.groups.length} group${stage.groups.length === 1 ? '' : 's'} • ${stage.rounds} round${stage.rounds === 1 ? '' : 's'}</span>`;
          header.appendChild(icon);
          header.appendChild(title);
          summary.appendChild(header);
          details.appendChild(summary);

          const body = document.createElement('div');
          body.className = 'details-body';
          const summaryRow = document.createElement('div');
          summaryRow.className = 'stage-summary';
          summaryRow.innerHTML = `
            <span class="badge">${stage.rounds} round${stage.rounds === 1 ? '' : 's'}</span>
            <span class="badge">${stage.estimatedMinGames} games</span>
            <span class="badge${state.developerMode ? '' : ' hidden'}">Stage ID ${stage.id}</span>
          `;
          body.appendChild(summaryRow);

          const list = document.createElement('div');
          list.className = 'flex flex-col gap-2';
          stage.groups.forEach((group) => {
            const item = document.createElement('div');
            item.className = 'badge';
            const idBadge = state.developerMode ? ` • ID ${group.id}` : '';
            item.textContent = `${group.name} • ${group.teamCount} teams${idBadge}`;
            list.appendChild(item);
          });
          body.appendChild(list);

          if (stage.entryTargetId && state.developerMode) {
            const idBlock = document.createElement('div');
            idBlock.className = 'callout';
            idBlock.innerHTML = `Stage key: <code>${stage.stageKey}</code><br>Stage ID: <code>${stage.id}</code>`;
            body.appendChild(idBlock);
          }

          details.appendChild(body);
          stageList.appendChild(details);
        });

        container.appendChild(stageList);
        return container;
      }

      function renderReviewStep(league, config, federation, nation) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-5';

        const plan = createCompetitionPlan(league, config);
        const summary = document.createElement('div');
        summary.className = 'callout';
        const totalGroups = plan.stages.reduce((sum, stage) => sum + stage.groups.length, 0);
        summary.innerHTML = `
          <div class="font-semibold mb-2">Summary</div>
          <div>${config.teamCount} teams • ${totalGroups} group${totalGroups === 1 ? '' : 's'} • ${plan.stages.length} stage${plan.stages.length === 1 ? '' : 's'}</div>
          <div>${plan.stages.map((stage) => stage.name).join(' → ')}</div>
        `;
        container.appendChild(summary);

        const tree = document.createElement('div');
        tree.className = 'flex flex-col gap-2';
        const fedId = getIdForKey(`fed:${federation.uuid}`);
        const nationId = getIdForKey(`nation:${nation.uuid}`);
        const leagueId = getIdForKey(`league:${league.uuid}`);
        tree.innerHTML = `
          <div class="badge">${federation.name}${state.developerMode ? ` • ${fedId}` : ''}</div>
          <div class="badge" style="margin-left:1.5rem;">${nation.name}${state.developerMode ? ` • ${nationId}` : ''}</div>
          <div class="badge" style="margin-left:3rem;">${league.name}${state.developerMode ? ` • ${leagueId}` : ''}</div>
        `;
        plan.stages.forEach((stage) => {
          const stageEl = document.createElement('div');
          stageEl.className = 'badge';
          stageEl.style.marginLeft = '4.5rem';
          const idBadge = state.developerMode ? ` • ${stage.id}` : '';
          stageEl.textContent = `${stage.name}${idBadge}`;
          tree.appendChild(stageEl);
          stage.groups.forEach((group) => {
            const groupEl = document.createElement('div');
            groupEl.className = 'badge';
            groupEl.style.marginLeft = '6rem';
            const idInfo = state.developerMode ? ` • ${group.id}` : '';
            groupEl.textContent = `${group.name}${idInfo}`;
            tree.appendChild(groupEl);
          });
        });
        container.appendChild(tree);

        const notes = document.createElement('div');
        notes.className = 'text-sm text-slate-600';
        notes.textContent = 'Use Build & Export to regenerate compobj, settings, tasks, advancements, standings, schedule, objectives, and weather files. All references remain synchronized.';
        container.appendChild(notes);

        return container;
      }

      function applyStageOverrides(stage, override) {
        if (!override) return;
        if (override.name) stage.name = override.name;
        if (override.code) stage.code = override.code;
        if (override.entryTargetId) stage.entryTargetId = override.entryTargetId;
        if (override.finalGroupId) stage.finalGroupId = override.finalGroupId;
        if (override.includeThird !== undefined && override.includeThird !== null) {
          stage.includeThird = Boolean(override.includeThird);
        }
        if (override.estimatedMinGames !== undefined && override.estimatedMinGames !== null) {
          stage.estimatedMinGames = Number(override.estimatedMinGames);
        }
        if (override.estimatedMaxGames !== undefined && override.estimatedMaxGames !== null) {
          stage.estimatedMaxGames = Number(override.estimatedMaxGames);
        }
        if (override.scheduleRows?.length) {
          stage.scheduleRows = override.scheduleRows.map((row) => ({
            stageId: row.stageId,
            dateId: row.dateId,
            matchDay: row.matchDay,
            minGames: row.minGames,
            maxGames: row.maxGames,
            time: row.time
          }));
        }
        const groupsById = new Map(stage.groups.map((group) => [group.id, group]));
        override.groups?.forEach((groupOverride, index) => {
          const group = groupsById.get(groupOverride.id) || stage.groups[index];
          if (!group) return;
          if (groupOverride.name) group.name = groupOverride.name;
          if (groupOverride.code) group.code = groupOverride.code;
          if (groupOverride.teamCount !== undefined && groupOverride.teamCount !== null && groupOverride.teamCount !== '') {
            group.teamCount = Number(groupOverride.teamCount);
          }
          if (groupOverride.objective) group.objective = groupOverride.objective;
          if (groupOverride.objectiveValue) group.objectiveValue = groupOverride.objectiveValue;
          if (groupOverride.objectives?.length) {
            group.objectives = groupOverride.objectives.map((obj) => ({
              objective: obj.objective || '',
              value: obj.value || ''
            }));
            const primary = group.objectives[0];
            if (primary) {
              group.objective = primary.objective || group.objective;
              group.objectiveValue = primary.value || group.objectiveValue;
            }
          }
        });
      }

      function applyPlanOverrides(plan, overrides) {
        if (!overrides) return plan;
        plan.stages.forEach((stage) => {
          applyStageOverrides(stage, overrides.stages?.[stage.key]);
        });
        if (overrides.advancements?.length) {
          plan.advancements = overrides.advancements.map((adv) => ({
            fromId: adv.fromId,
            placement: adv.placement,
            toId: adv.toId,
            slot: adv.slot
          }));
        }
        if (overrides.finalTargetId) {
          plan.finalTargetId = overrides.finalTargetId;
        }
        return plan;
      }

      function createCompetitionPlan(league, config) {
        const plan = { stages: [], advancements: [], finalTargetId: null };
        const structure = config.structureType;
        const teamCount = Math.max(2, config.teamCount);

        if (structure === 'playoffs' && !config.includePlayoffs) {
          const playoffStage = buildPlayoffStage('playoff', league, config, teamCount);
          plan.stages.push(playoffStage);
          plan.finalTargetId = playoffStage.finalGroupId;
          return applyPlanOverrides(plan, config.planOverrides);
        }

        const groupStage = buildGroupStage('main', league, config, teamCount);
        plan.stages.push(groupStage);

        if (config.includePlayoffs) {
          const playoffTeams = Math.min(config.playoffTeams || teamCount, teamCount);
          const playoffStage = buildPlayoffStage('playoff', league, config, playoffTeams);
          plan.stages.push(playoffStage);
          plan.finalTargetId = playoffStage.finalGroupId;
          plan.advancements.push(...computeAdvancements(groupStage.groups, playoffStage.entryTargetId, playoffTeams));
        } else {
          plan.finalTargetId = groupStage.finalGroupId;
        }

        return applyPlanOverrides(plan, config.planOverrides);
      }

      function buildGroupStage(key, league, config, teamCount) {
        const groupCount = config.structureType === 'league' ? 1 : Math.max(1, config.groupCount);
        const stageKey = `league:${league.uuid}:stage:${key}`;
        const id = getIdForKey(stageKey);
        const rounds = Math.max(1, config.rounds);
        const homeAwayMultiplier = config.homeAndAway ? 2 : 1;
        const baseTeams = Math.floor(teamCount / groupCount);
        const remainder = teamCount % groupCount;
        const groups = [];
        for (let i = 0; i < groupCount; i += 1) {
          const teamsInGroup = baseTeams + (i < remainder ? 1 : 0);
          const groupKey = `${stageKey}:group:${i + 1}`;
          const groupId = getIdForKey(groupKey);
          const groupCode = groupCount === 1 ? 'G1' : `G${i + 1}`;
          const defaultObjective = config.includePlayoffs ? 'ReachPlayoffs' : 'WinGroup';
          const defaultValue = config.includePlayoffs ? String(Math.max(1, Math.floor((config.playoffTeams || 1) / groupCount))) : '1';
          groups.push({
            id: groupId,
            name: groupCount === 1 ? `${league.name} Table` : `Group ${String.fromCharCode(65 + i)}`,
            code: groupCode,
            teamCount: teamsInGroup,
            objective: defaultObjective,
            objectiveValue: defaultValue,
            objectives: [{ objective: defaultObjective, value: defaultValue }]
          });
        }
        const matchesPerGroup = groups.reduce((sum, group) => sum + ((group.teamCount * (group.teamCount - 1)) / 2) * homeAwayMultiplier, 0);
        const estimatedGames = matchesPerGroup * rounds;
        const stageCode = key === 'main'
          ? (config.structureType === 'groups' ? 'SGROUP' : 'SMAIN')
          : `S${key.toUpperCase()}`;
        return {
          key,
          stageKey,
          id,
          icon: stageIcons[config.structureType] || stageIcons.league,
          name: config.structureType === 'groups' ? 'Group Stage' : 'League Stage',
          code: stageCode,
          rounds,
          gamesPerMatchup: homeAwayMultiplier,
          groups,
          entryTargetId: groups[0]?.id || id,
          finalGroupId: groups[groups.length - 1]?.id || id,
          finalTargetId: groups[groups.length - 1]?.id || id,
          estimatedMinGames: estimatedGames,
          estimatedMaxGames: estimatedGames,
          includeThird: false
        };
      }

      function buildPlayoffStage(key, league, config, totalTeams) {
        const safeTeams = Math.max(2, totalTeams);
        const rounds = Math.max(1, Math.ceil(Math.log2(safeTeams)));
        const stageKey = `league:${league.uuid}:stage:${key}`;
        const id = getIdForKey(stageKey);
        const names = ['Round of 64', 'Round of 32', 'Round of 16', 'Quarterfinal', 'Semifinal', 'Final'];
        const startIndex = Math.max(0, names.length - rounds);
        const groups = [];
        let totalMatches = 0;
        for (let r = 0; r < rounds; r += 1) {
          const teamsInRound = Math.pow(2, rounds - r);
          const matches = teamsInRound / 2;
          totalMatches += matches * (config.gamesPerMatchup || 1);
          const groupKey = `${stageKey}:round:${r + 1}`;
          const groupId = getIdForKey(groupKey);
          const roundCode = `GPO${rounds - r}`;
          groups.push({
            id: groupId,
            name: names[startIndex + r] || `Round ${r + 1}`,
            code: roundCode,
            teamCount: teamsInRound,
            objective: r === rounds - 1 ? 'WinFinal' : 'Advance',
            objectiveValue: '1',
            objectives: [{ objective: r === rounds - 1 ? 'WinFinal' : 'Advance', value: '1' }]
          });
        }
        if (config.includeThirdPlace) {
          const thirdKey = `${stageKey}:third`;
          const thirdId = getIdForKey(thirdKey);
          groups.push({
            id: thirdId,
            name: 'Third Place Playoff',
            code: 'G3P',
            teamCount: 2,
            objective: 'WinMatch',
            objectiveValue: '1',
            objectives: [{ objective: 'WinMatch', value: '1' }]
          });
          totalMatches += config.gamesPerMatchup || 1;
        }
        const finalGroup = config.includeThirdPlace ? groups[groups.length - 2] : groups[groups.length - 1];
        return {
          key,
          stageKey,
          id,
          icon: stageIcons.playoff,
          name: key === 'playoff' ? 'Playoffs' : 'Knockout Stage',
          code: key === 'playoff' ? 'SPLAYOFF' : `S${key.toUpperCase()}`,
          rounds,
          gamesPerMatchup: config.gamesPerMatchup || 1,
          groups,
          entryTargetId: groups[0]?.id || id,
          finalGroupId: finalGroup?.id || id,
          estimatedMinGames: totalMatches,
          estimatedMaxGames: totalMatches,
          includeThird: Boolean(config.includeThirdPlace)
        };
      }

      function computeAdvancements(groups, targetGroupId, totalSlots) {
        if (!groups.length || !targetGroupId) return [];
        const slots = Math.max(1, totalSlots);
        const perGroup = Math.max(1, Math.floor(slots / groups.length));
        let remainder = slots % groups.length;
        const adv = [];
        let slotIndex = 1;
        groups.forEach((group) => {
          let advCount = perGroup;
          if (remainder > 0) {
            advCount += 1;
            remainder -= 1;
          }
          for (let placement = 1; placement <= advCount; placement += 1) {
            adv.push({
              fromId: group.id,
              placement: String(placement),
              toId: targetGroupId,
              slot: String(slotIndex)
            });
            slotIndex += 1;
          }
        });
        return adv;
      }

      function validateProject() {
        const issues = [];
        if (!state.federations.length) {
          issues.push('No federations defined.');
        }
        state.federations.forEach((fed) => {
          if (!fed.name) issues.push('Federation missing a name.');
          if (!fed.code) issues.push(`Federation ${fed.name || fed.uuid} missing a code.`);
          if (!fed.nations.length) issues.push(`${fed.name} has no nations.`);
          fed.nations.forEach((nation) => {
            if (!nation.name) issues.push(`Nation under ${fed.name} is missing a name.`);
            if (!nation.code) issues.push(`${nation.name || 'Nation'} in ${fed.name} is missing a code.`);
            if (!nation.competitions.length) issues.push(`${nation.name || 'Nation'} in ${fed.name} has no competitions.`);
            nation.competitions.forEach((league) => {
              if (!league.name) issues.push('A competition is missing a name.');
              if (!league.code) issues.push(`${league.name || 'Competition'} is missing a short code.`);
              const config = ensureConfig(league);
              if (config.teamCount < 2) issues.push(`${league.name}: team count must be at least 2.`);
              if (config.structureType !== 'league' && config.groupCount > config.teamCount) issues.push(`${league.name}: group count exceeds teams.`);
              if (config.includePlayoffs) {
                if (!Number.isInteger(config.playoffTeams) || config.playoffTeams < 2) issues.push(`${league.name}: playoff entrants must be at least 2.`);
                if (config.playoffTeams > config.teamCount) issues.push(`${league.name}: playoff entrants cannot exceed team count.`);
              }
            });
          });
        });
        return issues;
      }

      function buildProjectFiles() {
        const context = {
          compRows: [],
          setRows: [],
          taskRows: [],
          advRows: [],
          standRows: [],
          schedRows: [],
          objectiveRows: [],
          weatherRows: weatherRows.map((row) => ({
            fedId: row.fedId,
            dayId: row.dayId,
            weatherType: row.weatherType,
            param1: row.param1,
            param2: row.param2,
            param3: row.param3,
            param4: row.param4,
            start: row.start,
            end: row.end
          }))
        };

        const weatherByFed = new Map();
        context.weatherRows.forEach((row) => {
          if (!weatherByFed.has(row.fedId)) weatherByFed.set(row.fedId, []);
          weatherByFed.get(row.fedId).push(row);
        });

        const worldId = getIdForKey('world:root');
        context.compRows.push({
          id: worldId,
          level: String(state.world.level ?? '0'),
          code: state.world.code || 'WORLD',
          name: state.world.name || 'World',
          parent: String(state.world.parent ?? '-1')
        });

        state.federations.forEach((fed) => {
          const fedId = getIdForKey(`fed:${fed.uuid}`);
          context.compRows.push({ id: fedId, level: '1', code: fed.code || '', name: fed.name || 'Federation', parent: worldId });
          if (!weatherByFed.has(fedId) || !weatherByFed.get(fedId).length) {
            for (let month = 1; month <= 12; month += 1) {
              const weatherRow = {
                fedId,
                dayId: String(month),
                weatherType: '80',
                param1: '0',
                param2: '0',
                param3: '0',
                param4: '20',
                start: '1600',
                end: '1900'
              };
              context.weatherRows.push(weatherRow);
              if (!weatherByFed.has(fedId)) weatherByFed.set(fedId, []);
              weatherByFed.get(fedId).push(weatherRow);
            }
          }

          fed.nations.forEach((nation) => {
            const nationId = getIdForKey(`nation:${nation.uuid}`);
            context.compRows.push({ id: nationId, level: '2', code: nation.code || '', name: nation.name || 'Nation', parent: fedId });

            nation.competitions.forEach((league) => {
              const leagueId = getIdForKey(`league:${league.uuid}`);
              const config = ensureConfig(league);
              context.compRows.push({ id: leagueId, level: '3', code: league.code || '', name: league.name || 'Competition', parent: nationId });

              const leagueSettings = new Map();
              (config.planOverrides?.leagueSettings || []).forEach((entry) => {
                leagueSettings.set(entry.key, entry.value);
              });
              leagueSettings.set('season', league.season || '');
              leagueSettings.set('structure_type', config.structureType);
              leagueSettings.set('team_count', String(config.teamCount));
              if (config.structureType !== 'league') {
                leagueSettings.set('group_count', String(config.groupCount));
              }
              leagueSettings.set('include_playoffs', config.includePlayoffs ? 'true' : 'false');
              leagueSettings.forEach((value, key) => {
                context.setRows.push({ id: leagueId, settingKey: key, value: String(value ?? '') });
              });

              const plan = createCompetitionPlan(league, config);
              let stageIndex = 1;
              plan.stages.forEach((stage) => {
                context.compRows.push({ id: stage.id, level: '4', code: stage.code, name: stage.name, parent: leagueId });
                const stageSettings = new Map();
                (config.planOverrides?.stages?.[stage.key]?.settings || []).forEach((entry) => {
                  stageSettings.set(entry.key, entry.value);
                });
                if (stage.key === 'main') {
                  stageSettings.set('rounds', String(config.rounds));
                  stageSettings.set('games_per_matchup', String(config.homeAndAway ? 2 : 1));
                } else {
                  stageSettings.set('games_per_matchup', String(config.gamesPerMatchup || 1));
                }
                stageSettings.forEach((value, key) => {
                  context.setRows.push({ id: stage.id, settingKey: key, value: String(value ?? '') });
                });

                const scheduleRows = stage.scheduleRows && stage.scheduleRows.length
                  ? stage.scheduleRows
                  : [{
                      stageId: stage.id,
                      dateId: `AUTO-${stageIndex}`,
                      matchDay: '1',
                      minGames: String(stage.estimatedMinGames),
                      maxGames: String(stage.estimatedMaxGames),
                      time: config.matchTime || '20:00'
                    }];
                scheduleRows.forEach((row, idx) => {
                  context.schedRows.push({
                    stageId: stage.id,
                    dateId: row.dateId || `AUTO-${stageIndex}${idx ? `-${idx}` : ''}`,
                    matchDay: row.matchDay || '1',
                    minGames: String(row.minGames ?? stage.estimatedMinGames ?? ''),
                    maxGames: String(row.maxGames ?? stage.estimatedMaxGames ?? ''),
                    time: row.time || config.matchTime || '20:00'
                  });
                });

                stage.groups.forEach((group) => {
                  context.compRows.push({ id: group.id, level: '5', code: group.code, name: group.name, parent: stage.id });
                  context.standRows.push({ groupId: group.id, teamCount: String(group.teamCount) });
                  const objectives = group.objectives && group.objectives.length
                    ? group.objectives
                    : [{ objective: group.objective, value: group.objectiveValue }];
                  objectives.forEach((objective) => {
                    context.objectiveRows.push({
                      groupId: group.id,
                      objective: objective.objective || '',
                      value: objective.value || ''
                    });
                  });
                });
                stageIndex += 1;
              });

              plan.advancements.forEach((adv) => {
                context.advRows.push({ fromId: adv.fromId, placement: adv.placement, toId: adv.toId, slot: adv.slot });
              });

              const tasks = (config.planOverrides?.tasks || []).map((row) => ({
                trophyId: row.trophyId,
                phase: row.phase,
                command: row.command,
                target: row.target,
                ref1: row.ref1,
                ref2: row.ref2,
                ref3: row.ref3
              }));
              const trophyIndex = tasks.findIndex((row) => (row.command || '').toUpperCase() === 'AWARD_TROPHY');
              if (trophyIndex >= 0) {
                tasks[trophyIndex] = {
                  ...tasks[trophyIndex],
                  trophyId: leagueId,
                  target: plan.finalTargetId || leagueId
                };
              } else {
                tasks.push({
                  trophyId: leagueId,
                  phase: 'FINALE',
                  command: 'AWARD_TROPHY',
                  target: plan.finalTargetId || leagueId,
                  ref1: '',
                  ref2: '',
                  ref3: ''
                });
              }
              tasks.forEach((row) => {
                context.taskRows.push({
                  trophyId: String(row.trophyId || leagueId),
                  phase: String(row.phase || ''),
                  command: String(row.command || ''),
                  target: String(row.target || ''),
                  ref1: String(row.ref1 || ''),
                  ref2: String(row.ref2 || ''),
                  ref3: String(row.ref3 || '')
                });
              });
            });
          });
        });

        const files = [
          { name: 'compobj.txt', content: context.compRows.map((r) => [r.id, r.level, r.code, r.name, r.parent].join(',')).join('\n') },
          { name: 'settings.txt', content: context.setRows.map((r) => [r.id, r.settingKey, r.value].join(',')).join('\n') },
          { name: 'tasks.txt', content: context.taskRows.map((r) => [r.trophyId, r.phase, r.command, r.target, r.ref1, r.ref2, r.ref3].join(',')).join('\n') },
          { name: 'advancement.txt', content: context.advRows.map((r) => [r.fromId, r.placement, r.toId, r.slot].join(',')).join('\n') },
          { name: 'standings.txt', content: context.standRows.map((r) => [r.groupId, r.teamCount].join(',')).join('\n') },
          { name: 'schedule.txt', content: context.schedRows.map((r) => [r.stageId, r.dateId, r.matchDay, r.minGames, r.maxGames, r.time].join(',')).join('\n') },
          { name: 'objectives.txt', content: context.objectiveRows.map((r) => [r.groupId, r.objective, r.value].join(',')).join('\n') },
          { name: 'weather.txt', content: context.weatherRows.map((r) => [r.fedId, r.dayId, r.weatherType, r.param1, r.param2, r.param3, r.param4, r.start, r.end].join(',')).join('\n') }
        ];

        return { files, context };
      }

      function createZip(files) {
        const encoder = new TextEncoder();
        const fileRecords = [];
        const chunks = [];
        let offset = 0;
        files.forEach((file) => {
          const nameBytes = encoder.encode(file.name);
          const dataBytes = encoder.encode(file.content);
          const crc = crc32(dataBytes);
          const localHeader = new Uint8Array(30 + nameBytes.length);
          const localView = new DataView(localHeader.buffer);
          let p = 0;
          localView.setUint32(p, 0x04034b50, true); p += 4;
          localView.setUint16(p, 20, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint32(p, crc, true); p += 4;
          localView.setUint32(p, dataBytes.length, true); p += 4;
          localView.setUint32(p, dataBytes.length, true); p += 4;
          localView.setUint16(p, nameBytes.length, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localHeader.set(nameBytes, 30);
          chunks.push(localHeader);
          chunks.push(dataBytes);
          fileRecords.push({ nameBytes, dataBytes, crc, offset });
          offset += localHeader.length + dataBytes.length;
        });

        const centralChunks = [];
        let centralSize = 0;
        fileRecords.forEach((record) => {
          const centralHeader = new Uint8Array(46 + record.nameBytes.length);
          const view = new DataView(centralHeader.buffer);
          let p = 0;
          view.setUint32(p, 0x02014b50, true); p += 4;
          view.setUint16(p, 20, true); p += 2;
          view.setUint16(p, 20, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint32(p, record.crc, true); p += 4;
          view.setUint32(p, record.dataBytes.length, true); p += 4;
          view.setUint32(p, record.dataBytes.length, true); p += 4;
          view.setUint16(p, record.nameBytes.length, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint32(p, 0, true); p += 4;
          view.setUint32(p, record.offset, true); p += 4;
          centralHeader.set(record.nameBytes, 46);
          centralChunks.push(centralHeader);
          centralSize += centralHeader.length;
        });

        const centralOffset = offset;
        const totalSize = offset + centralSize + 22;
        const zipBuffer = new Uint8Array(totalSize);
        let cursor = 0;
        chunks.forEach((chunk) => { zipBuffer.set(chunk, cursor); cursor += chunk.length; });
        centralChunks.forEach((chunk) => { zipBuffer.set(chunk, cursor); cursor += chunk.length; });

        const end = new DataView(zipBuffer.buffer, cursor, 22);
        end.setUint32(0, 0x06054b50, true);
        end.setUint16(4, 0, true);
        end.setUint16(6, 0, true);
        end.setUint16(8, fileRecords.length, true);
        end.setUint16(10, fileRecords.length, true);
        end.setUint32(12, centralSize, true);
        end.setUint32(16, centralOffset, true);
        end.setUint16(20, 0, true);

        return new Blob([zipBuffer], { type: 'application/zip' });
      }

      const CRC32_TABLE = new Uint32Array(256).map((_, n) => {
        let c = n;
        for (let k = 0; k < 8; k += 1) {
          c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        return c >>> 0;
      });

      function crc32(bytes) {
        let crc = 0 ^ (-1);
        for (let i = 0; i < bytes.length; i += 1) {
          const y = (crc ^ bytes[i]) & 0xff;
          crc = (crc >>> 8) ^ CRC32_TABLE[y];
        }
        return (crc ^ (-1)) >>> 0;
      }

      function downloadBlob(filename, blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 400);
      }

      function renderExportResults() {
        const container = $('exportResults');
        if (!container) return;
        container.innerHTML = '';
        if (!state.lastBuild) {
          const msg = document.createElement('div');
          msg.className = 'text-sm text-slate-600';
          msg.textContent = 'Run Build & Export to see generated files.';
          container.appendChild(msg);
          return;
        }
        const { files } = state.lastBuild;
        const chips = document.createElement('div');
        chips.className = 'export-grid';
        files.forEach((file) => {
          const chip = document.createElement('div');
          chip.className = 'export-chip';
          chip.innerHTML = `<span>${file.name}</span><span>${file.content.split(/\n/).filter(Boolean).length} lines</span>`;
          chips.appendChild(chip);
        });
        container.appendChild(chips);

        files.forEach((file) => {
          const details = document.createElement('details');
          details.className = 'stage-details';
          details.innerHTML = `<summary>${file.name}</summary>`;
          const pre = document.createElement('pre');
          pre.className = 'export-text';
          pre.textContent = file.content || '(empty)';
          details.appendChild(pre);
          container.appendChild(details);
        });
      }

      function handleBuildExport() {
        const issues = validateProject();
        if (issues.length) {
          showMessage('Build blocked by validation errors.', 'error');
          const container = $('exportResults');
          if (container) {
            container.innerHTML = '';
            const callout = document.createElement('div');
            callout.className = 'callout callout-error';
            callout.innerHTML = `<div class="font-semibold mb-2">Please fix the following:</div><ul>${issues.map((issue) => `<li>${issue}</li>`).join('')}</ul>`;
            container.appendChild(callout);
          }
          return;
        }
        syncDataFromState();
        const zip = createZip(state.lastBuild.files);
        downloadBlob('competition_export.zip', zip);
        showMessage('Build succeeded — ZIP download started.', 'success');
      }

      function handleDownloadZip() {
        if (!state.lastBuild) {
          showMessage('Nothing to download yet — run Build & Export first.', 'info');
          return;
        }
        syncDataFromState();
        const zip = createZip(state.lastBuild.files);
        downloadBlob('competition_export.zip', zip);
      }

      async function handleCopyText() {
        if (!state.lastBuild) {
          showMessage('Nothing to copy yet — run Build & Export first.', 'info');
          return;
        }
        syncDataFromState();
        const combined = state.lastBuild.files.map((file) => `# ${file.name}\n${file.content}`).join('\n\n');
        try {
          await navigator.clipboard.writeText(combined);
          showMessage('All file contents copied to clipboard.', 'success');
        } catch (err) {
          showMessage('Clipboard copy failed.', 'error');
        }
      }

      function renderAll() {
        renderFileStatus();
        renderFederations();
        renderCompetitions();
        renderEditor();
        renderExportResults();
      }

      function setupEventHandlers() {
        const fileButtons = $('fileButtonGrid');
        if (fileButtons) {
          fileButtons.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-file]');
            if (!button) return;
            const key = button.dataset.file;
            const input = $(`fileInput-${key}`);
            if (input) input.click();
          });
        }

        fileDefinitions.forEach((def) => {
          const input = $(`fileInput-${def.key}`);
          if (!input) return;
          input.addEventListener('change', async (event) => {
            const file = event.target.files?.[0];
            if (file) await handleFileSelection(def, file);
            event.target.value = '';
          });
        });

        const zipButton = $('importZipBtn');
        const zipInput = $('zipInput');
        if (zipButton && zipInput) {
          zipButton.addEventListener('click', () => zipInput.click());
          zipInput.addEventListener('change', async (event) => {
            const file = event.target.files?.[0];
            if (file) await handleZipSelection(file);
            event.target.value = '';
          });
        }

        const exportButtons = $('fileExportButtons');
        if (exportButtons) {
          exportButtons.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-export]');
            if (!button) return;
            const key = button.dataset.export;
            if (key === 'zip-all') {
              handleDownloadZip();
              return;
            }
            const def = fileDefinitions.find((item) => item.key === key);
            if (!def) return;
            const rows = getRowsForArray(def.arrayKey);
            if (!rows.length) return;
            downloadText(def.fileName, rowsToText(rows, def.formatter));
          });
        }

        const validateAllBtn = $('validateAllBtn');
        if (validateAllBtn) {
          validateAllBtn.addEventListener('click', handleValidateAll);
        }

        const federationList = $('federationList');
        if (federationList) {
          federationList.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-fed-id]');
            if (!button) return;
            state.selectedFederation = button.dataset.fedId;
            const federation = getSelectedFederation();
            const firstNation = federation
              ? federation.nations.find((nation) => nation.competitions.length) || federation.nations[0] || null
              : null;
            state.selectedNation = firstNation?.uuid || null;
            state.selectedCompetition = firstNation?.competitions[0]?.uuid || null;
            renderAll();
          });
        }

        const nationList = $('nationList');
        if (nationList) {
          nationList.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-nation-id]');
            if (!button) return;
            state.selectedNation = button.dataset.nationId;
            const nation = getSelectedNation();
            state.selectedCompetition = nation?.competitions[0]?.uuid || null;
            renderCompetitions();
            renderEditor();
          });
        }

        const leagueList = $('leagueList');
        if (leagueList) {
          leagueList.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-competition-id]');
            if (!button) return;
            state.selectedCompetition = button.dataset.competitionId;
            renderEditor();
            renderCompetitions();
          });
        }

        const search = $('leagueSearch');
        if (search) {
          search.addEventListener('input', (event) => {
            state.leagueSearch = event.target.value;
            renderCompetitions();
          });
        }

        const addLeagueBtn = $('addLeagueBtn');
        if (addLeagueBtn) {
          addLeagueBtn.addEventListener('click', () => {
            if (!state.dataLoaded) {
              showMessage('Import competition data before adding new competitions.', 'info');
              return;
            }
            const federation = getSelectedFederation();
            const nation = getSelectedNation();
            if (!federation) {
              showMessage('Select a federation first.', 'info');
              return;
            }
            if (!nation) {
              showMessage('Select a nation first.', 'info');
              return;
            }
            const name = prompt('Competition name', 'New Competition');
            if (!name) return;
            const code = prompt('Short code', name.slice(0, 4).toUpperCase());
            const season = prompt('Season label', new Date().getFullYear());
            const league = createCompetition(name, (code || name.slice(0, 4)).toUpperCase(), season || '');
            nation.competitions.push(league);
            state.selectedCompetition = league.uuid;
            syncDataFromState();
            renderAll();
            showMessage('Competition created.', 'success');
          });
        }

        const buildBtn = $('buildExportBtn');
        if (buildBtn) buildBtn.addEventListener('click', handleBuildExport);
        const zipBtn = $('downloadZipBtn');
        if (zipBtn) zipBtn.addEventListener('click', handleDownloadZip);
        const copyBtn = $('copyTextBtn');
        if (copyBtn) copyBtn.addEventListener('click', handleCopyText);

        const themeToggle = $('themeToggle');
        if (themeToggle) {
          themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark');
            themeToggle.textContent = document.body.classList.contains('dark') ? 'Toggle Light' : 'Toggle Dark';
          });
        }

        const developerToggle = $('developerToggle');
        if (developerToggle) {
          developerToggle.addEventListener('click', () => {
            state.developerMode = !state.developerMode;
            developerToggle.textContent = state.developerMode ? 'Developer Mode • On' : 'Developer Mode';
            renderAll();
          });
        }

        const prevStepBtn = $('prevStepBtn');
        const nextStepBtn = $('nextStepBtn');
        if (prevStepBtn) {
          prevStepBtn.addEventListener('click', () => {
            state.stepIndex = Math.max(0, state.stepIndex - 1);
            renderEditor();
          });
        }
        if (nextStepBtn) {
          nextStepBtn.addEventListener('click', () => {
            const maxIndex = stepLabels.length - 1;
            state.stepIndex = Math.min(maxIndex, state.stepIndex + 1);
            renderEditor();
          });
        }
      }

      function init() {
        state.world = createWorldRoot();
        state.federations = state.world.federations;
        state.selectedFederation = null;
        state.selectedNation = null;
        state.selectedCompetition = null;
        state.dataLoaded = false;
        setupEventHandlers();
        renderAll();
        showMessage('Import competition data to begin.', 'info');
      }

      init();
    })();
  </script>
</body>
</html>
