<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Competition Architect</title>
  <style>
    :root {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: light dark;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: #f1f5f9;
      color: #0f172a;
    }
    body.dark {
      background: #0f172a;
      color: #e2e8f0;
    }
    body.dark .card { background: #1e293b; border-color: #334155; box-shadow: none; }
    body.dark .bg-slate-50 { background: #1f2937; }
    body.dark .bg-slate-100 { background: #16213b; }
    body.dark .border-slate-200 { border-color: #334155; }
    body.dark .text-slate-600 { color: #cbd5f5; }
    body.dark .text-slate-500 { color: #94a3b8; }
    body.dark input,
    body.dark textarea,
    body.dark select {
      background: #0f172a;
      color: #e2e8f0;
      border-color: #475569;
    }
    a { color: inherit; }
    button { font: inherit; cursor: pointer; border: none; background: none; }
    input, textarea, select { font: inherit; border: 1px solid #cbd5f5; border-radius: 0.55rem; padding: 0.55rem 0.75rem; }
    textarea { resize: vertical; }
    ::placeholder { color: #94a3b8; }

    .min-h-screen { min-height: 100vh; }
    .flex { display: flex; }
    .flex-col { flex-direction: column; }
    .flex-row { flex-direction: row; }
    .flex-wrap { flex-wrap: wrap; }
    .items-center { align-items: center; }
    .items-start { align-items: flex-start; }
    .justify-between { justify-content: space-between; }
    .justify-start { justify-content: flex-start; }
    .justify-center { justify-content: center; }
    .justify-end { justify-content: flex-end; }
    .gap-1 { gap: 0.25rem; }
    .gap-2 { gap: 0.5rem; }
    .gap-3 { gap: 0.75rem; }
    .gap-4 { gap: 1rem; }
    .gap-5 { gap: 1.25rem; }
    .gap-6 { gap: 1.5rem; }
    .gap-8 { gap: 2rem; }
    .gap-10 { gap: 2.5rem; }
    .p-2 { padding: 0.5rem; }
    .p-3 { padding: 0.75rem; }
    .p-4 { padding: 1rem; }
    .p-5 { padding: 1.25rem; }
    .p-6 { padding: 1.5rem; }
    .p-8 { padding: 2rem; }
    .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
    .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
    .px-4 { padding-left: 1rem; padding-right: 1rem; }
    .px-5 { padding-left: 1.25rem; padding-right: 1.25rem; }
    .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
    .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
    .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
    .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
    .py-4 { padding-top: 1rem; padding-bottom: 1rem; }
    .py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
    .mt-1 { margin-top: 0.25rem; }
    .mt-2 { margin-top: 0.5rem; }
    .mt-3 { margin-top: 0.75rem; }
    .mt-4 { margin-top: 1rem; }
    .mt-5 { margin-top: 1.25rem; }
    .mt-6 { margin-top: 1.5rem; }
    .mt-8 { margin-top: 2rem; }
    .mt-10 { margin-top: 2.5rem; }
    .mb-2 { margin-bottom: 0.5rem; }
    .mb-3 { margin-bottom: 0.75rem; }
    .mb-4 { margin-bottom: 1rem; }
    .mb-6 { margin-bottom: 1.5rem; }
    .mb-8 { margin-bottom: 2rem; }
    .mx-auto { margin-left: auto; margin-right: auto; }
    .w-full { width: 100%; }
    .w-1\/3 { width: 33.333%; }
    .w-2\/3 { width: 66.666%; }
    .shrink-0 { flex-shrink: 0; }
    .grow { flex-grow: 1; }
    .text-xs { font-size: 0.75rem; }
    .text-sm { font-size: 0.875rem; }
    .text-base { font-size: 1rem; }
    .text-lg { font-size: 1.125rem; }
    .text-xl { font-size: 1.25rem; }
    .text-2xl { font-size: 1.5rem; }
    .text-3xl { font-size: 1.75rem; }
    .font-medium { font-weight: 500; }
    .font-semibold { font-weight: 600; }
    .font-bold { font-weight: 700; }
    .uppercase { text-transform: uppercase; letter-spacing: 0.08em; }
    .rounded { border-radius: 0.5rem; }
    .rounded-md { border-radius: 0.65rem; }
    .rounded-lg { border-radius: 0.85rem; }
    .rounded-full { border-radius: 9999px; }
    .border { border: 1px solid #e2e8f0; }
    .border-slate-200 { border-color: #e2e8f0; }
    .shadow-sm { box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08); }
    .shadow { box-shadow: 0 22px 45px -18px rgba(15, 23, 42, 0.35); }
    .bg-white { background: #ffffff; }
    .bg-slate-50 { background: #f8fafc; }
    .bg-slate-100 { background: #f1f5f9; }
    .bg-slate-800 { background: #1e293b; }
    .text-slate-500 { color: #64748b; }
    .text-slate-600 { color: #475569; }
    .text-slate-700 { color: #334155; }
    .text-slate-900 { color: #0f172a; }
    .text-emerald-600 { color: #059669; }
    .text-red-600 { color: #dc2626; }
    .text-blue-600 { color: #2563eb; }
    .text-amber-500 { color: #f59e0b; }
    .bg-emerald-500 { background: #10b981; }
    .bg-emerald-600 { background: #059669; }
    .bg-blue-600 { background: #2563eb; }
    .bg-blue-700 { background: #1d4ed8; }
    .bg-red-600 { background: #dc2626; }
    .bg-red-700 { background: #b91c1c; }
    .bg-amber-500 { background: #f59e0b; }
    .bg-amber-600 { background: #d97706; }
    .text-white { color: #ffffff; }
    .text-center { text-align: center; }
    .text-right { text-align: right; }
    .whitespace-nowrap { white-space: nowrap; }
    .leading-tight { line-height: 1.3; }
    .tracking-wide { letter-spacing: 0.08em; }
    .hidden { display: none !important; }

    .page { max-width: 1320px; margin: 0 auto; padding: 2.5rem 1.75rem 4rem; display: flex; flex-direction: column; gap: 2rem; }
    header.page-header { display: flex; flex-wrap: wrap; gap: 1rem; justify-content: space-between; align-items: flex-start; }
    header.page-header h1 { margin: 0; }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.6rem 1.05rem;
      border-radius: 0.75rem;
      font-size: 0.9rem;
      font-weight: 600;
      border: none;
      background: #e2e8f0;
      color: #0f172a;
      transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 14px 32px -18px rgba(15, 23, 42, 0.35); }
    .btn-primary { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; }
    .btn-accent { background: linear-gradient(135deg, #10b981, #059669); color: #ffffff; }
    .btn-ghost { background: transparent; border: 1px solid #cbd5f5; color: inherit; }
    .btn-outline { background: transparent; border: 1px solid rgba(37,99,235,0.35); color: #1d4ed8; }

    .card { background: #ffffff; border-radius: 1rem; border: 1px solid #e2e8f0; box-shadow: 0 18px 40px -24px rgba(15, 23, 42, 0.35); display: flex; flex-direction: column; }
    .card-header { display: flex; justify-content: space-between; align-items: center; padding: 1.25rem 1.5rem; border-bottom: 1px solid #e2e8f0; }
    .card-body { padding: 1.5rem; display: flex; flex-direction: column; gap: 1rem; }

    .selector-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0.85rem; }
    .selector-card { position: relative; overflow: hidden; border-radius: 0.95rem; border: 1px solid #e2e8f0; padding: 1rem; background: #f8fafc; display: flex; flex-direction: column; gap: 0.65rem; text-align: left; transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease; }
    .selector-card:hover { transform: translateY(-2px); box-shadow: 0 18px 35px -22px rgba(15, 23, 42, 0.35); }
    .selector-card-active { border-color: #1d4ed8; box-shadow: 0 18px 30px -22px rgba(37, 99, 235, 0.45); background: linear-gradient(135deg, rgba(37,99,235,0.12), rgba(15,23,42,0.03)); }
    .selector-card-add { border: 1px dashed #94a3b8; background: #ffffff; justify-content: center; align-items: center; font-weight: 600; color: #64748b; }
    .selector-card-add:hover { border-color: #1d4ed8; color: #1d4ed8; box-shadow: none; transform: translateY(0); }
    .selector-icon { font-size: 1.5rem; }
    .selector-title { font-weight: 600; font-size: 1rem; }
    .selector-sub { font-size: 0.8rem; color: #475569; }
    .selector-dev { font-size: 0.75rem; color: #94a3b8; }

    .wizard { display: flex; flex-direction: column; gap: 1.5rem; }
    .stepper { display: flex; gap: 0.75rem; flex-wrap: wrap; }
    .step-pill { padding: 0.55rem 0.95rem; border-radius: 999px; background: #e2e8f0; color: #475569; display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; font-weight: 600; transition: background 0.2s ease, color 0.2s ease; }
    .step-pill span { font-size: 0.75rem; font-weight: 500; opacity: 0.7; }
    .step-pill-active { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #ffffff; box-shadow: 0 14px 32px -20px rgba(37,99,235,0.8); }

    .pill-button { border-radius: 999px; padding: 0.45rem 0.9rem; font-size: 0.8rem; background: #e2e8f0; color: #0f172a; font-weight: 600; }
    .pill-button-active { background: #2563eb; color: #ffffff; }

    .input-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; }
    .field { display: flex; flex-direction: column; gap: 0.45rem; }
    .field label { font-weight: 600; font-size: 0.85rem; }
    .field small { color: #64748b; font-size: 0.75rem; }

    .stage-list { display: flex; flex-direction: column; gap: 0.85rem; }
    .stage-details { border-radius: 0.85rem; border: 1px solid #e2e8f0; background: #ffffff; padding: 0.75rem 1rem; }
    .stage-header { display: flex; align-items: center; gap: 0.75rem; }
    .stage-icon { font-size: 1.25rem; }
    .stage-summary { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 0.5rem; }
    .badge { display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.3rem 0.7rem; border-radius: 999px; background: #e2e8f0; font-size: 0.75rem; font-weight: 600; color: #334155; }
    body.dark .badge { background: #273347; color: #cbd5f5; }

    details summary { list-style: none; cursor: pointer; display: flex; align-items: center; gap: 0.75rem; font-weight: 600; }
    details summary::-webkit-details-marker { display: none; }
    details[open] { border-color: #2563eb; box-shadow: 0 18px 35px -24px rgba(37,99,235,0.45); }
    details .details-body { margin-top: 0.8rem; padding-top: 0.8rem; border-top: 1px dashed #cbd5f5; display: flex; flex-direction: column; gap: 0.6rem; }

    .toggle-row { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; border-radius: 0.8rem; border: 1px solid #e2e8f0; background: #f8fafc; }
    .toggle-row .toggle-info { display: flex; flex-direction: column; gap: 0.25rem; }

    .switch { position: relative; width: 48px; height: 26px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #cbd5f5; transition: .2s; border-radius: 26px; }
    .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: .2s; border-radius: 50%; box-shadow: 0 2px 6px rgba(15,23,42,0.2); }
    .switch input:checked + .slider { background-color: #2563eb; }
    .switch input:checked + .slider:before { transform: translateX(22px); }

    .range-row { display: flex; flex-direction: column; gap: 0.4rem; }
    .range-row label { display: flex; justify-content: space-between; font-size: 0.85rem; font-weight: 600; }
    input[type=range] { -webkit-appearance: none; width: 100%; height: 6px; border-radius: 999px; background: #e2e8f0; outline: none; }
    input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #2563eb; cursor: pointer; box-shadow: 0 4px 12px rgba(37,99,235,0.45); }
    input[type=range]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: #2563eb; cursor: pointer; box-shadow: 0 4px 12px rgba(37,99,235,0.45); }

    .message { border-radius: 0.8rem; padding: 0.65rem 0.9rem; font-size: 0.85rem; display: inline-flex; align-items: center; gap: 0.5rem; }
    .message-info { background: #dbeafe; color: #1d4ed8; }
    .message-success { background: #dcfce7; color: #047857; }
    .message-error { background: #fee2e2; color: #b91c1c; }

    .export-panel { border-radius: 1rem; border: 1px solid #e2e8f0; padding: 1.25rem; background: #ffffff; display: flex; flex-direction: column; gap: 1rem; }
    .export-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 0.75rem; }
    .export-chip { padding: 0.45rem 0.75rem; border-radius: 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; font-size: 0.8rem; display: flex; justify-content: space-between; align-items: center; }
    .export-text { white-space: pre; overflow-x: auto; background: #0f172a; color: #e2e8f0; border-radius: 0.75rem; padding: 1rem; font-family: "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace; font-size: 0.8rem; }

    .callout { border-radius: 0.9rem; padding: 0.9rem 1rem; background: #fef3c7; color: #92400e; font-size: 0.85rem; }
    .callout-error { background: #fee2e2; color: #b91c1c; }

    .file-button-grid { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .file-status-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 0.75rem; }
    .file-status-card { padding: 0.75rem; border-radius: 0.85rem; background: #f8fafc; border: 1px solid #e2e8f0; display: flex; flex-direction: column; gap: 0.25rem; }
    body.dark .file-status-card { background: #1f2937; border-color: #334155; }
    .file-status-card .title { font-weight: 600; font-size: 0.85rem; }
    .file-status-card .meta { font-size: 0.75rem; color: #64748b; }
    body.dark .file-status-card .meta { color: #cbd5f5; }
    .validation-log { border-radius: 0.85rem; border: 1px solid #e2e8f0; padding: 0.9rem; display: flex; flex-direction: column; gap: 0.5rem; }
    .validation-log ul { margin: 0; padding-left: 1.25rem; }
    body.dark .validation-log { border-color: #334155; }

    @media (max-width: 960px) {
      .page { padding: 1.75rem 1.25rem 3rem; }
      .layout { display: flex; flex-direction: column; gap: 1.5rem; }
    }
  </style>
</head>
<body class="min-h-screen" id="pageBody">
  <div class="page">
    <header class="page-header">
      <div>
        <p class="uppercase text-xs tracking-wide text-slate-600">Unified Competition Builder</p>
        <h1 class="text-3xl font-bold mt-2">Competition Architect</h1>
        <p class="text-sm text-slate-600 mt-1">Plan federations, design league structures, and export synchronized data packs without touching raw IDs.</p>
      </div>
      <div class="flex flex-wrap items-center gap-2">
        <button id="developerToggle" class="btn btn-ghost">Developer Mode</button>
        <button id="themeToggle" class="btn btn-ghost">Toggle Dark</button>
        <button id="buildExportBtn" class="btn btn-primary">Build &amp; Export</button>
      </div>
    </header>

    <div id="globalMessage" class="hidden"></div>

    <section class="card" id="fileManager">
      <div class="card-header">
        <div>
          <h2 class="text-xl font-semibold">Data Files</h2>
          <p class="text-xs text-slate-600 mt-1">Import, validate, and export synchronized text packs before diving into editing.</p>
        </div>
        <div class="flex items-center gap-2">
          <button id="validateAllBtn" class="btn btn-outline">Validate All</button>
          <button id="importZipBtn" class="btn btn-ghost">Load ZIP</button>
        </div>
      </div>
      <div class="card-body">
        <div class="flex flex-col gap-4">
          <div class="file-button-grid" id="fileButtonGrid">
            <button type="button" class="btn" data-file="compobj">Import compobj.txt</button>
            <button type="button" class="btn" data-file="settings">Import settings.txt</button>
            <button type="button" class="btn" data-file="tasks">Import tasks.txt</button>
            <button type="button" class="btn" data-file="advancement">Import advancement.txt</button>
            <button type="button" class="btn" data-file="standings">Import standings.txt</button>
            <button type="button" class="btn" data-file="schedule">Import schedule.txt</button>
            <button type="button" class="btn" data-file="weather">Import weather.txt</button>
            <button type="button" class="btn" data-file="objectives">Import objectives.txt</button>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-slate-600 mb-2">Loaded Files</h3>
            <div id="fileStatusList" class="file-status-grid"></div>
          </div>
          <div>
            <h3 class="text-sm font-semibold text-slate-600 mb-2">Export</h3>
            <div class="file-button-grid" id="fileExportButtons"></div>
          </div>
          <div id="validationOutput" class="validation-log hidden"></div>
        </div>
        <input id="fileInput-compobj" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-settings" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-tasks" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-advancement" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-standings" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-schedule" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-weather" type="file" accept=".txt" class="hidden" />
        <input id="fileInput-objectives" type="file" accept=".txt" class="hidden" />
        <input id="zipInput" type="file" accept=".zip" class="hidden" />
      </div>
    </section>

    <section class="layout" style="display:grid; grid-template-columns: 320px 320px 1fr; gap:1.5rem; align-items:start;">
      <article class="card" id="federationPanel">
        <div class="card-header">
          <div>
            <h2 class="text-xl font-semibold">Federation Selector</h2>
            <p class="text-xs text-slate-600 mt-1">Pick a confederation to browse its competitions.</p>
          </div>
        </div>
        <div class="card-body">
          <div id="federationList" class="selector-grid"></div>
        </div>
      </article>

      <article class="card" id="leaguePanel">
        <div class="card-header">
          <div>
            <h2 class="text-xl font-semibold">League Browser</h2>
            <p id="leaguePanelSummary" class="text-xs text-slate-600 mt-1"></p>
          </div>
          <button id="addLeagueBtn" class="btn btn-ghost">New Competition</button>
        </div>
        <div class="card-body">
          <div class="field">
            <label for="leagueSearch" class="text-sm font-semibold">Search</label>
            <input id="leagueSearch" type="search" placeholder="Search competitions by name or code" />
          </div>
          <div id="leagueList" class="selector-grid"></div>
        </div>
      </article>

      <article class="card" id="editorPanel">
        <div class="card-header">
          <div>
            <h2 class="text-xl font-semibold">Competition Editor</h2>
            <p id="editorSummary" class="text-xs text-slate-600 mt-1"></p>
          </div>
          <div class="flex items-center gap-2">
            <button id="prevStepBtn" class="btn btn-ghost">Back</button>
            <button id="nextStepBtn" class="btn btn-ghost">Next</button>
          </div>
        </div>
        <div class="card-body">
          <div id="editorContent" class="wizard"></div>
        </div>
      </article>
    </section>

    <section class="card">
      <div class="card-header">
        <div>
          <h2 class="text-xl font-semibold">Build Output</h2>
          <p class="text-xs text-slate-600 mt-1">Validated data files appear here after each build.</p>
        </div>
        <div class="flex items-center gap-2">
          <button id="downloadZipBtn" class="btn btn-outline">Download ZIP</button>
          <button id="copyTextBtn" class="btn btn-outline">Copy All Text</button>
        </div>
      </div>
      <div class="card-body">
        <div id="exportResults" class="export-panel"></div>
      </div>
    </section>
  </div>

  <script>
    (() => {
      const $ = (id) => document.getElementById(id);
      const state = {
        federations: [],
        selectedFederation: null,
        selectedLeague: null,
        developerMode: false,
        stepIndex: 0,
        leagueSearch: '',
        lastBuild: null
      };

      let compRows = [];
      let setRows = [];
      let taskRows = [];
      let advRows = [];
      let standRows = [];
      let schedRows = [];
      let weatherRows = [];
      let objectiveRows = [];

      const fileStatus = new Map();
      const textDecoder = new TextDecoder();

      const fileDefinitions = [
        { key: 'compobj', fileName: 'compobj.txt', arrayKey: 'compRows', parser: parseCompobj, formatter: formatCompRow, label: 'Competition Objects' },
        { key: 'settings', fileName: 'settings.txt', arrayKey: 'setRows', parser: parseSettings, formatter: formatSettingRow, label: 'Settings' },
        { key: 'tasks', fileName: 'tasks.txt', arrayKey: 'taskRows', parser: parseTasks, formatter: formatTaskRow, label: 'Tasks' },
        { key: 'advancement', fileName: 'advancement.txt', arrayKey: 'advRows', parser: parseAdvancement, formatter: formatAdvRow, label: 'Advancement' },
        { key: 'standings', fileName: 'standings.txt', arrayKey: 'standRows', parser: parseStandings, formatter: formatStandRow, label: 'Standings' },
        { key: 'schedule', fileName: 'schedule.txt', arrayKey: 'schedRows', parser: parseSchedule, formatter: formatSchedRow, label: 'Schedule' },
        { key: 'weather', fileName: 'weather.txt', arrayKey: 'weatherRows', parser: parseWeather, formatter: formatWeatherRow, label: 'Weather' },
        { key: 'objectives', fileName: 'objectives.txt', arrayKey: 'objectiveRows', parser: parseObjectives, formatter: formatObjectiveRow, label: 'Objectives' }
      ];

      function getRowsForArray(arrayKey) {
        switch (arrayKey) {
          case 'compRows': return compRows;
          case 'setRows': return setRows;
          case 'taskRows': return taskRows;
          case 'advRows': return advRows;
          case 'standRows': return standRows;
          case 'schedRows': return schedRows;
          case 'weatherRows': return weatherRows;
          case 'objectiveRows': return objectiveRows;
          default: return [];
        }
      }

      function setRowsForArray(arrayKey, rows) {
        switch (arrayKey) {
          case 'compRows': compRows = rows; break;
          case 'setRows': setRows = rows; break;
          case 'taskRows': taskRows = rows; break;
          case 'advRows': advRows = rows; break;
          case 'standRows': standRows = rows; break;
          case 'schedRows': schedRows = rows; break;
          case 'weatherRows': weatherRows = rows; break;
          case 'objectiveRows': objectiveRows = rows; break;
          default: break;
        }
      }

      const editorConfigs = new Map();
      const idRegistry = new Map();
      let uidCounter = 1;
      let idSeed = 1200;

      const structureTypes = [
        { key: 'league', label: 'League Stage', description: 'Single table, round-robin competition with standings.', icon: '⚽' },
        { key: 'groups', label: 'Group Phase', description: 'Multiple pools with advancement to later rounds.', icon: '🧩' },
        { key: 'playoffs', label: 'Playoffs', description: 'Knockout bracket with configurable rounds.', icon: '🏆' }
      ];

      const stageIcons = {
        league: '⚽',
        groups: '🧩',
        playoff: '🏆',
        qualifying: '🎯',
        final: '🥇'
      };

      function parseLines(content, buildRow) {
        const rows = [];
        if (!content) return rows;
        const lines = content.split(/\r?\n/);
        lines.forEach((line, index) => {
          if (!line.trim()) return;
          const parts = line.split(',');
          rows.push(buildRow(parts, line, index));
        });
        return rows;
      }

      function parseCompobj(content) {
        return parseLines(content, (parts, raw, index) => ({
          id: (parts[0] || '').trim(),
          level: (parts[1] || '').trim(),
          code: (parts[2] || '').trim(),
          name: (parts[3] || '').trim(),
          parent: (parts[4] || '').trim(),
          raw,
          index
        }));
      }

      function parseSettings(content) {
        return parseLines(content, (parts, raw, index) => ({
          id: (parts[0] || '').trim(),
          settingKey: (parts[1] || '').trim(),
          value: (parts[2] || '').trim(),
          raw,
          index
        }));
      }

      function parseTasks(content) {
        return parseLines(content, (parts, raw, index) => ({
          trophyId: (parts[0] || '').trim(),
          phase: (parts[1] || '').trim(),
          command: (parts[2] || '').trim(),
          target: (parts[3] || '').trim(),
          ref1: (parts[4] || '').trim(),
          ref2: (parts[5] || '').trim(),
          ref3: (parts[6] || '').trim(),
          raw,
          index
        }));
      }

      function parseAdvancement(content) {
        return parseLines(content, (parts, raw, index) => ({
          fromId: (parts[0] || '').trim(),
          placement: (parts[1] || '').trim(),
          toId: (parts[2] || '').trim(),
          slot: (parts[3] || '').trim(),
          raw,
          index
        }));
      }

      function parseStandings(content) {
        return parseLines(content, (parts, raw, index) => ({
          groupId: (parts[0] || '').trim(),
          teamCount: (parts[1] || '').trim(),
          raw,
          index
        }));
      }

      function parseSchedule(content) {
        return parseLines(content, (parts, raw, index) => ({
          stageId: (parts[0] || '').trim(),
          dateId: (parts[1] || '').trim(),
          matchDay: (parts[2] || '').trim(),
          minGames: (parts[3] || '').trim(),
          maxGames: (parts[4] || '').trim(),
          time: (parts[5] || '').trim(),
          raw,
          index
        }));
      }

      function parseWeather(content) {
        return parseLines(content, (parts, raw, index) => ({
          fedId: (parts[0] || '').trim(),
          dayId: (parts[1] || '').trim(),
          weatherType: (parts[2] || '').trim(),
          param1: (parts[3] || '').trim(),
          param2: (parts[4] || '').trim(),
          param3: (parts[5] || '').trim(),
          param4: (parts[6] || '').trim(),
          start: (parts[7] || '').trim(),
          end: (parts[8] || '').trim(),
          raw,
          index
        }));
      }

      function parseObjectives(content) {
        return parseLines(content, (parts, raw, index) => ({
          groupId: (parts[0] || '').trim(),
          objective: (parts[1] || '').trim(),
          value: (parts[2] || '').trim(),
          raw,
          index
        }));
      }

      function formatCompRow(row) {
        return [row.id, row.level, row.code, row.name, row.parent].join(',');
      }

      function formatSettingRow(row) {
        return [row.id, row.settingKey, row.value].join(',');
      }

      function formatTaskRow(row) {
        return [row.trophyId, row.phase, row.command, row.target, row.ref1, row.ref2, row.ref3].join(',');
      }

      function formatAdvRow(row) {
        return [row.fromId, row.placement, row.toId, row.slot].join(',');
      }

      function formatStandRow(row) {
        return [row.groupId, row.teamCount].join(',');
      }

      function formatSchedRow(row) {
        return [row.stageId, row.dateId, row.matchDay, row.minGames, row.maxGames, row.time].join(',');
      }

      function formatWeatherRow(row) {
        return [row.fedId, row.dayId, row.weatherType, row.param1, row.param2, row.param3, row.param4, row.start, row.end].join(',');
      }

      function formatObjectiveRow(row) {
        return [row.groupId, row.objective, row.value].join(',');
      }

      function rowsToText(rows, formatter) {
        return rows.map((row) => row.raw || formatter(row)).join('\n');
      }

      function createUuid(prefix = 'id') {
        return `${prefix}-${uidCounter++}`;
      }

      function getIdForKey(key) {
        if (!idRegistry.has(key)) {
          idRegistry.set(key, allocateId());
        }
        return idRegistry.get(key);
      }

      function allocateId() {
        const used = new Set(idRegistry.values());
        while (used.has(String(idSeed))) {
          idSeed += 1;
        }
        const assigned = String(idSeed);
        idSeed += 1;
        return assigned;
      }

      function setIdForKey(key, desiredId) {
        const normalized = String(desiredId || '').trim();
        if (!normalized) return false;
        const takenBy = Array.from(idRegistry.entries()).find(([, value]) => value === normalized && value !== idRegistry.get(key));
        if (takenBy) return false;
        idRegistry.set(key, normalized);
        return true;
      }

      function ensureConfig(league) {
        if (!editorConfigs.has(league.uuid)) {
          editorConfigs.set(league.uuid, createDefaultConfig());
        }
        return editorConfigs.get(league.uuid);
      }

      function createDefaultConfig() {
        return {
          structureType: 'league',
          teamCount: 20,
          groupCount: 1,
          rounds: 2,
          homeAndAway: true,
          includePlayoffs: false,
          playoffTeams: 8,
          gamesPerMatchup: 2,
          includeThirdPlace: false,
          matchTime: '20:00'
        };
      }

      function resetRegistries() {
        idRegistry.clear();
        uidCounter = 1;
        idSeed = 1200;
      }

      function convertContextRows(rows, formatter) {
        return rows.map((row, index) => ({ ...row, raw: formatter(row), index }));
      }

      function updateLastBuildFromArrays() {
        state.lastBuild = {
          files: fileDefinitions.map((def) => ({
            name: def.fileName,
            content: rowsToText(getRowsForArray(def.arrayKey), def.formatter)
          })),
          context: {
            compRows,
            setRows,
            taskRows,
            advRows,
            standRows,
            schedRows,
            weatherRows,
            objectiveRows
          }
        };
      }

      function renderFileStatus() {
        const container = $('fileStatusList');
        if (!container) return;
        container.innerHTML = '';
        fileDefinitions.forEach((def) => {
          const status = fileStatus.get(def.key);
          const card = document.createElement('div');
          card.className = 'file-status-card';
          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = def.fileName;
          const meta = document.createElement('div');
          meta.className = 'meta';
          if (status && typeof status.lines === 'number') {
            meta.textContent = `✅ ${status.lines} lines loaded`;
          } else {
            meta.textContent = 'Not loaded yet';
          }
          card.appendChild(title);
          card.appendChild(meta);
          if (status?.message) {
            const note = document.createElement('div');
            note.className = 'meta';
            note.textContent = status.message;
            card.appendChild(note);
          }
          container.appendChild(card);
        });
        renderExportButtons();
      }

      function renderExportButtons() {
        const container = $('fileExportButtons');
        if (!container) return;
        container.innerHTML = '';
        fileDefinitions.forEach((def) => {
          const rows = getRowsForArray(def.arrayKey);
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'btn btn-ghost';
          button.textContent = `Download ${def.fileName}`;
          button.dataset.export = def.key;
          if (!rows.length) {
            button.disabled = true;
            button.classList.add('text-slate-500');
          }
          container.appendChild(button);
        });
        const anyData = fileDefinitions.some((def) => getRowsForArray(def.arrayKey).length);
        const zipButton = document.createElement('button');
        zipButton.type = 'button';
        zipButton.dataset.export = 'zip-all';
        if (anyData) {
          zipButton.className = 'btn btn-primary';
        } else {
          zipButton.className = 'btn btn-ghost text-slate-500';
          zipButton.disabled = true;
        }
        zipButton.textContent = 'Download All (ZIP)';
        container.appendChild(zipButton);
      }

      function hydrateStateFromFiles() {
        if (!compRows.length) {
          return;
        }
        resetRegistries();
        editorConfigs.clear();
        state.federations = [];
        const children = new Map();
        compRows.forEach((row) => {
          if (!children.has(row.parent)) children.set(row.parent, []);
          children.get(row.parent).push(row);
        });
        children.forEach((list) => list.sort((a, b) => (a.index || 0) - (b.index || 0)));
        const settingsMap = new Map();
        setRows.forEach((row) => {
          if (!settingsMap.has(row.id)) settingsMap.set(row.id, new Map());
          settingsMap.get(row.id).set(row.settingKey, row.value);
        });
        const standingsMap = new Map();
        standRows.forEach((row) => standingsMap.set(row.groupId, Number(row.teamCount) || 0));
        const scheduleMap = new Map();
        schedRows.forEach((row) => {
          if (!scheduleMap.has(row.stageId)) scheduleMap.set(row.stageId, row);
        });

        const federationRows = compRows.filter((row) => row.level === '0').sort((a, b) => (a.index || 0) - (b.index || 0));
        federationRows.forEach((fedRow) => {
          const federation = {
            uuid: createUuid('fed'),
            name: fedRow.name,
            code: fedRow.code,
            region: '',
            leagues: []
          };
          setIdForKey(`fed:${federation.uuid}`, fedRow.id);
          const leagueRows = (children.get(fedRow.id) || []).filter((row) => row.level === '1');
          leagueRows.forEach((leagueRow) => {
            const league = {
              uuid: createUuid('league'),
              name: leagueRow.name,
              code: leagueRow.code,
              season: '',
              notes: ''
            };
            setIdForKey(`league:${league.uuid}`, leagueRow.id);
            const config = deriveConfigFromData(league, leagueRow, children, settingsMap, standingsMap, scheduleMap);
            editorConfigs.set(league.uuid, config);
            federation.leagues.push(league);
          });
          state.federations.push(federation);
        });
        state.selectedFederation = state.federations[0]?.uuid || null;
        state.selectedLeague = state.federations[0]?.leagues[0]?.uuid || null;
        state.stepIndex = 0;
        renderAll();
      }

      function deriveConfigFromData(league, leagueRow, children, settingsMap, standingsMap, scheduleMap) {
        const config = createDefaultConfig();
        const stageRows = (children.get(leagueRow.id) || []).filter((row) => row.level === '2').sort((a, b) => (a.index || 0) - (b.index || 0));
        const isPlayoffStage = (row) => (row.code || '').toUpperCase() === 'PO' || /(playoff|knockout)/i.test(row.name || '');
        const playoffStage = stageRows.find((row) => isPlayoffStage(row)) || null;
        const mainStage = stageRows.find((row) => !isPlayoffStage(row)) || (playoffStage ? null : stageRows[0] || null);

        const groupsForStage = (stage) => (stage ? (children.get(stage.id) || []).filter((row) => row.level === '3').sort((a, b) => (a.index || 0) - (b.index || 0)) : []);
        const mainGroups = groupsForStage(mainStage);
        const playoffGroups = groupsForStage(playoffStage);

        if (mainStage) {
          const stageKey = `league:${league.uuid}:stage:main`;
          setIdForKey(stageKey, mainStage.id);
          let teamCount = 0;
          mainGroups.forEach((group, index) => {
            setIdForKey(`${stageKey}:group:${index + 1}`, group.id);
            teamCount += standingsMap.get(group.id) || Number(group.teamCount) || 0;
          });
          if (teamCount) config.teamCount = teamCount;
          const groupCount = mainGroups.length || 1;
          config.groupCount = groupCount;
          config.structureType = groupCount > 1 ? 'groups' : 'league';
          const stageSettings = settingsMap.get(mainStage.id);
          if (stageSettings) {
            const rounds = Number(stageSettings.get('rounds'));
            if (rounds) config.rounds = rounds;
            const gamesPerMatch = Number(stageSettings.get('games_per_matchup'));
            if (gamesPerMatch) config.homeAndAway = gamesPerMatch >= 2;
          }
          const scheduleRow = scheduleMap.get(mainStage.id);
          if (scheduleRow?.time) config.matchTime = scheduleRow.time;
        } else if (playoffGroups.length) {
          const firstGroup = playoffGroups.find((group) => (group.code || '').toUpperCase() !== '3P');
          const teams = firstGroup ? (standingsMap.get(firstGroup.id) || Number(firstGroup.teamCount) || 0) : 0;
          if (teams) config.teamCount = teams;
          config.structureType = 'playoffs';
        }

        if (playoffStage) {
          const stageKey = `league:${league.uuid}:stage:playoff`;
          setIdForKey(stageKey, playoffStage.id);
          let entrants = 0;
          let roundIndex = 1;
          playoffGroups.forEach((group) => {
            const code = (group.code || '').toUpperCase();
            if (code === '3P') {
              config.includeThirdPlace = true;
              setIdForKey(`${stageKey}:third`, group.id);
            } else {
              setIdForKey(`${stageKey}:round:${roundIndex}`, group.id);
              roundIndex += 1;
              entrants = Math.max(entrants, standingsMap.get(group.id) || Number(group.teamCount) || 0);
            }
          });
          if (entrants) config.playoffTeams = entrants;
          const stageSettings = settingsMap.get(playoffStage.id);
          if (stageSettings) {
            const gamesPerMatch = Number(stageSettings.get('games_per_matchup'));
            if (gamesPerMatch) config.gamesPerMatchup = gamesPerMatch;
          }
          const scheduleRow = scheduleMap.get(playoffStage.id);
          if (!mainStage && scheduleRow?.time) config.matchTime = scheduleRow.time;
          if (mainStage) config.includePlayoffs = true;
        } else {
          config.includePlayoffs = false;
        }

        return config;
      }

      function syncDataFromState() {
        const build = buildProjectFiles();
        compRows = convertContextRows(build.context.compRows, formatCompRow);
        setRows = convertContextRows(build.context.setRows, formatSettingRow);
        taskRows = convertContextRows(build.context.taskRows, formatTaskRow);
        advRows = convertContextRows(build.context.advRows, formatAdvRow);
        standRows = convertContextRows(build.context.standRows, formatStandRow);
        schedRows = convertContextRows(build.context.schedRows, formatSchedRow);
        objectiveRows = convertContextRows(build.context.objectiveRows, formatObjectiveRow);
        weatherRows = convertContextRows(build.context.weatherRows, formatWeatherRow);
        state.lastBuild = build;
        fileDefinitions.forEach((def) => {
          const rows = getRowsForArray(def.arrayKey);
          fileStatus.set(def.key, { lines: rows.length, message: 'Synced from editor' });
        });
        const validationOutput = $('validationOutput');
        if (validationOutput) validationOutput.classList.add('hidden');
        renderFileStatus();
        renderExportResults();
      }

      async function handleFileSelection(definition, file) {
        const text = await file.text();
        const rows = definition.parser(text).map((row, index) => ({ ...row, index }));
        rows.forEach((row) => { if (!row.raw) row.raw = definition.formatter(row); });
        setRowsForArray(definition.arrayKey, rows);
        fileStatus.set(definition.key, { lines: rows.length, message: `Loaded from ${file.name}` });
        updateLastBuildFromArrays();
        const validationOutput = $('validationOutput');
        if (validationOutput) validationOutput.classList.add('hidden');
        renderFileStatus();
        renderExportResults();
        if (compRows.length) {
          hydrateStateFromFiles();
        } else {
          renderAll();
        }
        showMessage(`✅ Loaded ${rows.length} lines from ${definition.fileName}`, 'success');
      }

      async function handleZipSelection(file) {
        const buffer = await file.arrayBuffer();
        const entries = extractZipEntries(buffer);
        const loaded = [];
        fileDefinitions.forEach((def) => {
          const match = entries[def.fileName.toLowerCase()];
          if (match) {
            const text = textDecoder.decode(match);
            const rows = def.parser(text).map((row, index) => ({ ...row, index }));
            rows.forEach((row) => { if (!row.raw) row.raw = def.formatter(row); });
            setRowsForArray(def.arrayKey, rows);
            fileStatus.set(def.key, { lines: rows.length, message: `Loaded from ${file.name}` });
            loaded.push(`${def.fileName} (${rows.length} lines)`);
          }
        });
        if (!loaded.length) {
          showMessage('ZIP did not contain recognizable data files.', 'error');
          return;
        }
        updateLastBuildFromArrays();
        const validationOutput = $('validationOutput');
        if (validationOutput) validationOutput.classList.add('hidden');
        renderFileStatus();
        renderExportResults();
        hydrateStateFromFiles();
        showMessage(`✅ Loaded ${loaded.length} files from ZIP`, 'success');
      }

      function extractZipEntries(buffer) {
        const view = new DataView(buffer);
        let offset = buffer.byteLength - 22;
        let endFound = false;
        while (offset >= 0) {
          if (view.getUint32(offset, true) === 0x06054b50) {
            endFound = true;
            break;
          }
          offset -= 1;
        }
        if (!endFound) return {};
        const total = view.getUint16(offset + 10, true);
        const centralOffset = view.getUint32(offset + 16, true);
        const entries = {};
        let ptr = centralOffset;
        for (let i = 0; i < total; i += 1) {
          if (view.getUint32(ptr, true) !== 0x02014b50) break;
          const nameLength = view.getUint16(ptr + 28, true);
          const extraLength = view.getUint16(ptr + 30, true);
          const commentLength = view.getUint16(ptr + 32, true);
          const compression = view.getUint16(ptr + 10, true);
          const localHeaderOffset = view.getUint32(ptr + 42, true);
          const nameBytes = new Uint8Array(buffer, ptr + 46, nameLength);
          const rawName = textDecoder.decode(nameBytes);
          const normalized = rawName.split('/').pop() || rawName;
          const fileName = normalized.toLowerCase();
          ptr += 46 + nameLength + extraLength + commentLength;
          if (compression !== 0) continue; // Only support stored entries
          if (view.getUint32(localHeaderOffset, true) !== 0x04034b50) continue;
          const localNameLength = view.getUint16(localHeaderOffset + 26, true);
          const localExtraLength = view.getUint16(localHeaderOffset + 28, true);
          const size = view.getUint32(localHeaderOffset + 18, true);
          const dataStart = localHeaderOffset + 30 + localNameLength + localExtraLength;
          entries[fileName] = new Uint8Array(buffer, dataStart, size);
        }
        return entries;
      }

      function downloadText(name, text) {
        const blob = new Blob([text], { type: 'text/plain' });
        downloadBlob(name, blob);
      }

      function validateFiles() {
        const issues = [];
        const compIdSet = new Set(compRows.map((row) => row.id));
        const stageIdSet = new Set(compRows.filter((row) => row.level === '2').map((row) => row.id));
        const groupIdSet = new Set(compRows.filter((row) => row.level === '3').map((row) => row.id));
        const leagueIdSet = new Set(compRows.filter((row) => row.level === '1').map((row) => row.id));
        const federationIdSet = new Set(compRows.filter((row) => row.level === '0').map((row) => row.id));
        compRows.forEach((row) => {
          if (row.level !== '0' && row.parent && !compIdSet.has(row.parent)) {
            issues.push(`Competition entry ${row.id} references missing parent ${row.parent}.`);
          }
        });
        setRows.forEach((row) => {
          if (row.id && !compIdSet.has(row.id)) {
            issues.push(`Setting ${row.settingKey} references unknown node ${row.id}.`);
          }
        });
        standRows.forEach((row) => {
          if (row.groupId && !groupIdSet.has(row.groupId)) {
            issues.push(`Standings entry references missing group ${row.groupId}.`);
          }
        });
        objectiveRows.forEach((row) => {
          if (row.groupId && !groupIdSet.has(row.groupId)) {
            issues.push(`Objective ${row.objective} references missing group ${row.groupId}.`);
          }
        });
        schedRows.forEach((row) => {
          if (row.stageId && !stageIdSet.has(row.stageId)) {
            issues.push(`Schedule ${row.dateId} references missing stage ${row.stageId}.`);
          }
        });
        advRows.forEach((row) => {
          if (row.fromId && !groupIdSet.has(row.fromId)) {
            issues.push(`Advancement ${row.fromId} references missing group ${row.fromId}.`);
          }
          if (row.toId && !groupIdSet.has(row.toId)) {
            issues.push(`Advancement ${row.fromId} references missing group ${row.toId}.`);
          }
        });
        taskRows.forEach((row) => {
          if (row.trophyId && !leagueIdSet.has(row.trophyId)) {
            issues.push(`Task trophy ${row.trophyId} does not match a competition.`);
          }
          if (row.target && !compIdSet.has(row.target)) {
            issues.push(`Task target ${row.target} is missing from compobj.`);
          }
        });
        weatherRows.forEach((row) => {
          if (row.fedId && !federationIdSet.has(row.fedId)) {
            issues.push(`Weather pattern references missing federation ${row.fedId}.`);
          }
        });
        return issues;
      }

      function handleValidateAll() {
        const issues = validateFiles();
        const output = $('validationOutput');
        if (!output) return;
        output.classList.remove('hidden');
        if (!issues.length) {
          output.innerHTML = `<div class="text-emerald-600 font-semibold">All references look good.</div><div class="text-sm text-slate-600">Every linked ID resolves correctly.</div>`;
          showMessage('Validation complete — all references resolved.', 'success');
        } else {
          output.innerHTML = `<div class="text-red-600 font-semibold">${issues.length} issue${issues.length === 1 ? '' : 's'} detected:</div><ul>${issues.map((issue) => `<li>${issue}</li>`).join('')}</ul>`;
          showMessage('Validation finished with warnings.', 'error');
        }
      }

      function describeCompetitionType(config) {
        if (!config) return 'Unknown';
        if (config.structureType === 'playoffs' && !config.includePlayoffs) return 'Cup';
        if (config.structureType === 'playoffs') return 'Hybrid';
        if (config.includePlayoffs) return 'Hybrid';
        return 'League';
      }


      function createFederation(name, code, region) {
        const federation = {
          uuid: createUuid('fed'),
          name,
          code,
          region,
          leagues: []
        };
        getIdForKey(`fed:${federation.uuid}`);
        return federation;
      }

      function createLeague(name, code, season) {
        const league = {
          uuid: createUuid('league'),
          name,
          code,
          season,
          notes: ''
        };
        getIdForKey(`league:${league.uuid}`);
        editorConfigs.set(league.uuid, createDefaultConfig());
        return league;
      }

      function createInitialProject() {
        const uefa = createFederation('UEFA', 'UEFA', 'Europe');
        const concacaf = createFederation('CONCACAF', 'CONCACAF', 'North & Central America');
        const afc = createFederation('AFC', 'AFC', 'Asia');

        const ucl = createLeague('UEFA Champions League', 'UCL', '2024/25');
        editorConfigs.set(ucl.uuid, {
          structureType: 'groups',
          teamCount: 32,
          groupCount: 8,
          rounds: 2,
          homeAndAway: true,
          includePlayoffs: true,
          playoffTeams: 16,
          gamesPerMatchup: 2,
          includeThirdPlace: false,
          matchTime: '21:00'
        });

        const europa = createLeague('UEFA Europa League', 'UEL', '2024/25');
        editorConfigs.set(europa.uuid, {
          structureType: 'groups',
          teamCount: 48,
          groupCount: 12,
          rounds: 2,
          homeAndAway: true,
          includePlayoffs: true,
          playoffTeams: 32,
          gamesPerMatchup: 2,
          includeThirdPlace: false,
          matchTime: '21:00'
        });

        const mls = createLeague('Major League Soccer', 'MLS', '2024');
        editorConfigs.set(mls.uuid, {
          structureType: 'league',
          teamCount: 29,
          groupCount: 1,
          rounds: 1,
          homeAndAway: false,
          includePlayoffs: true,
          playoffTeams: 16,
          gamesPerMatchup: 2,
          includeThirdPlace: false,
          matchTime: '19:30'
        });

        const acl = createLeague('AFC Champions League', 'ACL', '2024/25');
        editorConfigs.set(acl.uuid, {
          structureType: 'groups',
          teamCount: 40,
          groupCount: 10,
          rounds: 2,
          homeAndAway: true,
          includePlayoffs: true,
          playoffTeams: 16,
          gamesPerMatchup: 2,
          includeThirdPlace: true,
          matchTime: '20:00'
        });

        uefa.leagues.push(ucl, europa);
        concacaf.leagues.push(mls);
        afc.leagues.push(acl);

        return [uefa, concacaf, afc];
      }

      function getSelectedFederation() {
        return state.federations.find((f) => f.uuid === state.selectedFederation) || null;
      }

      function getSelectedLeague() {
        const federation = getSelectedFederation();
        if (!federation) return null;
        return federation.leagues.find((l) => l.uuid === state.selectedLeague) || null;
      }

      function showMessage(text, tone = 'info') {
        const box = $('globalMessage');
        if (!box) return;
        const classMap = {
          info: 'message message-info',
          success: 'message message-success',
          error: 'message message-error'
        };
        box.className = classMap[tone] || classMap.info;
        box.textContent = text;
        box.classList.remove('hidden');
        clearTimeout(showMessage.timer);
        showMessage.timer = setTimeout(() => box.classList.add('hidden'), 4000);
      }

      function renderFederations() {
        const container = $('federationList');
        if (!container) return;
        container.innerHTML = '';
        state.federations.forEach((fed) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.fedId = fed.uuid;
          btn.className = 'selector-card' + (state.selectedFederation === fed.uuid ? ' selector-card-active' : '');
          const leagueCount = fed.leagues.length;
          const idInfo = state.developerMode ? `<div class="selector-dev">ID ${getIdForKey(`fed:${fed.uuid}`)}</div>` : '';
          btn.innerHTML = `
            <div class="selector-icon">🌍</div>
            <div class="selector-title">${fed.name || 'Untitled Federation'}</div>
            <div class="selector-sub">${fed.code || 'No code'} • ${leagueCount} competition${leagueCount === 1 ? '' : 's'}</div>
            ${fed.region ? `<div class="selector-sub">${fed.region}</div>` : ''}
            ${idInfo}
          `;
          container.appendChild(btn);
        });

        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'selector-card selector-card-add';
        addBtn.textContent = '+ New Federation';
        addBtn.onclick = () => {
          const name = prompt('Federation name', 'New Federation');
          if (!name) return;
          const code = prompt('Federation code', name.slice(0, 4).toUpperCase());
          const region = prompt('Region or description', '');
          const federation = createFederation(name, code || name.slice(0, 4).toUpperCase(), region || '');
          state.federations.push(federation);
          state.selectedFederation = federation.uuid;
          state.selectedLeague = null;
          syncDataFromState();
          renderAll();
          showMessage('Federation added.', 'success');
        };
        container.appendChild(addBtn);
      }

      function renderLeagues() {
        const container = $('leagueList');
        const summary = $('leaguePanelSummary');
        if (!container || !summary) return;
        container.innerHTML = '';
        const federation = getSelectedFederation();
        if (!federation) {
          summary.textContent = 'Select a federation to browse its competitions.';
          return;
        }
        const filtered = federation.leagues.filter((league) => {
          if (!state.leagueSearch) return true;
          const q = state.leagueSearch.toLowerCase();
          return (
            (league.name || '').toLowerCase().includes(q) ||
            (league.code || '').toLowerCase().includes(q)
          );
        });
        summary.textContent = `${filtered.length} competition${filtered.length === 1 ? '' : 's'} in ${federation.name}`;
        filtered.forEach((league) => {
          const config = ensureConfig(league);
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.leagueId = league.uuid;
          btn.className = 'selector-card' + (state.selectedLeague === league.uuid ? ' selector-card-active' : '');
          const stageIcon = structureTypes.find((s) => s.key === config.structureType)?.icon || '⚙️';
          const typeLabel = describeCompetitionType(config);
          const teamLabel = `${config.teamCount} team${config.teamCount === 1 ? '' : 's'}`;
          const idInfo = state.developerMode ? `<div class="selector-dev">ID ${getIdForKey(`league:${league.uuid}`)}</div>` : '';
          btn.innerHTML = `
            <div class="selector-icon">${stageIcon}</div>
            <div class="selector-title">${league.name || 'Untitled Competition'}</div>
            <div class="selector-sub">${league.code || 'No code'} • ${typeLabel} • ${teamLabel}</div>
            ${league.season ? `<div class="selector-sub">Season ${league.season}</div>` : ''}
            ${idInfo}
          `;
          container.appendChild(btn);
        });
        if (!filtered.length) {
          const empty = document.createElement('div');
          empty.className = 'callout';
          empty.textContent = 'No competitions yet. Create one to begin designing.';
          container.appendChild(empty);
        }
      }

      function renderEditor() {
        const editor = $('editorContent');
        const summary = $('editorSummary');
        if (!editor || !summary) return;
        editor.innerHTML = '';
        const federation = getSelectedFederation();
        const league = getSelectedLeague();
        if (!federation || !league) {
          summary.textContent = 'Choose a competition to unlock the guided editor.';
          const placeholder = document.createElement('div');
          placeholder.className = 'callout';
          placeholder.textContent = 'Select a competition card from the League Browser to begin editing its structure.';
          editor.appendChild(placeholder);
          return;
        }
        const config = ensureConfig(league);
        summary.textContent = `${federation.name} • ${league.name}`;
        renderStepper(editor);
        renderStepContent(editor, league, config, federation);
      }

      function renderStepper(editor) {
        const stepper = document.createElement('div');
        stepper.className = 'stepper';
        const steps = ['Overview', 'Structure', 'Stages', 'Review'];
        steps.forEach((label, index) => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'step-pill' + (state.stepIndex === index ? ' step-pill-active' : '');
          pill.innerHTML = `<span>${index + 1}</span>${label}`;
          pill.onclick = () => {
            state.stepIndex = index;
            renderEditor();
          };
          stepper.appendChild(pill);
        });
        editor.appendChild(stepper);
      }

      function renderStepContent(editor, league, config, federation) {
        const content = document.createElement('div');
        content.className = 'flex flex-col gap-6';
        const step = state.stepIndex;
        if (step === 0) {
          content.appendChild(renderOverviewStep(league, config, federation));
        } else if (step === 1) {
          content.appendChild(renderStructureStep(league, config));
        } else if (step === 2) {
          content.appendChild(renderStagesStep(league, config));
        } else {
          content.appendChild(renderReviewStep(league, config, federation));
        }
        editor.appendChild(content);
      }

      function renderOverviewStep(league, config, federation) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-6';

        const breadcrumb = document.createElement('div');
        breadcrumb.className = 'badge';
        breadcrumb.textContent = `${federation.name} • ${league.name}`;
        container.appendChild(breadcrumb);

        const grid = document.createElement('div');
        grid.className = 'input-grid';

        grid.appendChild(createField('Competition Name', league.name, 'text', (value) => {
          league.name = value;
          renderLeagues();
          renderEditor();
        }));

        grid.appendChild(createField('Short Code', league.code, 'text', (value) => {
          league.code = value.toUpperCase();
          renderLeagues();
        }, 'Uppercase identifier used in generated files.'));

        grid.appendChild(createField('Season', league.season, 'text', (value) => {
          league.season = value;
          renderLeagues();
        }, 'Optional season label for settings.'));

        grid.appendChild(createField('Notes', league.notes, 'textarea', (value) => {
          league.notes = value;
        }, 'Internal notes for collaborators.'));

        container.appendChild(grid);

        if (state.developerMode) {
          const devBox = document.createElement('div');
          devBox.className = 'callout';
          const fedId = getIdForKey(`fed:${federation.uuid}`);
          const leagueId = getIdForKey(`league:${league.uuid}`);
          devBox.innerHTML = `
            <div class="font-semibold mb-2">Developer identifiers</div>
            <div class="flex flex-wrap gap-3">
              <div>Federation ID: <code>${fedId}</code></div>
              <div>Competition ID: <input id="leagueIdInput" value="${leagueId}" class="px-2 py-1" style="width:6rem" /></div>
            </div>
          `;
          setTimeout(() => {
            const input = $('leagueIdInput');
            if (input) {
              input.addEventListener('change', () => {
                const ok = setIdForKey(`league:${league.uuid}`, input.value);
                if (!ok) {
                  showMessage('ID already in use or invalid.', 'error');
                  input.value = getIdForKey(`league:${league.uuid}`);
                } else {
                  showMessage('Competition ID updated.', 'success');
                  syncDataFromState();
                }
              });
            }
          }, 10);
          container.appendChild(devBox);
        }

        return container;
      }

      function createField(label, value, type, onChange, helper) {
        const wrapper = document.createElement('div');
        wrapper.className = 'field';
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        wrapper.appendChild(labelEl);
        let input;
        if (type === 'textarea') {
          input = document.createElement('textarea');
          input.rows = 3;
        } else {
          input = document.createElement('input');
          input.type = type;
        }
        input.value = value || '';
        input.addEventListener('input', (event) => {
          onChange(event.target.value);
          syncDataFromState();
        });
        wrapper.appendChild(input);
        if (helper) {
          const helperEl = document.createElement('small');
          helperEl.textContent = helper;
          wrapper.appendChild(helperEl);
        }
        return wrapper;
      }

      function renderStructureStep(league, config) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-6';

        const structureRow = document.createElement('div');
        structureRow.className = 'flex flex-wrap gap-2';
        structureTypes.forEach((type) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'pill-button' + (config.structureType === type.key ? ' pill-button-active' : '');
          button.innerHTML = `${type.icon} ${type.label}`;
          button.onclick = () => {
            config.structureType = type.key;
            if (type.key === 'league') config.groupCount = 1;
            syncDataFromState();
            renderEditor();
          };
          button.title = type.description;
          structureRow.appendChild(button);
        });
        container.appendChild(structureRow);

        const sliders = document.createElement('div');
        sliders.className = 'flex flex-col gap-4';
        sliders.appendChild(createRange('Teams', 2, 64, config.teamCount, 1, (value) => {
          config.teamCount = value;
          renderLeagues();
        }));

        const groupDisabled = config.structureType === 'league' || config.structureType === 'playoffs';
        sliders.appendChild(createRange('Groups', 1, 16, config.groupCount, 1, (value) => {
          config.groupCount = value;
        }, groupDisabled, groupDisabled ? 'Group count is fixed for this structure.' : 'Distribute teams evenly across groups.'));

        sliders.appendChild(createRange('Rounds', 1, 6, config.rounds, 1, (value) => {
          config.rounds = value;
        }, false, 'Number of round-robin cycles.'));

        container.appendChild(sliders);

        const toggles = document.createElement('div');
        toggles.className = 'flex flex-col gap-3';
        toggles.appendChild(createToggle('Home & Away fixtures', config.homeAndAway, (checked) => {
          config.homeAndAway = checked;
        }));
        toggles.appendChild(createToggle('Include playoff stage', config.includePlayoffs, (checked) => {
          config.includePlayoffs = checked;
          renderEditor();
        }, 'Generates a knockout bracket after the main stage.'));
        container.appendChild(toggles);

        return container;
      }

      function createRange(label, min, max, value, step, onChange, disabled = false, helper) {
        const wrapper = document.createElement('div');
        wrapper.className = 'range-row';
        const labelRow = document.createElement('label');
        labelRow.innerHTML = `<span>${label}</span><span>${value}</span>`;
        wrapper.appendChild(labelRow);
        const input = document.createElement('input');
        input.type = 'range';
        input.min = String(min);
        input.max = String(max);
        input.step = String(step);
        input.value = String(value);
        input.disabled = disabled;
        input.addEventListener('input', (event) => {
          const newValue = Number(event.target.value);
          labelRow.innerHTML = `<span>${label}</span><span>${newValue}</span>`;
        });
        input.addEventListener('change', (event) => {
          const newValue = Number(event.target.value);
          onChange(newValue);
          syncDataFromState();
        });
        wrapper.appendChild(input);
        if (helper) {
          const helperEl = document.createElement('small');
          helperEl.textContent = helper;
          wrapper.appendChild(helperEl);
        }
        return wrapper;
      }

      function createToggle(label, value, onChange, helper) {
        const row = document.createElement('div');
        row.className = 'toggle-row';
        const info = document.createElement('div');
        info.className = 'toggle-info';
        const title = document.createElement('div');
        title.className = 'font-semibold';
        title.textContent = label;
        info.appendChild(title);
        if (helper) {
          const helperEl = document.createElement('small');
          helperEl.textContent = helper;
          info.appendChild(helperEl);
        }
        const toggle = document.createElement('label');
        toggle.className = 'switch';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = value;
        input.addEventListener('change', (event) => {
          onChange(event.target.checked);
          syncDataFromState();
        });
        const slider = document.createElement('span');
        slider.className = 'slider';
        toggle.appendChild(input);
        toggle.appendChild(slider);
        row.appendChild(info);
        row.appendChild(toggle);
        return row;
      }

      function renderStagesStep(league, config) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-5';

        if (config.includePlayoffs || config.structureType === 'playoffs') {
          container.appendChild(createRange('Playoff entrants', 2, Math.max(2, config.teamCount), config.playoffTeams, 2, (value) => {
            config.playoffTeams = value;
            renderEditor();
          }, false, 'Number of teams advancing to the knockout bracket.'));

          container.appendChild(createRange('Games per matchup', 1, 3, config.gamesPerMatchup, 1, (value) => {
            config.gamesPerMatchup = value;
          }, false, 'Best-of series length for playoff rounds.'));

          container.appendChild(createToggle('Third-place match', config.includeThirdPlace, (checked) => {
            config.includeThirdPlace = checked;
            renderEditor();
          }));
        }

        const plan = createCompetitionPlan(league, config);
        const stageList = document.createElement('div');
        stageList.className = 'stage-list';

        plan.stages.forEach((stage) => {
          const details = document.createElement('details');
          details.className = 'stage-details';
          details.open = stage.key === 'main';
          const summary = document.createElement('summary');
          const header = document.createElement('div');
          header.className = 'stage-header';
          const icon = document.createElement('div');
          icon.className = 'stage-icon';
          icon.textContent = stage.icon || '⚙️';
          const title = document.createElement('div');
          title.className = 'flex flex-col';
          title.innerHTML = `<span class="font-semibold">${stage.name}</span><span class="text-sm text-slate-600">${stage.groups.length} group${stage.groups.length === 1 ? '' : 's'} • ${stage.rounds} round${stage.rounds === 1 ? '' : 's'}</span>`;
          header.appendChild(icon);
          header.appendChild(title);
          summary.appendChild(header);
          details.appendChild(summary);

          const body = document.createElement('div');
          body.className = 'details-body';
          const summaryRow = document.createElement('div');
          summaryRow.className = 'stage-summary';
          summaryRow.innerHTML = `
            <span class="badge">${stage.rounds} round${stage.rounds === 1 ? '' : 's'}</span>
            <span class="badge">${stage.estimatedMinGames} games</span>
            <span class="badge${state.developerMode ? '' : ' hidden'}">Stage ID ${stage.id}</span>
          `;
          body.appendChild(summaryRow);

          const list = document.createElement('div');
          list.className = 'flex flex-col gap-2';
          stage.groups.forEach((group) => {
            const item = document.createElement('div');
            item.className = 'badge';
            const idBadge = state.developerMode ? ` • ID ${group.id}` : '';
            item.textContent = `${group.name} • ${group.teamCount} teams${idBadge}`;
            list.appendChild(item);
          });
          body.appendChild(list);

          if (stage.entryTargetId && state.developerMode) {
            const idBlock = document.createElement('div');
            idBlock.className = 'callout';
            idBlock.innerHTML = `Stage key: <code>${stage.stageKey}</code><br>Stage ID: <code>${stage.id}</code>`;
            body.appendChild(idBlock);
          }

          details.appendChild(body);
          stageList.appendChild(details);
        });

        container.appendChild(stageList);
        return container;
      }

      function renderReviewStep(league, config, federation) {
        const container = document.createElement('div');
        container.className = 'flex flex-col gap-5';

        const plan = createCompetitionPlan(league, config);
        const summary = document.createElement('div');
        summary.className = 'callout';
        const totalGroups = plan.stages.reduce((sum, stage) => sum + stage.groups.length, 0);
        summary.innerHTML = `
          <div class="font-semibold mb-2">Summary</div>
          <div>${config.teamCount} teams • ${totalGroups} group${totalGroups === 1 ? '' : 's'} • ${plan.stages.length} stage${plan.stages.length === 1 ? '' : 's'}</div>
          <div>${plan.stages.map((stage) => stage.name).join(' → ')}</div>
        `;
        container.appendChild(summary);

        const tree = document.createElement('div');
        tree.className = 'flex flex-col gap-2';
        const fedId = getIdForKey(`fed:${federation.uuid}`);
        const leagueId = getIdForKey(`league:${league.uuid}`);
        tree.innerHTML = `
          <div class="badge">${federation.name}${state.developerMode ? ` • ${fedId}` : ''}</div>
          <div class="badge" style="margin-left:1.5rem;">${league.name}${state.developerMode ? ` • ${leagueId}` : ''}</div>
        `;
        plan.stages.forEach((stage) => {
          const stageEl = document.createElement('div');
          stageEl.className = 'badge';
          stageEl.style.marginLeft = '3rem';
          const idBadge = state.developerMode ? ` • ${stage.id}` : '';
          stageEl.textContent = `${stage.name}${idBadge}`;
          tree.appendChild(stageEl);
          stage.groups.forEach((group) => {
            const groupEl = document.createElement('div');
            groupEl.className = 'badge';
            groupEl.style.marginLeft = '4.5rem';
            const idInfo = state.developerMode ? ` • ${group.id}` : '';
            groupEl.textContent = `${group.name}${idInfo}`;
            tree.appendChild(groupEl);
          });
        });
        container.appendChild(tree);

        const notes = document.createElement('div');
        notes.className = 'text-sm text-slate-600';
        notes.textContent = 'Use Build & Export to regenerate compobj, settings, tasks, advancements, standings, schedule, objectives, and weather files. All references remain synchronized.';
        container.appendChild(notes);

        return container;
      }

      function createCompetitionPlan(league, config) {
        const plan = { stages: [], advancements: [], finalTargetId: null };
        const structure = config.structureType;
        const teamCount = Math.max(2, config.teamCount);

        if (structure === 'playoffs' && !config.includePlayoffs) {
          const playoffStage = buildPlayoffStage('playoff', league, config, teamCount);
          plan.stages.push(playoffStage);
          plan.finalTargetId = playoffStage.finalGroupId;
          return plan;
        }

        const groupStage = buildGroupStage('main', league, config, teamCount);
        plan.stages.push(groupStage);

        if (config.includePlayoffs) {
          const playoffTeams = Math.min(config.playoffTeams || teamCount, teamCount);
          const playoffStage = buildPlayoffStage('playoff', league, config, playoffTeams);
          plan.stages.push(playoffStage);
          plan.finalTargetId = playoffStage.finalGroupId;
          plan.advancements.push(...computeAdvancements(groupStage.groups, playoffStage.entryTargetId, playoffTeams));
        } else {
          plan.finalTargetId = groupStage.finalGroupId;
        }

        return plan;
      }

      function buildGroupStage(key, league, config, teamCount) {
        const groupCount = config.structureType === 'league' ? 1 : Math.max(1, config.groupCount);
        const stageKey = `league:${league.uuid}:stage:${key}`;
        const id = getIdForKey(stageKey);
        const rounds = Math.max(1, config.rounds);
        const homeAwayMultiplier = config.homeAndAway ? 2 : 1;
        const baseTeams = Math.floor(teamCount / groupCount);
        const remainder = teamCount % groupCount;
        const groups = [];
        for (let i = 0; i < groupCount; i += 1) {
          const teamsInGroup = baseTeams + (i < remainder ? 1 : 0);
          const groupKey = `${stageKey}:group:${i + 1}`;
          const groupId = getIdForKey(groupKey);
          groups.push({
            id: groupId,
            name: groupCount === 1 ? `${league.name} Table` : `Group ${String.fromCharCode(65 + i)}`,
            code: groupCount === 1 ? 'TABLE' : `G${i + 1}`,
            teamCount: teamsInGroup,
            objective: config.includePlayoffs ? 'ReachPlayoffs' : 'WinGroup',
            objectiveValue: config.includePlayoffs ? String(Math.max(1, Math.floor((config.playoffTeams || 1) / groupCount))) : '1'
          });
        }
        const matchesPerGroup = groups.reduce((sum, group) => sum + ((group.teamCount * (group.teamCount - 1)) / 2) * homeAwayMultiplier, 0);
        const estimatedGames = matchesPerGroup * rounds;
        return {
          key,
          stageKey,
          id,
          icon: stageIcons[config.structureType] || stageIcons.league,
          name: config.structureType === 'groups' ? 'Group Stage' : 'League Stage',
          code: config.structureType === 'groups' ? 'GRP' : 'REG',
          rounds,
          gamesPerMatchup: homeAwayMultiplier,
          groups,
          entryTargetId: groups[0]?.id || id,
          finalGroupId: groups[groups.length - 1]?.id || id,
          finalTargetId: groups[groups.length - 1]?.id || id,
          estimatedMinGames: estimatedGames,
          estimatedMaxGames: estimatedGames,
          includeThird: false
        };
      }

      function buildPlayoffStage(key, league, config, totalTeams) {
        const safeTeams = Math.max(2, totalTeams);
        const rounds = Math.max(1, Math.ceil(Math.log2(safeTeams)));
        const stageKey = `league:${league.uuid}:stage:${key}`;
        const id = getIdForKey(stageKey);
        const names = ['Round of 64', 'Round of 32', 'Round of 16', 'Quarterfinal', 'Semifinal', 'Final'];
        const startIndex = Math.max(0, names.length - rounds);
        const groups = [];
        let totalMatches = 0;
        for (let r = 0; r < rounds; r += 1) {
          const teamsInRound = Math.pow(2, rounds - r);
          const matches = teamsInRound / 2;
          totalMatches += matches * (config.gamesPerMatchup || 1);
          const groupKey = `${stageKey}:round:${r + 1}`;
          const groupId = getIdForKey(groupKey);
          groups.push({
            id: groupId,
            name: names[startIndex + r] || `Round ${r + 1}`,
            code: `R${rounds - r}`,
            teamCount: teamsInRound,
            objective: r === rounds - 1 ? 'WinFinal' : 'Advance',
            objectiveValue: '1'
          });
        }
        if (config.includeThirdPlace) {
          const thirdKey = `${stageKey}:third`;
          const thirdId = getIdForKey(thirdKey);
          groups.push({
            id: thirdId,
            name: 'Third Place Playoff',
            code: '3P',
            teamCount: 2,
            objective: 'WinMatch',
            objectiveValue: '1'
          });
          totalMatches += config.gamesPerMatchup || 1;
        }
        const finalGroup = config.includeThirdPlace ? groups[groups.length - 2] : groups[groups.length - 1];
        return {
          key,
          stageKey,
          id,
          icon: stageIcons.playoff,
          name: key === 'playoff' ? 'Playoffs' : 'Knockout Stage',
          code: 'PO',
          rounds,
          gamesPerMatchup: config.gamesPerMatchup || 1,
          groups,
          entryTargetId: groups[0]?.id || id,
          finalGroupId: finalGroup?.id || id,
          estimatedMinGames: totalMatches,
          estimatedMaxGames: totalMatches,
          includeThird: Boolean(config.includeThirdPlace)
        };
      }

      function computeAdvancements(groups, targetGroupId, totalSlots) {
        if (!groups.length || !targetGroupId) return [];
        const slots = Math.max(1, totalSlots);
        const perGroup = Math.max(1, Math.floor(slots / groups.length));
        let remainder = slots % groups.length;
        const adv = [];
        let slotIndex = 1;
        groups.forEach((group) => {
          let advCount = perGroup;
          if (remainder > 0) {
            advCount += 1;
            remainder -= 1;
          }
          for (let placement = 1; placement <= advCount; placement += 1) {
            adv.push({
              fromId: group.id,
              placement: String(placement),
              toId: targetGroupId,
              slot: String(slotIndex)
            });
            slotIndex += 1;
          }
        });
        return adv;
      }

      function validateProject() {
        const issues = [];
        if (!state.federations.length) {
          issues.push('No federations defined.');
        }
        state.federations.forEach((fed) => {
          if (!fed.name) issues.push('Federation missing a name.');
          if (!fed.code) issues.push(`Federation ${fed.name || fed.uuid} missing a code.`);
          if (!fed.leagues.length) issues.push(`${fed.name} has no competitions.`);
          fed.leagues.forEach((league) => {
            if (!league.name) issues.push('A competition is missing a name.');
            if (!league.code) issues.push(`${league.name || 'Competition'} is missing a short code.`);
            const config = ensureConfig(league);
            if (config.teamCount < 2) issues.push(`${league.name}: team count must be at least 2.`);
            if (config.structureType !== 'league' && config.groupCount > config.teamCount) issues.push(`${league.name}: group count exceeds teams.`);
            if (config.includePlayoffs) {
              if (!Number.isInteger(config.playoffTeams) || config.playoffTeams < 2) issues.push(`${league.name}: playoff entrants must be at least 2.`);
              if (config.playoffTeams > config.teamCount) issues.push(`${league.name}: playoff entrants cannot exceed team count.`);
            }
          });
        });
        return issues;
      }

      function buildProjectFiles() {
        const context = {
          compRows: [],
          setRows: [],
          taskRows: [],
          advRows: [],
          standRows: [],
          schedRows: [],
          objectiveRows: [],
          weatherRows: []
        };

        state.federations.forEach((fed) => {
          const fedId = getIdForKey(`fed:${fed.uuid}`);
          context.compRows.push({ id: fedId, level: '0', code: fed.code || '', name: fed.name || 'Federation', parent: '' });
          context.weatherRows.push({
            fedId,
            dayId: '1',
            weatherType: 'Clear',
            param1: '20',
            param2: '50',
            param3: '',
            param4: '',
            start: '1',
            end: '365'
          });

          fed.leagues.forEach((league) => {
            const leagueId = getIdForKey(`league:${league.uuid}`);
            const config = ensureConfig(league);
            context.compRows.push({ id: leagueId, level: '1', code: league.code || '', name: league.name || 'Competition', parent: fedId });
            context.setRows.push({ id: leagueId, settingKey: 'season', value: league.season || '' });
            context.setRows.push({ id: leagueId, settingKey: 'structure_type', value: config.structureType });
            context.setRows.push({ id: leagueId, settingKey: 'team_count', value: String(config.teamCount) });

            const plan = createCompetitionPlan(league, config);
            let stageIndex = 1;
            plan.stages.forEach((stage) => {
              context.compRows.push({ id: stage.id, level: '2', code: stage.code, name: stage.name, parent: leagueId });
              context.setRows.push({ id: stage.id, settingKey: 'rounds', value: String(stage.rounds) });
              context.setRows.push({ id: stage.id, settingKey: 'games_per_matchup', value: String(stage.gamesPerMatchup) });
              context.schedRows.push({
                stageId: stage.id,
                dateId: `AUTO-${stageIndex}`,
                matchDay: '1',
                minGames: String(stage.estimatedMinGames),
                maxGames: String(stage.estimatedMaxGames),
                time: config.matchTime || '20:00'
              });
              stage.groups.forEach((group, groupIndex) => {
                context.compRows.push({ id: group.id, level: '3', code: group.code, name: group.name, parent: stage.id });
                context.standRows.push({ groupId: group.id, teamCount: String(group.teamCount) });
                context.objectiveRows.push({ groupId: group.id, objective: group.objective, value: group.objectiveValue });
              });
              stageIndex += 1;
            });

            plan.advancements.forEach((adv) => context.advRows.push(adv));
            context.taskRows.push({ trophyId: leagueId, phase: 'FINALE', command: 'AWARD_TROPHY', target: plan.finalTargetId, ref1: '', ref2: '', ref3: '' });
          });
        });

        const files = [
          { name: 'compobj.txt', content: context.compRows.map((r) => [r.id, r.level, r.code, r.name, r.parent].join(',')).join('\n') },
          { name: 'settings.txt', content: context.setRows.map((r) => [r.id, r.settingKey, r.value].join(',')).join('\n') },
          { name: 'tasks.txt', content: context.taskRows.map((r) => [r.trophyId, r.phase, r.command, r.target, r.ref1, r.ref2, r.ref3].join(',')).join('\n') },
          { name: 'advancement.txt', content: context.advRows.map((r) => [r.fromId, r.placement, r.toId, r.slot].join(',')).join('\n') },
          { name: 'standings.txt', content: context.standRows.map((r) => [r.groupId, r.teamCount].join(',')).join('\n') },
          { name: 'schedule.txt', content: context.schedRows.map((r) => [r.stageId, r.dateId, r.matchDay, r.minGames, r.maxGames, r.time].join(',')).join('\n') },
          { name: 'objectives.txt', content: context.objectiveRows.map((r) => [r.groupId, r.objective, r.value].join(',')).join('\n') },
          { name: 'weather.txt', content: context.weatherRows.map((r) => [r.fedId, r.dayId, r.weatherType, r.param1, r.param2, r.param3, r.param4, r.start, r.end].join(',')).join('\n') }
        ];

        return { files, context };
      }

      function createZip(files) {
        const encoder = new TextEncoder();
        const fileRecords = [];
        const chunks = [];
        let offset = 0;
        files.forEach((file) => {
          const nameBytes = encoder.encode(file.name);
          const dataBytes = encoder.encode(file.content);
          const crc = crc32(dataBytes);
          const localHeader = new Uint8Array(30 + nameBytes.length);
          const localView = new DataView(localHeader.buffer);
          let p = 0;
          localView.setUint32(p, 0x04034b50, true); p += 4;
          localView.setUint16(p, 20, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localView.setUint32(p, crc, true); p += 4;
          localView.setUint32(p, dataBytes.length, true); p += 4;
          localView.setUint32(p, dataBytes.length, true); p += 4;
          localView.setUint16(p, nameBytes.length, true); p += 2;
          localView.setUint16(p, 0, true); p += 2;
          localHeader.set(nameBytes, 30);
          chunks.push(localHeader);
          chunks.push(dataBytes);
          fileRecords.push({ nameBytes, dataBytes, crc, offset });
          offset += localHeader.length + dataBytes.length;
        });

        const centralChunks = [];
        let centralSize = 0;
        fileRecords.forEach((record) => {
          const centralHeader = new Uint8Array(46 + record.nameBytes.length);
          const view = new DataView(centralHeader.buffer);
          let p = 0;
          view.setUint32(p, 0x02014b50, true); p += 4;
          view.setUint16(p, 20, true); p += 2;
          view.setUint16(p, 20, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint32(p, record.crc, true); p += 4;
          view.setUint32(p, record.dataBytes.length, true); p += 4;
          view.setUint32(p, record.dataBytes.length, true); p += 4;
          view.setUint16(p, record.nameBytes.length, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint16(p, 0, true); p += 2;
          view.setUint32(p, 0, true); p += 4;
          view.setUint32(p, record.offset, true); p += 4;
          centralHeader.set(record.nameBytes, 46);
          centralChunks.push(centralHeader);
          centralSize += centralHeader.length;
        });

        const centralOffset = offset;
        const totalSize = offset + centralSize + 22;
        const zipBuffer = new Uint8Array(totalSize);
        let cursor = 0;
        chunks.forEach((chunk) => { zipBuffer.set(chunk, cursor); cursor += chunk.length; });
        centralChunks.forEach((chunk) => { zipBuffer.set(chunk, cursor); cursor += chunk.length; });

        const end = new DataView(zipBuffer.buffer, cursor, 22);
        end.setUint32(0, 0x06054b50, true);
        end.setUint16(4, 0, true);
        end.setUint16(6, 0, true);
        end.setUint16(8, fileRecords.length, true);
        end.setUint16(10, fileRecords.length, true);
        end.setUint32(12, centralSize, true);
        end.setUint32(16, centralOffset, true);
        end.setUint16(20, 0, true);

        return new Blob([zipBuffer], { type: 'application/zip' });
      }

      const CRC32_TABLE = new Uint32Array(256).map((_, n) => {
        let c = n;
        for (let k = 0; k < 8; k += 1) {
          c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        return c >>> 0;
      });

      function crc32(bytes) {
        let crc = 0 ^ (-1);
        for (let i = 0; i < bytes.length; i += 1) {
          const y = (crc ^ bytes[i]) & 0xff;
          crc = (crc >>> 8) ^ CRC32_TABLE[y];
        }
        return (crc ^ (-1)) >>> 0;
      }

      function downloadBlob(filename, blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        setTimeout(() => URL.revokeObjectURL(url), 400);
      }

      function renderExportResults() {
        const container = $('exportResults');
        if (!container) return;
        container.innerHTML = '';
        if (!state.lastBuild) {
          const msg = document.createElement('div');
          msg.className = 'text-sm text-slate-600';
          msg.textContent = 'Run Build & Export to see generated files.';
          container.appendChild(msg);
          return;
        }
        const { files } = state.lastBuild;
        const chips = document.createElement('div');
        chips.className = 'export-grid';
        files.forEach((file) => {
          const chip = document.createElement('div');
          chip.className = 'export-chip';
          chip.innerHTML = `<span>${file.name}</span><span>${file.content.split(/\n/).filter(Boolean).length} lines</span>`;
          chips.appendChild(chip);
        });
        container.appendChild(chips);

        files.forEach((file) => {
          const details = document.createElement('details');
          details.className = 'stage-details';
          details.innerHTML = `<summary>${file.name}</summary>`;
          const pre = document.createElement('pre');
          pre.className = 'export-text';
          pre.textContent = file.content || '(empty)';
          details.appendChild(pre);
          container.appendChild(details);
        });
      }

      function handleBuildExport() {
        const issues = validateProject();
        if (issues.length) {
          showMessage('Build blocked by validation errors.', 'error');
          const container = $('exportResults');
          if (container) {
            container.innerHTML = '';
            const callout = document.createElement('div');
            callout.className = 'callout callout-error';
            callout.innerHTML = `<div class="font-semibold mb-2">Please fix the following:</div><ul>${issues.map((issue) => `<li>${issue}</li>`).join('')}</ul>`;
            container.appendChild(callout);
          }
          return;
        }
        syncDataFromState();
        const zip = createZip(state.lastBuild.files);
        downloadBlob('competition_export.zip', zip);
        showMessage('Build succeeded — ZIP download started.', 'success');
      }

      function handleDownloadZip() {
        if (!state.lastBuild) {
          showMessage('Nothing to download yet — run Build & Export first.', 'info');
          return;
        }
        syncDataFromState();
        const zip = createZip(state.lastBuild.files);
        downloadBlob('competition_export.zip', zip);
      }

      async function handleCopyText() {
        if (!state.lastBuild) {
          showMessage('Nothing to copy yet — run Build & Export first.', 'info');
          return;
        }
        syncDataFromState();
        const combined = state.lastBuild.files.map((file) => `# ${file.name}\n${file.content}`).join('\n\n');
        try {
          await navigator.clipboard.writeText(combined);
          showMessage('All file contents copied to clipboard.', 'success');
        } catch (err) {
          showMessage('Clipboard copy failed.', 'error');
        }
      }

      function renderAll() {
        renderFileStatus();
        renderFederations();
        renderLeagues();
        renderEditor();
        renderExportResults();
      }

      function setupEventHandlers() {
        const fileButtons = $('fileButtonGrid');
        if (fileButtons) {
          fileButtons.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-file]');
            if (!button) return;
            const key = button.dataset.file;
            const input = $(`fileInput-${key}`);
            if (input) input.click();
          });
        }

        fileDefinitions.forEach((def) => {
          const input = $(`fileInput-${def.key}`);
          if (!input) return;
          input.addEventListener('change', async (event) => {
            const file = event.target.files?.[0];
            if (file) await handleFileSelection(def, file);
            event.target.value = '';
          });
        });

        const zipButton = $('importZipBtn');
        const zipInput = $('zipInput');
        if (zipButton && zipInput) {
          zipButton.addEventListener('click', () => zipInput.click());
          zipInput.addEventListener('change', async (event) => {
            const file = event.target.files?.[0];
            if (file) await handleZipSelection(file);
            event.target.value = '';
          });
        }

        const exportButtons = $('fileExportButtons');
        if (exportButtons) {
          exportButtons.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-export]');
            if (!button) return;
            const key = button.dataset.export;
            if (key === 'zip-all') {
              handleDownloadZip();
              return;
            }
            const def = fileDefinitions.find((item) => item.key === key);
            if (!def) return;
            const rows = getRowsForArray(def.arrayKey);
            if (!rows.length) return;
            downloadText(def.fileName, rowsToText(rows, def.formatter));
          });
        }

        const validateAllBtn = $('validateAllBtn');
        if (validateAllBtn) {
          validateAllBtn.addEventListener('click', handleValidateAll);
        }

        const federationList = $('federationList');
        if (federationList) {
          federationList.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-fed-id]');
            if (!button) return;
            state.selectedFederation = button.dataset.fedId;
            const federation = getSelectedFederation();
            state.selectedLeague = federation?.leagues[0]?.uuid || null;
            renderAll();
          });
        }

        const leagueList = $('leagueList');
        if (leagueList) {
          leagueList.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-league-id]');
            if (!button) return;
            state.selectedLeague = button.dataset.leagueId;
            renderEditor();
            renderLeagues();
          });
        }

        const search = $('leagueSearch');
        if (search) {
          search.addEventListener('input', (event) => {
            state.leagueSearch = event.target.value;
            renderLeagues();
          });
        }

        const addLeagueBtn = $('addLeagueBtn');
        if (addLeagueBtn) {
          addLeagueBtn.addEventListener('click', () => {
            const federation = getSelectedFederation();
            if (!federation) {
              showMessage('Select a federation first.', 'info');
              return;
            }
            const name = prompt('Competition name', 'New Competition');
            if (!name) return;
            const code = prompt('Short code', name.slice(0, 4).toUpperCase());
            const season = prompt('Season label', new Date().getFullYear());
            const league = createLeague(name, (code || name.slice(0, 4)).toUpperCase(), season || '');
            federation.leagues.push(league);
            state.selectedLeague = league.uuid;
            syncDataFromState();
            renderAll();
            showMessage('Competition created.', 'success');
          });
        }

        const buildBtn = $('buildExportBtn');
        if (buildBtn) buildBtn.addEventListener('click', handleBuildExport);
        const zipBtn = $('downloadZipBtn');
        if (zipBtn) zipBtn.addEventListener('click', handleDownloadZip);
        const copyBtn = $('copyTextBtn');
        if (copyBtn) copyBtn.addEventListener('click', handleCopyText);

        const themeToggle = $('themeToggle');
        if (themeToggle) {
          themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark');
            themeToggle.textContent = document.body.classList.contains('dark') ? 'Toggle Light' : 'Toggle Dark';
          });
        }

        const developerToggle = $('developerToggle');
        if (developerToggle) {
          developerToggle.addEventListener('click', () => {
            state.developerMode = !state.developerMode;
            developerToggle.textContent = state.developerMode ? 'Developer Mode • On' : 'Developer Mode';
            renderAll();
          });
        }

        const prevStepBtn = $('prevStepBtn');
        const nextStepBtn = $('nextStepBtn');
        if (prevStepBtn) {
          prevStepBtn.addEventListener('click', () => {
            state.stepIndex = Math.max(0, state.stepIndex - 1);
            renderEditor();
          });
        }
        if (nextStepBtn) {
          nextStepBtn.addEventListener('click', () => {
            state.stepIndex = Math.min(3, state.stepIndex + 1);
            renderEditor();
          });
        }
      }

      function init() {
        state.federations = createInitialProject();
        state.selectedFederation = state.federations[0]?.uuid || null;
        state.selectedLeague = state.federations[0]?.leagues[0]?.uuid || null;
        setupEventHandlers();
        syncDataFromState();
        renderAll();
        showMessage('Designer ready — tweak a league and export when finished.', 'info');
      }

      init();
    })();
  </script>
</body>
</html>
