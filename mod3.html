<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CompObj + Advancement Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: light dark; }
    .row-dirty { outline: 2px dashed rgb(251 191 36 / 0.7); }
    .sticky-th { position: sticky; top: 0; z-index: 10; }
    .level-comp { background-color: rgba(16, 185, 129, 0.18); }
    .level-stage { background-color: rgba(14, 165, 233, 0.18); }
    .level-group { background-color: rgba(251, 191, 36, 0.2); }
    .level-selected { outline: 2px solid rgba(79, 70, 229, 0.6); outline-offset: -2px; }
    #rowEditorModal.hidden { display: none; }
    #rowEditorModal { position: fixed; inset: 0; background-color: rgba(15, 23, 42, 0.55); display: flex; align-items: center; justify-content: center; padding: 1.5rem; z-index: 50; }
    #rowEditorModal .modal-card { max-width: 32rem; width: 100%; }
    @media (max-width: 640px) {
      #rowEditorModal { align-items: flex-end; }
      #rowEditorModal .modal-card { border-radius: 1.25rem 1.25rem 0 0; }
    }
    @media (prefers-color-scheme: dark) {
      .level-comp { background-color: rgba(16, 185, 129, 0.35); }
      .level-stage { background-color: rgba(14, 165, 233, 0.35); }
      .level-group { background-color: rgba(251, 191, 36, 0.35); }
    }
  </style>
</head>
<body class="bg-slate-100 text-slate-900 p-6">
  <div class="max-w-6xl mx-auto">

    <!-- Header -->
    <header class="flex items-start justify-between gap-4 mb-6">
      <div>
        <h1 class="text-2xl font-bold">CompObj & Advancement Editor</h1>
        <p class="text-sm text-slate-600">
          Manage competition structures (CompObj) and advancement mapping lines in one tool.
        </p>
      </div>
      <div class="flex items-center gap-2">
        <label class="text-sm">Theme</label>
        <select id="themeSelect" class="p-2 rounded border bg-white">
          <option value="system">System</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
    </header>

    <section class="mb-6">
      <div class="flex flex-wrap items-center gap-3">
        <label for="competitionSelect" class="text-sm font-medium text-slate-700">Competition Filter</label>
        <select id="competitionSelect" class="p-2 rounded border bg-white min-w-[16rem]">
          <option value="">All competitions</option>
        </select>
        <span id="competitionSummary" class="text-sm text-slate-600"></span>
      </div>
    </section>

    <!-- ===================== -->
    <!-- CompObj Editor -->
    <!-- ===================== -->
    <section class="mb-10">
      <h2 class="text-xl font-bold mb-2">CompObj Editor</h2>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="fileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="pasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="exportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
        <button id="rebaseBtn" class="px-3 py-2 bg-amber-500 text-white rounded">Rebase IDs</button>
        <button id="autoFixBtn" class="px-3 py-2 bg-blue-600 text-white rounded">Auto-Fix Parents</button>
        <button id="dedupeBtn" class="px-3 py-2 bg-fuchsia-600 text-white rounded">De-duplicate IDs</button>
      </div>

      <div class="mb-3 flex flex-wrap items-center gap-3">
        <label class="text-sm">Rebase start ID:</label>
        <input id="rebaseStart" type="number" value="1000" class="p-2 rounded border w-24 bg-white">
        <label class="text-sm">Delimiter:</label>
        <select id="delimiter" class="p-2 rounded border bg-white">
          <option value=",">Comma</option>
          <option value="\t">Tab</option>
          <option value=";">Semicolon</option>
          <option value="|">Pipe</option>
          <option value="auto" selected>Auto-detect</option>
        </select>
      </div>

      <textarea id="pasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste CompObj lines here..."></textarea>
      <div id="meta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table id="dataTable" class="min-w-full table-auto text-sm">
          <thead>
            <tr class="bg-slate-50 sticky-th">
              <th class="p-2">#</th>
              <th class="p-2">ID</th>
              <th class="p-2">Level</th>
              <th class="p-2">Code</th>
              <th class="p-2">Name</th>
              <th class="p-2">Parent</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

      <div class="mt-4 flex flex-wrap gap-2">
        <button id="addLineBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Line</button>
        <button id="addStageBtn" class="px-3 py-2 bg-emerald-600 text-white rounded">+ Add Stage</button>
        <button id="addGroupBtn" class="px-3 py-2 bg-sky-600 text-white rounded">+ Add Group</button>
        <button id="sortByIdBtn" class="px-3 py-2 bg-slate-500 text-white rounded">Sort by ID</button>
        <button id="validateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
      </div>

      <div id="messages" class="mt-3 text-sm"></div>

      <div class="mt-4 grid gap-4 lg:grid-cols-[3fr,2fr]">
        <div>
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold text-slate-700">Hierarchy Preview</h3>
            <span class="text-xs text-slate-500">Level colors: <span class="inline-flex items-center gap-1"><span class="inline-block h-3 w-3 rounded-sm" style="background-color: rgba(16,185,129,0.6);"></span>Comp</span> · <span class="inline-flex items-center gap-1"><span class="inline-block h-3 w-3 rounded-sm" style="background-color: rgba(14,165,233,0.6);"></span>Stage</span> · <span class="inline-flex items-center gap-1"><span class="inline-block h-3 w-3 rounded-sm" style="background-color: rgba(251,191,36,0.6);"></span>Group</span></span>
          </div>
          <div id="hierarchyPreview" class="text-sm bg-white dark:bg-slate-900/70 border border-slate-200 dark:border-slate-700 rounded p-3 max-h-80 overflow-auto"></div>
        </div>
        <div>
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold text-slate-700">Advancement Relationships</h3>
            <span class="text-xs text-slate-500">Read-only</span>
          </div>
          <div id="relationshipsViewer" class="text-sm bg-white dark:bg-slate-900/70 border border-slate-200 dark:border-slate-700 rounded p-3 max-h-80 overflow-auto text-slate-700 dark:text-slate-200">Load a competition file to preview relationships.</div>
        </div>
      </div>
    </section>

    <!-- ===================== -->
    <!-- Advancement Editor -->
    <!-- ===================== -->
    <section id="advEditor">
      <h2 class="text-xl font-bold mb-2">Advancement Editor</h2>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="advFileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="advPasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="advExportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
      </div>

      <textarea id="advPasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste advancement lines here... (FromGroup,PlacementOrWinner,ToGroup,Slot)"></textarea>
      <div id="advMeta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table id="advTable" class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2">#</th>
              <th class="p-2">From Group ID</th>
              <th class="p-2">Placement / Winner</th>
              <th class="p-2">To Group ID</th>
              <th class="p-2">Slot #</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="advBody"></tbody>
        </table>
      </div>

      <div class="mt-3 flex gap-2">
        <button id="advAddBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Line</button>
        <button id="advSortBtn" class="px-3 py-2 bg-slate-500 text-white rounded">Sort by From ID</button>
        <button id="advValidateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
      </div>

      <div id="advMessages" class="mt-3 text-sm"></div>
    </section>

    <!-- ===================== -->
    <!-- Standings Editor -->
    <!-- ===================== -->
    <section id="standingsEditor" class="mt-10">
      <h2 class="text-xl font-bold mb-2">Standings Editor</h2>
      <p class="text-sm text-slate-600 mb-3">
        Manage standings slot definitions such as <code>GroupId,ZeroBasedSlot</code>.
        Remember that slot <code>0</code> represents the first team in a table.
      </p>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="standingsFileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="standingsPasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="standingsExportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
      </div>

      <textarea id="standingsPasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste standings lines here... (GroupId,ZeroBasedSlot)"></textarea>
      <div id="standingsMeta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2">#</th>
              <th class="p-2">Group ID</th>
              <th class="p-2">Slot (0-index)</th>
              <th class="p-2">Team #</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="standingsBody"></tbody>
        </table>
      </div>

      <div class="mt-3 flex gap-2">
        <button id="standingsAddBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Line</button>
        <button id="standingsSortBtn" class="px-3 py-2 bg-slate-500 text-white rounded">Sort by Group</button>
        <button id="standingsValidateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
      </div>

      <div id="standingsMessages" class="mt-3 text-sm"></div>
    </section>

    <!-- ===================== -->
    <!-- Settings Editor -->
    <!-- ===================== -->
    <section id="settingsEditor" class="mt-10">
      <h2 class="text-xl font-bold mb-2">Settings Editor</h2>
      <p class="text-sm text-slate-600 mb-3">
        Manage competition settings lines formatted as <code>CompObjID,SettingKey,SettingValue</code>.
        Each row links directly to a CompObj entry.
      </p>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="settingsFileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="settingsPasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="settingsExportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
        <button id="settingsValidateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
        <button id="settingsAddBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Row</button>
      </div>

      <textarea id="settingsPasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste settings lines here... (CompObjID,SettingKey,SettingValue)"></textarea>
      <div id="settingsMeta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2">#</th>
              <th class="p-2">CompObj ID</th>
              <th class="p-2">Setting Key</th>
              <th class="p-2">Setting Value</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="settingsBody"></tbody>
        </table>
      </div>

      <div id="settingsMessages" class="mt-3 text-sm"></div>
    </section>

    <!-- ===================== -->
    <!-- Schedule Editor -->
    <!-- ===================== -->
    <section id="scheduleEditor" class="mt-10">
      <h2 class="text-xl font-bold mb-2">Schedule Editor</h2>
      <p class="text-sm text-slate-600 mb-3">
        Manage fixture schedule rows formatted as <code>StageID,DateID,RoundNumber,MinGames,MaxGames,Time</code>.
      </p>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="scheduleFileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="schedulePasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="scheduleExportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
        <button id="scheduleValidateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
        <button id="scheduleAddBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Row</button>
      </div>

      <textarea id="schedulePasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste schedule lines here... (StageID,DateID,RoundNumber,MinGames,MaxGames,Time)"></textarea>
      <div id="scheduleMeta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2">#</th>
              <th class="p-2">Stage ID</th>
              <th class="p-2">Date ID</th>
              <th class="p-2">Round #</th>
              <th class="p-2">Min Games</th>
              <th class="p-2">Max Games</th>
              <th class="p-2">Time</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="scheduleBody"></tbody>
        </table>
      </div>

      <div id="scheduleMessages" class="mt-3 text-sm"></div>
    </section>

    <!-- ===================== -->
    <!-- Tasks Editor -->
    <!-- ===================== -->
    <section id="taskEditor" class="mt-10">
      <h2 class="text-xl font-bold mb-2">Tasks Editor</h2>
      <p class="text-sm text-slate-600 mb-3">
        Manage competition task lines such as <code>FillFromLeague</code>, <code>FillWithTeam</code>, and <code>UpdateTable</code>.
      </p>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="taskFileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="taskPasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="taskExportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
        <label class="text-sm">Delimiter:</label>
        <select id="taskDelimiter" class="p-2 rounded border bg-white">
          <option value=",">Comma</option>
          <option value="\t">Tab</option>
          <option value=";">Semicolon</option>
          <option value="|">Pipe</option>
          <option value="auto" selected>Auto-detect</option>
        </select>
      </div>

      <textarea id="taskPasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste tasks lines here... (TrophyLine,Phase,TaskType,Arg1,Arg2,Arg3,Arg4)"></textarea>
      <div id="taskMeta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2">#</th>
              <th class="p-2">Trophy Line</th>
              <th class="p-2">Phase</th>
              <th class="p-2">Task Type</th>
              <th class="p-2">Arg 1</th>
              <th class="p-2">Arg 2</th>
              <th class="p-2">Arg 3</th>
              <th class="p-2">Arg 4</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="taskBody"></tbody>
        </table>
      </div>

      <div class="mt-3 flex gap-2">
        <button id="taskAddBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Task</button>
        <button id="taskSortBtn" class="px-3 py-2 bg-slate-500 text-white rounded">Sort by Trophy</button>
        <button id="taskValidateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
      </div>

      <div id="taskMessages" class="mt-3 text-sm"></div>
    </section>

    <!-- ===================== -->
    <!-- Weather Editor -->
    <!-- ===================== -->
    <section id="weatherEditor" class="mt-10">
      <h2 class="text-xl font-bold mb-2">Weather Editor</h2>
      <p class="text-sm text-slate-600 mb-3">
        Manage weather configuration lines formatted as
        <code>FederationID,DayID,WeatherType,Param1,Param2,Param3,Param4,StartTime,EndTime</code>.
      </p>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="weatherFileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="weatherPasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="weatherAddBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Row</button>
        <button id="weatherExportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
        <button id="weatherValidateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
      </div>

      <textarea id="weatherPasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste weather lines here... (FederationID,DayID,WeatherType,Param1,Param2,Param3,Param4,StartTime,EndTime)"></textarea>
      <div id="weatherMeta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2">#</th>
              <th class="p-2">Federation ID</th>
              <th class="p-2">Day ID</th>
              <th class="p-2">Weather Type</th>
              <th class="p-2">Param1</th>
              <th class="p-2">Param2</th>
              <th class="p-2">Param3</th>
              <th class="p-2">Param4</th>
              <th class="p-2">Start Time</th>
              <th class="p-2">End Time</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="weatherBody"></tbody>
        </table>
      </div>

      <div id="weatherMessages" class="mt-3 text-sm"></div>
    </section>

    <!-- ===================== -->
    <!-- Objectives Editor -->
    <!-- ===================== -->
    <section id="objectivesEditor" class="mt-10">
      <h2 class="text-xl font-bold mb-2">Objectives Editor</h2>
      <p class="text-sm text-slate-600 mb-3">
        Manage team or group objectives listed in <code>objectives.txt</code> as
        <code>TargetID,ObjectiveCode,IsPrimary</code> lines.
      </p>

      <div class="mb-3 flex flex-wrap items-center gap-2">
        <input id="objectivesFileInput" type="file" accept=".txt" class="p-2 bg-white rounded border">
        <button id="objectivesPasteBtn" class="px-3 py-2 bg-indigo-600 text-white rounded">Paste/Text</button>
        <button id="objectivesAddBtn" class="px-3 py-2 bg-slate-700 text-white rounded">+ Add Objective</button>
        <button id="objectivesExportBtn" class="px-3 py-2 bg-green-600 text-white rounded">Export</button>
        <button id="objectivesValidateBtn" class="px-3 py-2 bg-red-600 text-white rounded">Validate</button>
      </div>

      <textarea id="objectivesPasteArea" class="w-full h-24 p-2 border rounded hidden" placeholder="Paste objective lines here... (TargetID,ObjectiveCode,IsPrimary)"></textarea>
      <div id="objectivesMeta" class="text-sm text-slate-600 mb-2"></div>

      <div class="overflow-x-auto border rounded">
        <table class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2">#</th>
              <th class="p-2">Target ID</th>
              <th class="p-2">Objective Code</th>
              <th class="p-2">Primary?</th>
              <th class="p-2">Actions</th>
            </tr>
          </thead>
          <tbody id="objectivesBody"></tbody>
        </table>
      </div>

      <div id="objectivesMessages" class="mt-3 text-sm"></div>
    </section>

    <!-- ===================== -->
    <!-- Validation & Repair -->
    <!-- ===================== -->
    <section id="validatorSection" class="mt-10">
      <div class="flex items-start justify-between flex-wrap gap-4 mb-4">
        <div>
          <h2 class="text-xl font-bold">Validation &amp; Repair Center</h2>
          <p class="text-sm text-slate-600">
            Validate syntax, structure, and cross-file references across all competition data files before exporting.
          </p>
        </div>
        <label class="flex items-center gap-2 text-sm text-slate-600">
          <input id="autoRepairToggle" type="checkbox" class="h-4 w-4">
          Auto repair simple issues after validation
        </label>
      </div>

      <div class="flex flex-wrap items-center gap-3 mb-4">
        <label class="text-sm font-medium text-slate-700">
          Load default baseline folder
          <input id="baselineInput" type="file" webkitdirectory multiple class="block mt-1 text-sm" />
        </label>
        <span id="baselineStatus" class="text-sm text-slate-600"></span>
      </div>

      <div class="flex flex-wrap items-center gap-2 mb-4">
        <button id="runValidationBtn" class="px-3 py-2 bg-red-600 text-white rounded">Run Validation</button>
        <button id="applyAllFixesBtn" class="px-3 py-2 bg-blue-600 text-white rounded" disabled>Apply All Fixes</button>
        <button id="exportValidatedBtn" class="px-3 py-2 bg-green-600 text-white rounded" disabled>Export Validated Files</button>
        <button id="viewDifferencesBtn" class="px-3 py-2 bg-amber-500 text-white rounded" disabled>View Differences</button>
        <span id="validationStatus" class="text-sm text-slate-600"></span>
      </div>

      <div class="overflow-x-auto border rounded mb-4">
        <table class="min-w-full table-auto text-sm">
          <thead class="bg-slate-50">
            <tr>
              <th class="p-2 text-left">File</th>
              <th class="p-2 text-left">Errors</th>
              <th class="p-2 text-left">Warnings</th>
              <th class="p-2 text-left">Notes</th>
            </tr>
          </thead>
          <tbody id="validationSummaryBody"></tbody>
        </table>
      </div>

      <div class="grid gap-4 lg:grid-cols-2">
        <div class="border rounded p-3 bg-white dark:bg-slate-900/70">
          <h3 class="font-semibold text-slate-700 dark:text-slate-200 mb-2">Issues</h3>
          <div id="validationLog" class="text-sm max-h-72 overflow-auto space-y-2"></div>
        </div>
        <div class="border rounded p-3 bg-white dark:bg-slate-900/70">
          <h3 class="font-semibold text-slate-700 dark:text-slate-200 mb-2">Auto-fix Suggestions</h3>
          <div id="fixList" class="text-sm max-h-72 overflow-auto space-y-2"></div>
        </div>
      </div>

      <div id="diffViewer" class="mt-4 border rounded p-3 bg-white dark:bg-slate-900/70 hidden">
        <div class="flex items-center justify-between mb-2">
          <h3 class="font-semibold text-slate-700 dark:text-slate-200">Baseline Differences</h3>
          <button id="closeDiffBtn" class="text-sm text-slate-500 hover:text-slate-700">Close</button>
        </div>
        <div id="diffOutput" class="text-sm max-h-80 overflow-auto space-y-1"></div>
      </div>

      <div id="changelogStatus" class="mt-3 text-xs text-slate-500"></div>
    </section>

  </div>

  <!-- Row Editor Modal -->
  <div id="rowEditorModal" class="hidden">
    <div class="modal-card bg-white dark:bg-slate-900 text-slate-800 dark:text-slate-100 rounded-xl shadow-xl border border-slate-200 dark:border-slate-700 p-6 space-y-4">
      <div class="flex items-start justify-between">
        <div>
          <h3 class="text-lg font-semibold">Line Editor</h3>
          <p class="text-xs text-slate-500">Update the selected line without regenerating other entries.</p>
        </div>
        <button id="rowEditorClose" class="text-slate-500 hover:text-slate-700 dark:hover:text-slate-200" aria-label="Close editor">✕</button>
      </div>

      <div class="grid gap-3">
        <label class="text-sm font-medium text-slate-600 dark:text-slate-300">
          Line Type
          <select id="rowTypeSelect" class="mt-1 w-full p-2 border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 rounded">
            <option value="competition">Competition (Level 3)</option>
            <option value="stage">Stage (Level 4)</option>
            <option value="group">Group (Level 5)</option>
          </select>
        </label>
        <label id="stageSubtypeWrapper" class="text-sm font-medium text-slate-600 dark:text-slate-300">
          Stage subtype
          <select id="stageSubtypeSelect" class="mt-1 w-full p-2 border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 rounded">
            <option value="LEAGUE">League</option>
            <option value="GROUP">Group</option>
            <option value="PLAYOFF">Playoff</option>
            <option value="SEMI_FINAL">Semi-Final</option>
            <option value="FINAL">Final</option>
            <option value="custom">Custom (keep code)</option>
          </select>
        </label>
        <label class="text-sm font-medium text-slate-600 dark:text-slate-300">
          Code
          <input id="rowCodeInput" type="text" class="mt-1 w-full p-2 border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 rounded" />
        </label>
        <label class="text-sm font-medium text-slate-600 dark:text-slate-300">
          Name
          <input id="rowNameInput" type="text" class="mt-1 w-full p-2 border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 rounded" />
        </label>
        <label class="text-sm font-medium text-slate-600 dark:text-slate-300">
          Parent ID
          <input id="rowParentInput" type="text" class="mt-1 w-full p-2 border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 rounded" />
        </label>
      </div>

      <div>
        <h4 class="text-sm font-semibold text-slate-600 dark:text-slate-300 mb-1">Advancement Relationships</h4>
        <div id="modalRelationships" class="text-xs bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded p-2 max-h-32 overflow-auto text-slate-600 dark:text-slate-200"></div>
      </div>

      <div class="flex justify-end gap-2">
        <button id="rowEditorCancel" class="px-3 py-2 rounded border border-slate-300 dark:border-slate-600 text-slate-600 dark:text-slate-200">Cancel</button>
        <button id="rowEditorSave" class="px-3 py-2 rounded bg-indigo-600 text-white">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- ===================== -->
  <!-- JavaScript -->
  <!-- ===================== -->
  <script>
    /* -----------------------
       CompObj Section
    ----------------------- */
    function autoDetectDelimiter(text){
      const sample = text.split(/\r?\n/).map(l=>l.trim()).find(Boolean) || '';
      const candidates=[',','\t',';','|'];
      let best=',';
      let bestCount=0;
      candidates.forEach(del=>{
        const count=sample ? sample.split(del).length : 0;
        if(count>bestCount){ bestCount=count; best=del; }
      });
      return best;
    }

    let rows = [];
    let compRawLines = [];
    let compDelimiter = ',';
    let activeCompetitionId = '';
    let activeScopeIds = null;

    const tbody = document.getElementById('tbody');
    const competitionSelect = document.getElementById('competitionSelect');
    const competitionSummary = document.getElementById('competitionSummary');
    const messagesEl = document.getElementById('messages');
    const hierarchyPreview = document.getElementById('hierarchyPreview');
    const relationshipsViewer = document.getElementById('relationshipsViewer');
    const modalRelationships = document.getElementById('modalRelationships');
    const rowEditorModal = document.getElementById('rowEditorModal');
    const rowTypeSelect = document.getElementById('rowTypeSelect');
    const stageSubtypeWrapper = document.getElementById('stageSubtypeWrapper');
    const stageSubtypeSelect = document.getElementById('stageSubtypeSelect');
    const rowCodeInput = document.getElementById('rowCodeInput');
    const rowNameInput = document.getElementById('rowNameInput');
    const rowParentInput = document.getElementById('rowParentInput');
    const rowEditorSave = document.getElementById('rowEditorSave');
    const rowEditorCancel = document.getElementById('rowEditorCancel');
    const rowEditorClose = document.getElementById('rowEditorClose');

    const objectivesBody = document.getElementById('objectivesBody');
    const objectivesMeta = document.getElementById('objectivesMeta');
    const objectivesMessages = document.getElementById('objectivesMessages');

    const validationSummaryBody = document.getElementById('validationSummaryBody');
    const validationLog = document.getElementById('validationLog');
    const fixList = document.getElementById('fixList');
    const diffViewer = document.getElementById('diffViewer');
    const diffOutput = document.getElementById('diffOutput');
    const closeDiffBtn = document.getElementById('closeDiffBtn');
    const baselineInput = document.getElementById('baselineInput');
    const baselineStatus = document.getElementById('baselineStatus');
    const runValidationBtn = document.getElementById('runValidationBtn');
    const applyAllFixesBtn = document.getElementById('applyAllFixesBtn');
    const exportValidatedBtn = document.getElementById('exportValidatedBtn');
    const viewDifferencesBtn = document.getElementById('viewDifferencesBtn');
    const validationStatus = document.getElementById('validationStatus');
    const autoRepairToggle = document.getElementById('autoRepairToggle');
    const changelogStatus = document.getElementById('changelogStatus');

    let selectedRowIndex = -1;
    const stageSubtypeTokens = [
      {value:'LEAGUE', label:'League'},
      {value:'GROUP', label:'Group'},
      {value:'PLAYOFF', label:'Playoff'},
      {value:'SEMI_FINAL', label:'Semi-Final'},
      {value:'FINAL', label:'Final'}
    ];

    let weatherRows = [];
    let weatherRawLines = [];

    let objectiveRows = [];
    let objectiveRawLines = [];

    const validationState = {
      issues: [],
      suggestions: [],
      diffs: [],
      baseline: new Map(),
      changelog: [],
      validatedOutputs: new Map(),
      autoRepairEnabled: false,
      runningAutoRepair: false,
      lastRan: null
    };

    function normalizeId(value){
      return String(value ?? '').trim();
    }

    function normalizeIdUpper(value){
      return normalizeId(value).toUpperCase();
    }

    function escapeHtml(value){
      return String(value ?? '').replace(/[&<>"']/g, ch=>({
        '&':'&amp;',
        '<':'&lt;',
        '>':'&gt;',
        '"':'&quot;',
        "'":'&#39;'
      })[ch] || ch);
    }

    function getRowTypeFromLevel(level){
      const norm = normalizeId(level);
      if(norm==='3') return 'competition';
      if(norm==='4') return 'stage';
      if(norm==='5') return 'group';
      return 'unknown';
    }

    function getLevelFromType(type){
      if(type==='competition') return '3';
      if(type==='stage') return '4';
      if(type==='group') return '5';
      return '';
    }

    function levelClassFromType(type){
      if(type==='competition') return 'level-comp';
      if(type==='stage') return 'level-stage';
      if(type==='group') return 'level-group';
      return '';
    }

    function typeDotClass(type){
      if(type==='competition') return 'bg-emerald-500';
      if(type==='stage') return 'bg-sky-500';
      if(type==='group') return 'bg-amber-500';
      return 'bg-slate-400';
    }

    function deriveStageSubtype(code){
      const upper = normalizeIdUpper(code);
      const match = stageSubtypeTokens.find(opt=>upper.startsWith(opt.value));
      return match ? match.value : 'custom';
    }

    function mergeStageSubtypeWithCode(subtype, currentCode){
      if(subtype==='custom') return currentCode;
      const suffixMatch = /_(\d+)$/i.exec(normalizeId(currentCode));
      const suffix = suffixMatch ? `_${suffixMatch[1]}` : '';
      return `${subtype}${suffix}`;
    }

    function ensureStageSubtypeVisibility(type){
      if(!stageSubtypeWrapper) return;
      stageSubtypeWrapper.classList.toggle('hidden', type!=='stage');
    }

    function describeRowLabel(row){
      const type = getRowTypeFromLevel(row?.level);
      const idLabel = escapeHtml(row?.id || '?');
      const nameLabel = escapeHtml(row?.name || '(no name)');
      const code = row?.code ? ` <span class="text-slate-400 dark:text-slate-500">[${escapeHtml(row.code)}]</span>` : '';
      const typeLabel = type==='unknown' ? `Level ${escapeHtml(row?.level || '?')}` : type.charAt(0).toUpperCase() + type.slice(1);
      return `<span class="font-medium">${typeLabel}</span> <span class="text-slate-500 dark:text-slate-400">#${idLabel}</span> — ${nameLabel}${code}`;
    }

    function rowMatchesScope(row, keys){
      if(!activeCompetitionId || !activeScopeIds) return true;
      let hasScopedValue = false;
      for(const key of keys){
        const normalizedValue = normalizeId(row?.[key]);
        if(!normalizedValue){
          continue;
        }
        hasScopedValue = true;
        if(activeScopeIds.has(normalizedValue)){
          return true;
        }
      }
      return !hasScopedValue;
    }

    function getVisibleIndexes(rowsArray, keys){
      if(!Array.isArray(rowsArray)) return [];
      const indexes=[];
      rowsArray.forEach((row,idx)=>{
        if(rowMatchesScope(row, keys)) indexes.push(idx);
      });
      return indexes;
    }

    function buildRelationshipHtml(rowId){
      const normalized = normalizeId(rowId);
      if(!normalized){
        return '<p class="text-slate-500 dark:text-slate-300">Select a row to inspect relationships.</p>';
      }

      const outgoing = [];
      const incoming = [];
      advRows.forEach((row, idx)=>{
        const fromId = normalizeId(row.fromId);
        const toId = normalizeId(row.toId);
        const qualifier = row.qualifier ? ` · ${escapeHtml(row.qualifier)}` : '';
        const slot = row.slot ? ` · slot ${escapeHtml(row.slot)}` : '';
        if(fromId === normalized){
          outgoing.push(`Adv #${idx+1}: → ${escapeHtml(row.toId || '?')}${qualifier}${slot}`);
        }
        if(toId === normalized){
          incoming.push(`Adv #${idx+1}: ← ${escapeHtml(row.fromId || '?')}${qualifier}${slot}`);
        }
      });

      const standings = [];
      standingsRows.forEach((row, idx)=>{
        if(normalizeId(row.groupId) === normalized){
          const slotLabel = row.slot === '' ? 'slot ?' : `slot ${escapeHtml(row.slot)}`;
          standings.push(`Standings #${idx+1}: ${slotLabel}`);
        }
      });

      const settingsLinks = [];
      settingRows.forEach((row, idx)=>{
        if(normalizeId(row.id) === normalized){
          const key = escapeHtml(row.key ?? '');
          const value = escapeHtml(row.value ?? '');
          settingsLinks.push(`Setting #${idx+1}: ${key}${value ? ` = ${value}` : ''}`);
        }
      });

      const scheduleLinks = [];
      scheduleRows.forEach((row, idx)=>{
        if(normalizeId(row.stage) === normalized){
          const round = row.round ? ` · Round ${escapeHtml(row.round)}` : '';
          const date = row.date ? ` · Date ${escapeHtml(row.date)}` : '';
          const time = row.time ? ` · Time ${escapeHtml(row.time)}` : '';
          scheduleLinks.push(`Schedule #${idx+1}${round}${date}${time}`);
        }
      });

      const taskLinks = [];
      const taskFields = ['trophyLine','arg1','arg2','arg3','arg4'];
      taskRows.forEach((row, idx)=>{
        const matches = taskFields.filter(field=>normalizeId(row[field]) === normalized);
        if(matches.length){
          const roleLabel = matches.map(field=>field==='trophyLine'?'Trophy Line':field.toUpperCase()).join(', ');
          taskLinks.push(`Task #${idx+1}: ${escapeHtml(row.taskType ?? '')} (${escapeHtml(roleLabel)})`);
        }
      });

      const sections = [];
      const renderSection = (title, items)=>{
        if(!items.length) return '';
        return `<div class="mb-2"><div class="font-medium text-slate-600 dark:text-slate-300">${title}</div><ul class="list-disc list-inside text-slate-600 dark:text-slate-200 space-y-0.5">${items.map(item=>`<li>${item}</li>`).join('')}</ul></div>`;
      };
      sections.push(renderSection('Outgoing advancement', outgoing));
      sections.push(renderSection('Incoming advancement', incoming));
      sections.push(renderSection('Standings slots', standings));
      sections.push(renderSection('Settings', settingsLinks));
      sections.push(renderSection('Schedule rows', scheduleLinks));
      sections.push(renderSection('Tasks', taskLinks));

      const content = sections.filter(Boolean).join('');
      if(!content){
        return `<p class="text-slate-500 dark:text-slate-300">No linked lines reference ID ${escapeHtml(normalized)}.</p>`;
      }
      return content;
    }

    function updateRelationshipPanels(rowId){
      const html = buildRelationshipHtml(rowId);
      if(relationshipsViewer){
        relationshipsViewer.innerHTML = html;
      }
      if(modalRelationships){
        modalRelationships.innerHTML = html;
      }
    }

    function renderHierarchyPreview(){
      if(!hierarchyPreview) return;
      const indexes = getVisibleIndexes(rows, ['id','parent']);
      if(!indexes.length){
        hierarchyPreview.innerHTML = '<p class="text-slate-500 dark:text-slate-300">Load a competition file to view its hierarchy.</p>';
        return;
      }

      const nodes = indexes.map(index=>({index, row: rows[index]}));
      const idToNode = new Map();
      nodes.forEach(node=>{
        const id = normalizeId(node.row.id);
        if(id) idToNode.set(id, node);
      });

      const parentToChildren = new Map();
      nodes.forEach(node=>{
        const parentId = normalizeId(node.row.parent);
        if(!parentToChildren.has(parentId)) parentToChildren.set(parentId, []);
        parentToChildren.get(parentId).push(node);
      });

      parentToChildren.forEach(children=>{
        children.sort((a,b)=>{
          const levelDiff = (Number(a.row.level) || 0) - (Number(b.row.level) || 0);
          if(levelDiff !== 0) return levelDiff;
          const nameDiff = (a.row.name || '').localeCompare(b.row.name || '', undefined, {numeric:true, sensitivity:'base'});
          if(nameDiff !== 0) return nameDiff;
          return normalizeId(a.row.id).localeCompare(normalizeId(b.row.id), undefined, {numeric:true, sensitivity:'base'});
        });
      });

      const roots = [];
      nodes.forEach(node=>{
        const parentId = normalizeId(node.row.parent);
        if(!parentId || !idToNode.has(parentId)){
          roots.push(node);
        }
      });
      if(!roots.length){
        nodes.forEach(node=>{
          if(getRowTypeFromLevel(node.row.level) === 'competition'){
            roots.push(node);
          }
        });
      }

      if(!roots.length){
        hierarchyPreview.innerHTML = '<p class="text-slate-500 dark:text-slate-300">No hierarchical data available.</p>';
        return;
      }

      const visited = new Set();
      const rootList = document.createElement('ul');
      rootList.className = 'space-y-1 text-slate-700 dark:text-slate-200 text-sm';

      function renderNode(node, container){
        const nodeId = normalizeId(node.row.id) || `__${node.index}`;
        if(visited.has(nodeId)) return;
        visited.add(nodeId);
        const li = document.createElement('li');
        const wrapper = document.createElement('div');
        const type = getRowTypeFromLevel(node.row.level);
        const isSelected = node.index === selectedRowIndex;
        wrapper.className = `flex items-center gap-2 ${isSelected ? 'text-indigo-600 dark:text-indigo-300 font-semibold' : ''}`;
        const dot = document.createElement('span');
        dot.className = `inline-block h-2.5 w-2.5 rounded-full ${typeDotClass(type)}`;
        wrapper.appendChild(dot);
        const label = document.createElement('span');
        label.innerHTML = describeRowLabel(node.row);
        wrapper.appendChild(label);
        li.appendChild(wrapper);

        const children = parentToChildren.get(normalizeId(node.row.id)) || [];
        if(children.length){
          const ul = document.createElement('ul');
          ul.className = 'ml-4 border-l border-slate-200 dark:border-slate-700 pl-3 space-y-1 mt-1';
          children.forEach(child=>renderNode(child, ul));
          li.appendChild(ul);
        }
        container.appendChild(li);
      }

      roots.forEach(root=>renderNode(root, rootList));
      hierarchyPreview.innerHTML = '';
      hierarchyPreview.appendChild(rootList);
    }

    function getRowIndexById(id){
      const target = normalizeId(id);
      if(!target) return -1;
      for(let i=0;i<rows.length;i+=1){
        if(normalizeId(rows[i].id) === target) return i;
      }
      return -1;
    }

    function setSelectedRow(index, {openEditor=false} = {}){
      selectedRowIndex = index;
      renderTable();
      if(openEditor && index>=0 && index<rows.length){
        openRowEditor(index);
      } else if(index<0){
        updateRelationshipPanels();
        closeRowEditor();
      }
    }

    function selectRowById(id, options={}){
      const index = getRowIndexById(id);
      if(index>=0){
        setSelectedRow(index, options);
      }
    }

    function closeRowEditor(){
      if(rowEditorModal && !rowEditorModal.classList.contains('hidden')){
        rowEditorModal.classList.add('hidden');
      }
    }

    function openRowEditor(index){
      if(!rowEditorModal) return;
      const row = rows[index];
      if(!row){
        closeRowEditor();
        return;
      }
      const rowType = getRowTypeFromLevel(row.level);
      if(rowTypeSelect){
        const validTypes = ['competition','stage','group'];
        rowTypeSelect.value = validTypes.includes(rowType) ? rowType : 'competition';
      }
      ensureStageSubtypeVisibility(rowTypeSelect ? rowTypeSelect.value : 'competition');
      if(stageSubtypeSelect){
        stageSubtypeSelect.value = rowType === 'stage' ? deriveStageSubtype(row.code ?? '') : 'custom';
      }
      if(rowCodeInput) rowCodeInput.value = row.code ?? '';
      if(rowNameInput) rowNameInput.value = row.name ?? '';
      if(rowParentInput) rowParentInput.value = row.parent ?? '';
      rowEditorModal.classList.remove('hidden');
      updateRelationshipPanels(row.id);
    }

    function setMessage(text){
      if(!messagesEl) return;
      messagesEl.textContent = text || '';
    }

    function generateNextId(){
      const usedIds = new Set();
      let maxNumeric = 0;
      rows.forEach(row=>{
        const norm = normalizeId(row.id);
        if(!norm) return;
        usedIds.add(norm);
        const num = Number(norm);
        if(Number.isFinite(num) && num > maxNumeric){
          maxNumeric = num;
        }
      });
      let candidate = maxNumeric + 1;
      if(candidate < 1) candidate = 1;
      while(usedIds.has(String(candidate))){
        candidate += 1;
      }
      return String(candidate);
    }

    function countSiblings(parentId, level){
      const normParent = normalizeId(parentId);
      const levelNorm = normalizeId(level);
      let count = 0;
      rows.forEach(row=>{
        if(normalizeId(row.parent) === normParent && normalizeId(row.level) === levelNorm){
          count += 1;
        }
      });
      return count;
    }

    function determineCompetitionContext(){
      if(selectedRowIndex>=0){
        const selected = rows[selectedRowIndex];
        const type = getRowTypeFromLevel(selected?.level);
        if(type === 'competition') return normalizeId(selected.id);
        if(type === 'stage') return normalizeId(selected.parent);
        if(type === 'group'){
          const stageIdx = getRowIndexById(selected.parent);
          if(stageIdx>=0){
            const stageRow = rows[stageIdx];
            if(getRowTypeFromLevel(stageRow.level) === 'stage'){
              return normalizeId(stageRow.parent);
            }
          }
        }
      }
      if(activeCompetitionId) return normalizeId(activeCompetitionId);
      const firstComp = rows.find(row=>getRowTypeFromLevel(row.level) === 'competition');
      return firstComp ? normalizeId(firstComp.id) : '';
    }

    function determineStageContext(){
      if(selectedRowIndex>=0){
        const selected = rows[selectedRowIndex];
        const type = getRowTypeFromLevel(selected?.level);
        if(type === 'stage') return normalizeId(selected.id);
        if(type === 'group') return normalizeId(selected.parent);
      }
      const compId = determineCompetitionContext();
      if(compId){
        const stageRow = rows.find(row=>normalizeId(row.parent) === compId && getRowTypeFromLevel(row.level) === 'stage');
        if(stageRow) return normalizeId(stageRow.id);
      }
      return '';
    }

    function createStageRow(parentId){
      const siblingCount = countSiblings(parentId, '4') + 1;
      const suffix = String(siblingCount).padStart(2,'0');
      const defaultSubtype = stageSubtypeTokens[0]?.value || 'LEAGUE';
      return {
        id: generateNextId(),
        level: '4',
        code: `${defaultSubtype}_${suffix}`,
        name: `New Stage ${siblingCount}`,
        parent: normalizeId(parentId)
      };
    }

    function createGroupRow(stageId){
      const siblingCount = countSiblings(stageId, '5') + 1;
      const suffix = String(siblingCount).padStart(2,'0');
      return {
        id: generateNextId(),
        level: '5',
        code: `GROUP_${suffix}`,
        name: `Group ${siblingCount}`,
        parent: normalizeId(stageId)
      };
    }

    function serializeCompRow(row){
      const delim = compDelimiter || ',';
      return [row.id ?? '', row.level ?? '', row.code ?? '', row.name ?? '', row.parent ?? ''].join(delim);
    }

    function updateCompRawLine(index){
      if(index<0 || index>=compRawLines.length) return;
      compRawLines[index] = serializeCompRow(rows[index] ?? {});
    }

    function recomputeActiveScope(){
      if(!activeCompetitionId){
        activeScopeIds = null;
        return;
      }
      const target = normalizeId(activeCompetitionId);
      if(!target){
        activeScopeIds = null;
        return;
      }
      const adjacency = new Map();
      rows.forEach(row=>{
        const parent = normalizeId(row.parent);
        const child = normalizeId(row.id);
        if(!adjacency.has(parent)) adjacency.set(parent, []);
        adjacency.get(parent).push(child);
      });
      const scope = new Set([target]);
      const stack=[target];
      while(stack.length){
        const current = stack.pop();
        const children = adjacency.get(current) || [];
        children.forEach(child=>{
          if(child && !scope.has(child)){
            scope.add(child);
            stack.push(child);
          }
        });
      }
      activeScopeIds = scope;
    }

    function updateCompetitionSummary(){
      if(!competitionSummary) return;
      if(!activeCompetitionId){
        competitionSummary.textContent = '';
        return;
      }
      const scopeCount = activeScopeIds ? activeScopeIds.size : 0;
      competitionSummary.textContent = scopeCount ? `Active scope contains ${scopeCount} linked IDs` : '';
    }

    function setActiveCompetition(id){
      activeCompetitionId = normalizeId(id);
      recomputeActiveScope();
      updateCompetitionSummary();
      renderTable();
      renderAdvTable();
      renderStandingsTable();
      renderSettingsTable();
      renderScheduleTable();
      renderTaskTable();
      renderWeatherTable();
    }

    if(competitionSelect){
      competitionSelect.onchange = ()=>{
        setActiveCompetition(competitionSelect.value);
      };
    }

    function refreshCompetitionOptions(){
      if(!competitionSelect) return;
      const existingValue = activeCompetitionId || competitionSelect.value;
      const options = rows
        .filter(row=>normalizeId(row.level)==='3' && normalizeId(row.code).toUpperCase().startsWith('C') && normalizeId(row.id))
        .map(row=>({
          id: normalizeId(row.id),
          label: `${normalizeId(row.code) || 'C?'} — ${row.name ? row.name.trim() : ''}`.trim().replace(/\s+/g,' ')
        }));
      options.sort((a,b)=>a.label.localeCompare(b.label, undefined, {numeric:true, sensitivity:'base'}));
      competitionSelect.innerHTML = '<option value="">All competitions</option>';
      const fragment = document.createDocumentFragment();
      options.forEach(opt=>{
        const optionEl = document.createElement('option');
        optionEl.value = opt.id;
        optionEl.textContent = opt.label || opt.id;
        fragment.appendChild(optionEl);
      });
      competitionSelect.appendChild(fragment);
      const restored = options.find(opt=>opt.id===existingValue) ? existingValue : '';
      competitionSelect.value = restored;
      setActiveCompetition(restored);
    }

    function parseText(text, delimSel='auto') {
      rows = [];
      compRawLines = [];
      const delim = (delimSel==='auto') ? autoDetectDelimiter(text) : delimSel;
      compDelimiter = delim;
      const rawLines = text.split(/\r?\n/);
      for (const rawLine of rawLines) {
        if(!rawLine || !rawLine.trim()) continue;
        const parts = rawLine.split(delim);
        while (parts.length < 5) parts.push('');
        const trimmed = parts.map(p=>p.trim());
        const [id, level, code, name, parent] = trimmed;
        rows.push({ id, level, code, name, parent });
        compRawLines.push(rawLine);
      }
      document.getElementById('meta').textContent = `${rows.length} lines parsed`;
      refreshCompetitionOptions();
    }

    function renderTable(){
      tbody.innerHTML = '';
      const indexes = getVisibleIndexes(rows, ['id','parent']);
      indexes.forEach((rowIndex,pos)=>{
        const r = rows[rowIndex];
        const rowType = getRowTypeFromLevel(r.level);
        const highlightClass = levelClassFromType(rowType);
        const isSelected = rowIndex === selectedRowIndex;
        const baseTint = pos%2 ? 'bg-white dark:bg-slate-800/40' : 'bg-slate-50 dark:bg-slate-800/60';
        const tr = document.createElement('tr');
        tr.dataset.index = rowIndex;
        tr.dataset.level = normalizeId(r.level);
        tr.className = `border-b border-slate-100 dark:border-slate-700 cursor-pointer transition-colors hover:bg-indigo-50 dark:hover:bg-slate-700/60 ${highlightClass || baseTint}`;
        if(isSelected) tr.classList.add('level-selected');
        tr.innerHTML = `
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="id" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.id ?? ''}"></td>
          <td class="p-2"><input data-f="level" data-i="${rowIndex}" class="w-12 p-1 border rounded" value="${r.level ?? ''}"></td>
          <td class="p-2"><input data-f="code" data-i="${rowIndex}" class="w-32 p-1 border rounded" value="${r.code ?? ''}"></td>
          <td class="p-2"><input data-f="name" data-i="${rowIndex}" class="w-56 p-1 border rounded" value="${r.name ?? ''}"></td>
          <td class="p-2"><input data-f="parent" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.parent ?? ''}"></td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        tbody.appendChild(tr);

        tr.addEventListener('click', evt=>{
          if(evt.target.closest('button')) return;
          if(evt.target.tagName === 'INPUT' || evt.target.closest('input')) return;
          setSelectedRow(rowIndex, { openEditor: true });
        });
      });

      tbody.querySelectorAll('input').forEach(inp=>{
        inp.addEventListener('click', evt=>evt.stopPropagation());
        inp.onfocus = ()=>{ inp.dataset.prev = inp.value; };
        inp.onchange = ()=>{
          const rowIndex = +inp.dataset.i;
          const field = inp.dataset.f;
          const newValue = inp.value;
          const prevValue = inp.dataset.prev ?? '';
          rows[rowIndex][field] = newValue;
          updateCompRawLine(rowIndex);
          if(field === 'id'){
            const normalizedPrev = String(prevValue).trim();
            const normalizedNew = String(newValue).trim();
            if(normalizedPrev && normalizedPrev !== normalizedNew){
              const mapping = {};
              mapping[normalizedPrev] = normalizedNew;
              applyGlobalIdMapping(mapping);
            } else {
              refreshCompetitionOptions();
            }
          } else if(field === 'parent' || field === 'level' || field === 'code' || field === 'name'){
            refreshCompetitionOptions();
          }
          inp.dataset.prev = newValue;
          if(field === 'level' || field === 'id'){
            renderTable();
          } else {
            renderHierarchyPreview();
            updateRelationshipPanels(rows[selectedRowIndex]?.id);
          }
          if(activeCompetitionId){
            recomputeActiveScope();
            updateCompetitionSummary();
            renderAdvTable();
            renderStandingsTable();
            renderSettingsTable();
            renderScheduleTable();
            renderTaskTable();
            renderWeatherTable();
          }
        };
      });
      tbody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.addEventListener('click', evt=>evt.stopPropagation());
        btn.onclick = ()=>{
          const idx = +btn.dataset.del;
          rows.splice(idx,1);
          compRawLines.splice(idx,1);
          if(selectedRowIndex === idx){
            closeRowEditor();
            selectedRowIndex = -1;
          } else if(selectedRowIndex > idx){
            selectedRowIndex -= 1;
          }
          refreshCompetitionOptions();
        };
      });

      renderHierarchyPreview();
      updateRelationshipPanels(rows[selectedRowIndex]?.id);
    }

    document.getElementById('fileInput').onchange = e=>{
      const f = e.target.files[0]; if(!f) return;
      const reader = new FileReader();
      reader.onload = ()=>parseText(reader.result, document.getElementById('delimiter').value);
      reader.readAsText(f);
    };

    document.getElementById('pasteBtn').onclick = ()=>{
      const pa=document.getElementById('pasteArea');
      pa.classList.toggle('hidden');
      if(!pa.classList.contains('hidden')) pa.focus();
    };
    document.getElementById('pasteArea').onblur = e=>parseText(e.target.value, document.getElementById('delimiter').value);

    document.getElementById('addLineBtn').onclick = ()=>{
      const newRow = {id:'',level:'',code:'',name:'',parent:''};
      rows.push(newRow);
      compRawLines.push(serializeCompRow(newRow));
      setMessage('Blank line added. Use the editor to configure it.');
      refreshCompetitionOptions();
      setSelectedRow(rows.length-1, { openEditor: true });
    };

    document.getElementById('addStageBtn').onclick = ()=>{
      const compId = determineCompetitionContext();
      if(!compId){
        setMessage('Select or activate a competition before adding a stage.');
        return;
      }
      const newRow = createStageRow(compId);
      rows.push(newRow);
      compRawLines.push(serializeCompRow(newRow));
      setMessage(`Stage ${newRow.name} added under competition ${compId}.`);
      refreshCompetitionOptions();
      selectRowById(newRow.id, { openEditor: true });
    };

    document.getElementById('addGroupBtn').onclick = ()=>{
      const stageId = determineStageContext();
      if(!stageId){
        setMessage('Select a stage before adding a group.');
        return;
      }
      const newRow = createGroupRow(stageId);
      rows.push(newRow);
      compRawLines.push(serializeCompRow(newRow));
      setMessage(`Group ${newRow.name} added under stage ${stageId}.`);
      refreshCompetitionOptions();
      selectRowById(newRow.id, { openEditor: true });
    };

    document.getElementById('exportBtn').onclick = ()=>{
      const blob = new Blob([compRawLines.join('\n')], {type:'text/plain'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='compobj_modified.txt'; a.click();
    };

    document.getElementById('rebaseBtn').onclick = ()=>{
      let start = Number(document.getElementById('rebaseStart').value);
      if(!Number.isFinite(start)) start = 1;
      const mapping = {};
      let nextId = start;
      rows.forEach(row=>{
        const oldId = String(row.id ?? '').trim();
        if(!oldId) return;
        const newId = String(nextId++);
        if(oldId !== newId){
          mapping[oldId] = newId;
        }
      });
      if(Object.keys(mapping).length){
        applyGlobalIdMapping(mapping);
      } else {
        document.getElementById('messages').textContent = 'Rebase skipped — IDs already aligned with the requested range.';
      }
    };

    document.getElementById('sortByIdBtn').onclick = ()=>{
      const selectedId = (selectedRowIndex>=0 && rows[selectedRowIndex]) ? normalizeId(rows[selectedRowIndex].id) : '';
      const combined = rows.map((row,idx)=>({row, raw: compRawLines[idx]}));
      combined.sort((a,b)=>Number(a.row.id||0)-Number(b.row.id||0));
      rows = combined.map(item=>item.row);
      compRawLines = combined.map(item=>item.raw);
      if(selectedId){
        selectedRowIndex = getRowIndexById(selectedId);
      }
      refreshCompetitionOptions();
    };

    document.getElementById('validateBtn').onclick = ()=>{
      const ids=new Set(rows.map(r=>String(r.id)));
      const probs=[];
      rows.forEach((r,i)=>{
        if(!r.id) probs.push(`Line ${i+1}: Missing ID`);
        if(r.parent && !ids.has(String(r.parent))) probs.push(`Line ${i+1}: Parent ${r.parent} not found`);
      });
      document.getElementById('messages').innerHTML = probs.length ? probs.join('<br>') : 'No validation issues.';
    };

    if(rowEditorCancel) rowEditorCancel.onclick = ()=>closeRowEditor();
    if(rowEditorClose) rowEditorClose.onclick = ()=>closeRowEditor();
    if(rowEditorModal){
      rowEditorModal.addEventListener('click', evt=>{
        if(evt.target === rowEditorModal) closeRowEditor();
      });
    }
    document.addEventListener('keydown', evt=>{
      if(evt.key === 'Escape') closeRowEditor();
    });

    if(rowTypeSelect){
      rowTypeSelect.onchange = ()=>{
        const type = rowTypeSelect.value;
        ensureStageSubtypeVisibility(type);
        if(type === 'stage' && stageSubtypeSelect){
          if(stageSubtypeSelect.value === 'custom'){
            stageSubtypeSelect.value = stageSubtypeTokens[0]?.value || 'LEAGUE';
            rowCodeInput.value = mergeStageSubtypeWithCode(stageSubtypeSelect.value, rowCodeInput.value);
          }
        } else if(stageSubtypeSelect){
          stageSubtypeSelect.value = 'custom';
        }
      };
    }

    if(stageSubtypeSelect){
      stageSubtypeSelect.onchange = ()=>{
        if(stageSubtypeSelect.value === 'custom') return;
        rowCodeInput.value = mergeStageSubtypeWithCode(stageSubtypeSelect.value, rowCodeInput.value);
      };
    }

    if(rowEditorSave){
      rowEditorSave.onclick = ()=>{
        if(selectedRowIndex < 0 || selectedRowIndex >= rows.length){
          closeRowEditor();
          return;
        }
        const row = rows[selectedRowIndex];
        if(!row){
          closeRowEditor();
          return;
        }
        const type = rowTypeSelect ? rowTypeSelect.value : getRowTypeFromLevel(row.level);
        row.level = getLevelFromType(type) || row.level;
        const codeInputValue = rowCodeInput ? rowCodeInput.value : row.code;
        if(type === 'stage' && stageSubtypeSelect){
          const subtypeValue = stageSubtypeSelect.value;
          row.code = subtypeValue === 'custom' ? codeInputValue : mergeStageSubtypeWithCode(subtypeValue, codeInputValue);
        } else {
          row.code = codeInputValue;
        }
        if(rowNameInput) row.name = rowNameInput.value;
        if(rowParentInput) row.parent = rowParentInput.value;
        updateCompRawLine(selectedRowIndex);
        refreshCompetitionOptions();
        setMessage(`Line ${row.id || selectedRowIndex+1} updated.`);
        closeRowEditor();
      };
    }

    ensureStageSubtypeVisibility(rowTypeSelect ? rowTypeSelect.value : 'competition');

    /* -----------------------
       Advancement Section
    ----------------------- */
    let advRows = [];
    let advRawLines = [];
    const advBody = document.getElementById('advBody');

    function serializeAdvRow(row){
      return [row.fromId ?? '', row.qualifier ?? '', row.toId ?? '', row.slot ?? ''].join(',');
    }

    function updateAdvRawLine(index){
      if(index<0 || index>=advRawLines.length) return;
      advRawLines[index] = serializeAdvRow(advRows[index] ?? {});
    }

    function parseAdv(text){
      advRows = [];
      advRawLines = [];
      const rawLines=text.split(/\r?\n/);
      for(const rawLine of rawLines){
        if(!rawLine || !rawLine.trim()) continue;
        const parts = rawLine.split(',');
        while(parts.length<4) parts.push('');
        const [fromId, qualifier, toId, slot] = parts.map(s=>s.trim());
        advRows.push({fromId,qualifier,toId,slot});
        advRawLines.push(rawLine);
      }
      document.getElementById('advMeta').textContent=`${advRows.length} advancement lines parsed`;
      renderAdvTable();
    }

    function renderAdvTable(){
      advBody.innerHTML='';
      const indexes = getVisibleIndexes(advRows, ['fromId','toId']);
      indexes.forEach((rowIndex,pos)=>{
        const r = advRows[rowIndex];
        const tr=document.createElement('tr');
        tr.className=pos%2?'bg-white':'bg-slate-50';
        tr.innerHTML=`
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="fromId" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.fromId}"></td>
          <td class="p-2"><input data-f="qualifier" data-i="${rowIndex}" class="w-16 p-1 border rounded" value="${r.qualifier}"></td>
          <td class="p-2"><input data-f="toId" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.toId}"></td>
          <td class="p-2"><input data-f="slot" data-i="${rowIndex}" class="w-16 p-1 border rounded" value="${r.slot}"></td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        advBody.appendChild(tr);
      });
      advBody.querySelectorAll('input').forEach(inp=>{
        inp.onchange=()=>{
          const idx = +inp.dataset.i;
          advRows[idx][inp.dataset.f]=inp.value;
          updateAdvRawLine(idx);
        };
      });
      advBody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.onclick=()=>{
          const idx = +btn.dataset.del;
          advRows.splice(idx,1);
          advRawLines.splice(idx,1);
          renderAdvTable();
        };
      });
      updateRelationshipPanels(rows[selectedRowIndex]?.id);
    }

    document.getElementById('advFileInput').onchange=e=>{
      const f=e.target.files[0]; if(!f) return;
      const r=new FileReader();
      r.onload=()=>parseAdv(r.result);
      r.readAsText(f);
    };

    document.getElementById('advPasteBtn').onclick=()=>{
      const pa=document.getElementById('advPasteArea');
      pa.classList.toggle('hidden');
      if(!pa.classList.contains('hidden')) pa.focus();
    };
    document.getElementById('advPasteArea').onblur=e=>parseAdv(e.target.value);

    document.getElementById('advAddBtn').onclick=()=>{
      advRows.push({fromId:'',qualifier:'',toId:'',slot:''});
      advRawLines.push(serializeAdvRow(advRows[advRows.length-1]));
      renderAdvTable();
    };

    document.getElementById('advSortBtn').onclick=()=>{
      const combined = advRows.map((row,idx)=>({row, raw: advRawLines[idx]}));
      combined.sort((a,b)=>Number(a.row.fromId||0)-Number(b.row.fromId||0));
      advRows = combined.map(item=>item.row);
      advRawLines = combined.map(item=>item.raw);
      renderAdvTable();
    };

    document.getElementById('advExportBtn').onclick=()=>{
      const blob=new Blob([advRawLines.join('\n')],{type:'text/plain'});
      const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='advancement.txt';a.click();
    };

    document.getElementById('advValidateBtn').onclick=()=>{
      const ids=new Set(rows.map(r=>String(r.id)));
      const missing=advRows.filter(r=>!ids.has(String(r.fromId))||!ids.has(String(r.toId)));
      const msg=missing.length?`${missing.length} advancement lines reference missing group IDs`:'All advancement links valid.';
      document.getElementById('advMessages').textContent=msg;
    };

    /* -----------------------
       Standings Section
    ----------------------- */
    let standingsRows=[];
    let standingsRawLines=[];
    let standingsDelimiter=',';
    const standingsBody=document.getElementById('standingsBody');

    function updateStandingsMeta(){
      const groupCounts=new Map();
      standingsRows.forEach(r=>{
        if(!r.groupId) return;
        const slotNum=r.slot===''?NaN:Number(r.slot);
        if(!groupCounts.has(r.groupId)) groupCounts.set(r.groupId, Number.isFinite(slotNum)?slotNum+1:1);
        else if(Number.isFinite(slotNum)) groupCounts.set(r.groupId, Math.max(groupCounts.get(r.groupId), slotNum+1));
        else groupCounts.set(r.groupId, groupCounts.get(r.groupId)+1);
      });
      const groupCount=groupCounts.size;
      let maxTeams=0;
      groupCounts.forEach(v=>{if(v>maxTeams) maxTeams=v;});
      const meta=`${standingsRows.length} rows parsed${groupCount?` across ${groupCount} groups`:''}${maxTeams?`. Largest table size: ${maxTeams} teams.`:''}`;
      document.getElementById('standingsMeta').textContent=meta;
    }

    function serializeStandingsRow(row){
      return [row.groupId ?? '', row.slot ?? ''].join(standingsDelimiter || ',');
    }

    function updateStandingsRawLine(index){
      if(index<0 || index>=standingsRawLines.length) return;
      standingsRawLines[index] = serializeStandingsRow(standingsRows[index] ?? {});
    }

    function renderStandingsTable(){
      standingsBody.innerHTML='';
      const indexes = getVisibleIndexes(standingsRows, ['groupId']);
      indexes.forEach((rowIndex,pos)=>{
        const r=standingsRows[rowIndex];
        const tr=document.createElement('tr');
        tr.className=pos%2?'bg-white':'bg-slate-50';
        const slotNum=r.slot===''?NaN:Number(r.slot);
        const teamLabel=Number.isFinite(slotNum)?`Team ${slotNum+1}`:'';
        tr.innerHTML=`
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="groupId" data-i="${rowIndex}" class="w-28 p-1 border rounded" value="${r.groupId}"></td>
          <td class="p-2"><input data-f="slot" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.slot}"></td>
          <td class="p-2 text-slate-600">${teamLabel}</td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        standingsBody.appendChild(tr);
      });
      standingsBody.querySelectorAll('input').forEach(inp=>{
        inp.onchange=()=>{
          const idx = +inp.dataset.i;
          standingsRows[idx][inp.dataset.f]=inp.value;
          updateStandingsRawLine(idx);
          updateStandingsMeta();
        };
      });
      standingsBody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.onclick=()=>{
          const idx = +btn.dataset.del;
          standingsRows.splice(idx,1);
          standingsRawLines.splice(idx,1);
          renderStandingsTable();
        };
      });
      updateStandingsMeta();
      updateRelationshipPanels(rows[selectedRowIndex]?.id);
    }

    function parseStandings(text){
      standingsRows=[];
      standingsRawLines=[];
      const delim=autoDetectDelimiter(text);
      standingsDelimiter=delim;
      const rawLines=text.split(/\r?\n/);
      for(const rawLine of rawLines){
        if(!rawLine || !rawLine.trim()) continue;
        const parts=rawLine.split(delim);
        if(!parts.length) continue;
        const trimmedParts = parts.map(s=>s.trim());
        if(!trimmedParts[0]) continue;
        const [groupId, slot=''] = trimmedParts;
        standingsRows.push({groupId, slot});
        standingsRawLines.push(rawLine);
      }
      renderStandingsTable();
    }

    document.getElementById('standingsFileInput').onchange=e=>{
      const f=e.target.files[0]; if(!f) return;
      const r=new FileReader();
      r.onload=()=>parseStandings(r.result);
      r.readAsText(f);
    };

    document.getElementById('standingsPasteBtn').onclick=()=>{
      const pa=document.getElementById('standingsPasteArea');
      pa.classList.toggle('hidden');
      if(!pa.classList.contains('hidden')) pa.focus();
    };
    document.getElementById('standingsPasteArea').onblur=e=>parseStandings(e.target.value);

    document.getElementById('standingsAddBtn').onclick=()=>{
      standingsRows.push({groupId:'',slot:''});
      standingsRawLines.push(serializeStandingsRow(standingsRows[standingsRows.length-1]));
      renderStandingsTable();
    };

    document.getElementById('standingsSortBtn').onclick=()=>{
      const combined = standingsRows.map((row,idx)=>({row, raw: standingsRawLines[idx]}));
      combined.sort((a,b)=>{
        const aRow=a.row;
        const bRow=b.row;
        const gDiff=Number(aRow.groupId||0)-Number(bRow.groupId||0);
        if(gDiff!==0) return gDiff;
        const slotA=aRow.slot===''?Number.POSITIVE_INFINITY:Number(aRow.slot);
        const slotB=bRow.slot===''?Number.POSITIVE_INFINITY:Number(bRow.slot);
        return slotA-slotB;
      });
      standingsRows = combined.map(item=>item.row);
      standingsRawLines = combined.map(item=>item.raw);
      renderStandingsTable();
    };

    document.getElementById('standingsExportBtn').onclick=()=>{
      const blob=new Blob([standingsRawLines.join('\n')],{type:'text/plain'});
      const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='standings.txt';a.click();
    };

    document.getElementById('standingsValidateBtn').onclick=()=>{
      const msgs=[];
      const seen=new Set();
      const groupSlots=new Map();
      standingsRows.forEach((r,i)=>{
        if(!r.groupId) msgs.push(`Row ${i+1}: Missing group ID`);
        if(r.slot==='') msgs.push(`Row ${i+1}: Missing slot value`);
        const slotNum=Number(r.slot);
        if(r.slot!=='' && Number.isNaN(slotNum)) msgs.push(`Row ${i+1}: Slot is not a number`);
        const key=`${r.groupId}|${r.slot}`;
        if(seen.has(key)) msgs.push(`Row ${i+1}: Duplicate group/slot combination (${r.groupId}, ${r.slot})`);
        seen.add(key);
        if(r.groupId){
          if(!groupSlots.has(r.groupId)) groupSlots.set(r.groupId,new Set());
          if(!Number.isNaN(slotNum)) groupSlots.get(r.groupId).add(slotNum);
        }
      });
      groupSlots.forEach((slots,gid)=>{
        if(!slots.has(0)) msgs.push(`Group ${gid} is missing slot 0`);
      });
      document.getElementById('standingsMessages').innerHTML = msgs.length ? msgs.join('<br>') : 'No validation issues.';
    };

    /* -----------------------
       Settings Section
    ----------------------- */
    let settingRows = [];
    let settingsRawLines = [];
    const settingsBody=document.getElementById('settingsBody');

    function updateSettingsMeta(){
      document.getElementById('settingsMeta').textContent=`${settingRows.length} setting line${settingRows.length===1?'':'s'} parsed`;
    }

    function serializeSettingRow(row){
      return [row.id ?? '', row.key ?? '', row.value ?? ''].join(',');
    }

    function updateSettingsRawLine(index){
      if(index<0 || index>=settingsRawLines.length) return;
      settingsRawLines[index] = serializeSettingRow(settingRows[index] ?? {});
    }

    function renderSettingsTable(){
      settingsBody.innerHTML='';
      const indexes = getVisibleIndexes(settingRows, ['id']);
      indexes.forEach((rowIndex,pos)=>{
        const r=settingRows[rowIndex];
        const tr=document.createElement('tr');
        tr.className=pos%2?'bg-white':'bg-slate-50';
        tr.innerHTML=`
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="id" data-i="${rowIndex}" class="w-28 p-1 border rounded" value="${r.id ?? ''}"></td>
          <td class="p-2"><input data-f="key" data-i="${rowIndex}" class="w-40 p-1 border rounded" value="${r.key ?? ''}"></td>
          <td class="p-2"><input data-f="value" data-i="${rowIndex}" class="w-48 p-1 border rounded" value="${r.value ?? ''}"></td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        settingsBody.appendChild(tr);
      });
      settingsBody.querySelectorAll('input').forEach(inp=>{
        inp.onchange=()=>{
          const idx = +inp.dataset.i;
          settingRows[idx][inp.dataset.f]=inp.value;
          updateSettingsRawLine(idx);
          updateSettingsMeta();
        };
      });
      settingsBody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.onclick=()=>{
          const idx = +btn.dataset.del;
          settingRows.splice(idx,1);
          settingsRawLines.splice(idx,1);
          renderSettingsTable();
        };
      });
      updateSettingsMeta();
      updateRelationshipPanels(rows[selectedRowIndex]?.id);
    }

    function parseSettings(text){
      settingRows=[];
      settingsRawLines=[];
      const rawLines=text.split(/\r?\n/);
      for(const rawLine of rawLines){
        if(!rawLine || !rawLine.trim()) continue;
        const parts=rawLine.split(',');
        while(parts.length<3) parts.push('');
        const trimmedParts = parts.map(s=>s.trim());
        const [id='', key='', value=''] = trimmedParts;
        if(id || key || value){
          settingRows.push({id, key, value});
          settingsRawLines.push(rawLine);
        }
      }
      renderSettingsTable();
    }

    document.getElementById('settingsFileInput').onchange=e=>{
      const f=e.target.files[0]; if(!f) return;
      const r=new FileReader();
      r.onload=()=>parseSettings(r.result);
      r.readAsText(f);
    };

    document.getElementById('settingsPasteBtn').onclick=()=>{
      const pa=document.getElementById('settingsPasteArea');
      pa.classList.toggle('hidden');
      if(!pa.classList.contains('hidden')) pa.focus();
    };
    document.getElementById('settingsPasteArea').onblur=e=>parseSettings(e.target.value);

    document.getElementById('settingsAddBtn').onclick=()=>{
      const newRow={id:'',key:'',value:''};
      settingRows.push(newRow);
      settingsRawLines.push(serializeSettingRow(newRow));
      renderSettingsTable();
    };

    document.getElementById('settingsExportBtn').onclick=()=>{
      const blob=new Blob([settingsRawLines.join('\n')],{type:'text/plain'});
      const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='settings.txt';a.click();
    };

    document.getElementById('settingsValidateBtn').onclick=()=>{
      const probs=[];
      const ids=new Set(rows.map(r=>String(r.id)));
      settingRows.forEach((r,i)=>{
        if(!r.id) probs.push(`Row ${i+1}: Missing CompObj ID`);
        else if(!ids.has(String(r.id))) probs.push(`Row ${i+1}: CompObj ID ${r.id} not found in CompObj table`);
        if(!r.key) probs.push(`Row ${i+1}: Missing Setting Key`);
        if(!r.value) probs.push(`Row ${i+1}: Missing Setting Value`);
      });
      document.getElementById('settingsMessages').innerHTML = probs.length ? probs.join('<br>') : 'No validation issues.';
    };

    updateSettingsMeta();

    /* -----------------------
       Schedule Section
    ----------------------- */
    let scheduleRows = [];
    let scheduleRawLines = [];
    const scheduleBody = document.getElementById('scheduleBody');
    const scheduleMetaEl = document.getElementById('scheduleMeta');
    const scheduleMessagesEl = document.getElementById('scheduleMessages');

    function updateScheduleMeta(){
      if(scheduleMetaEl){
        scheduleMetaEl.textContent = `${scheduleRows.length} lines parsed`;
      }
    }

    function serializeScheduleRow(row){
      return [row.stage ?? '',row.date ?? '',row.round ?? '',row.min ?? '',row.max ?? '',row.time ?? ''].join(',');
    }

    function updateScheduleRawLine(index){
      if(index<0 || index>=scheduleRawLines.length) return;
      scheduleRawLines[index] = serializeScheduleRow(scheduleRows[index] ?? {});
    }

    function renderScheduleTable(){
      scheduleBody.innerHTML='';
      const indexes = getVisibleIndexes(scheduleRows, ['stage']);
      indexes.forEach((rowIndex,pos)=>{
        const r=scheduleRows[rowIndex];
        const tr=document.createElement('tr');
        tr.className=pos%2?'bg-white':'bg-slate-50';
        tr.innerHTML=`
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="stage" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.stage ?? ''}"></td>
          <td class="p-2"><input data-f="date" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.date ?? ''}"></td>
          <td class="p-2"><input data-f="round" data-i="${rowIndex}" class="w-20 p-1 border rounded" value="${r.round ?? ''}"></td>
          <td class="p-2"><input data-f="min" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.min ?? ''}"></td>
          <td class="p-2"><input data-f="max" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.max ?? ''}"></td>
          <td class="p-2"><input data-f="time" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.time ?? ''}"></td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        scheduleBody.appendChild(tr);
      });
      scheduleBody.querySelectorAll('input').forEach(inp=>{
        inp.onchange=()=>{
          const idx = +inp.dataset.i;
          scheduleRows[idx][inp.dataset.f]=inp.value;
          updateScheduleRawLine(idx);
        };
      });
      scheduleBody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.onclick=()=>{
          const idx = +btn.dataset.del;
          scheduleRows.splice(idx,1);
          scheduleRawLines.splice(idx,1);
          renderScheduleTable();
        };
      });
      updateScheduleMeta();
      updateRelationshipPanels(rows[selectedRowIndex]?.id);
    }

    function parseSchedule(text){
      scheduleRows=[];
      scheduleRawLines=[];
      const lines=text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      for(const line of lines){
        const parts=line.split(',').map(s=>s.trim());
        while(parts.length<6) parts.push('');
        const [stage='',date='',round='',min='',max='',time='']=parts;
        scheduleRows.push({stage,date,round,min,max,time});
        scheduleRawLines.push(line);
      }
      renderScheduleTable();
      if(scheduleMessagesEl){
        scheduleMessagesEl.textContent='';
      }
    }

    document.getElementById('scheduleFileInput').onchange=e=>{
      const f=e.target.files[0]; if(!f) return;
      const reader=new FileReader();
      reader.onload=()=>parseSchedule(reader.result);
      reader.readAsText(f);
    };

    document.getElementById('schedulePasteBtn').onclick=()=>{
      const pa=document.getElementById('schedulePasteArea');
      pa.classList.toggle('hidden');
      if(!pa.classList.contains('hidden')) pa.focus();
    };
    document.getElementById('schedulePasteArea').onblur=e=>parseSchedule(e.target.value);

    document.getElementById('scheduleAddBtn').onclick=()=>{
      scheduleRows.push({stage:'',date:'',round:'',min:'',max:'',time:''});
      scheduleRawLines.push(serializeScheduleRow(scheduleRows[scheduleRows.length-1]));
      renderScheduleTable();
    };

    document.getElementById('scheduleExportBtn').onclick=()=>{
      const blob=new Blob([scheduleRawLines.join('\n')],{type:'text/plain'});
      const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='schedule.txt';a.click();
    };

    document.getElementById('scheduleValidateBtn').onclick=()=>{
      const probs=[];
      const stageIds=new Set(rows.map(r=>String(r.id)));
      const numericFields=[['date','Date ID'],['round','Round #'],['min','Min Games'],['max','Max Games'],['time','Time']];
      scheduleRows.forEach((r,i)=>{
        const rowNum=i+1;
        if(!r.stage) probs.push(`Row ${rowNum}: Missing Stage ID`);
        else if(!stageIds.has(String(r.stage))) probs.push(`Row ${rowNum}: Stage ID ${r.stage} not found in CompObj table`);
        numericFields.forEach(([field,label])=>{
          const val=r[field];
          if(val==='') probs.push(`Row ${rowNum}: Missing ${label}`);
          else if(Number.isNaN(Number(val))) probs.push(`Row ${rowNum}: ${label} must be numeric`);
        });
      });
      scheduleMessagesEl.innerHTML = probs.length ? probs.join('<br>') : 'No validation issues.';
    };

    function applyGlobalIdMapping(mapping){
      if(!mapping) return;
      const mappingLookup=new Map();
      if(mapping instanceof Map){
        mapping.forEach((newId,oldId)=>{
          const normOld=normalizeId(oldId);
          const normNew=normalizeId(newId);
          if(normOld && normNew && normOld!==normNew){
            mappingLookup.set(normOld, normNew);
          }
        });
      } else {
        Object.keys(mapping).forEach(oldId=>{
          const normOld=normalizeId(oldId);
          const normNew=normalizeId(mapping[oldId]);
          if(normOld && normNew && normOld!==normNew){
            mappingLookup.set(normOld, normNew);
          }
        });
      }
      if(!mappingLookup.size) return;

      let compChanged=false;
      rows.forEach((row,idx)=>{
        let changed=false;
        const currentId=normalizeId(row.id);
        if(mappingLookup.has(currentId)){
          row.id=mappingLookup.get(currentId);
          changed=true;
        }
        const parentId=normalizeId(row.parent);
        if(mappingLookup.has(parentId)){
          row.parent=mappingLookup.get(parentId);
          changed=true;
        }
        if(changed){
          updateCompRawLine(idx);
          compChanged=true;
        }
      });

      let scheduleChanged=false;
      scheduleRows.forEach((row,idx)=>{
        const replacement=mappingLookup.get(normalizeId(row.stage));
        if(replacement!==undefined){
          row.stage=replacement;
          updateScheduleRawLine(idx);
          scheduleChanged=true;
        }
      });

      let weatherIdsChanged=false;
      weatherRows.forEach((row,idx)=>{
        const federationId=normalizeId(row.fed);
        if(mappingLookup.has(federationId)){
          row.fed=mappingLookup.get(federationId);
          updateWeatherRawLine(idx);
          weatherIdsChanged=true;
        }
      });

      advRows.forEach((row,idx)=>{
        let changed=false;
        const fromId=normalizeId(row.fromId);
        if(mappingLookup.has(fromId)){
          row.fromId=mappingLookup.get(fromId);
          changed=true;
        }
        const toId=normalizeId(row.toId);
        if(mappingLookup.has(toId)){
          row.toId=mappingLookup.get(toId);
          changed=true;
        }
        if(changed) updateAdvRawLine(idx);
      });

      taskRows.forEach((row,idx)=>{
        let changed=false;
        ['trophyLine','arg1','arg2','arg3','arg4'].forEach(field=>{
          const val=normalizeId(row[field]);
          if(mappingLookup.has(val)){
            row[field]=mappingLookup.get(val);
            changed=true;
          }
        });
        if(changed) updateTaskRawLine(idx);
      });

      standingsRows.forEach((row,idx)=>{
        const gid=normalizeId(row.groupId);
        if(mappingLookup.has(gid)){
          row.groupId=mappingLookup.get(gid);
          updateStandingsRawLine(idx);
        }
      });

      settingRows.forEach((row,idx)=>{
        const sid=normalizeId(row.id);
        if(mappingLookup.has(sid)){
          row.id=mappingLookup.get(sid);
          if(idx < settingsRawLines.length){
            settingsRawLines[idx]=[row.id ?? '', row.key ?? '', row.value ?? ''].join(',');
          }
        }
      });

      if(activeCompetitionId){
        const activeNorm=normalizeId(activeCompetitionId);
        if(mappingLookup.has(activeNorm)){
          activeCompetitionId=mappingLookup.get(activeNorm);
        }
      }

      if(compChanged){
        refreshCompetitionOptions();
      } else {
        renderTable();
        renderAdvTable();
        renderStandingsTable();
        renderSettingsTable();
        renderScheduleTable();
        renderTaskTable();
        renderWeatherTable();
        if(activeCompetitionId){
          recomputeActiveScope();
          updateCompetitionSummary();
        }
      }

      if(scheduleChanged && scheduleMessagesEl){
        scheduleMessagesEl.textContent='Schedule updated with new stage references.';
      }

      const msgEl=document.getElementById('messages');
      if(msgEl){
        msgEl.textContent='IDs were changed — all cross-file references updated successfully.';
      }
      if(weatherIdsChanged){
        const weatherMessages=document.getElementById('weatherMessages');
        if(weatherMessages){
          weatherMessages.textContent='Weather federation references updated.';
        }
      }
    }
    window.applyGlobalIdMapping=applyGlobalIdMapping;

    updateScheduleMeta();

    /* -----------------------
       Tasks Section
    ----------------------- */
    let taskRows = [];
    let taskRawLines = [];
    let taskDelimiterActual = ',';
    const taskBody = document.getElementById('taskBody');

    function serializeTaskRow(row){
      return [row.trophyLine ?? '', row.phase ?? '', row.taskType ?? '', row.arg1 ?? '', row.arg2 ?? '', row.arg3 ?? '', row.arg4 ?? ''].join(taskDelimiterActual || ',');
    }

    function updateTaskRawLine(index){
      if(index<0 || index>=taskRawLines.length) return;
      taskRawLines[index] = serializeTaskRow(taskRows[index] ?? {});
    }

    function parseTasks(text, delimSel='auto'){
      taskRows = [];
      taskRawLines = [];
      const delim = (delimSel==='auto') ? autoDetectDelimiter(text) : delimSel;
      taskDelimiterActual = delim;
      const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
      for(const line of lines){
        const parts = line.split(delim).map(s=>s.trim());
        while(parts.length<7) parts.push('');
        const [trophyLine, phase, taskType, arg1, arg2, arg3, arg4] = parts;
        taskRows.push({trophyLine, phase, taskType, arg1, arg2, arg3, arg4});
        taskRawLines.push(line);
      }
      document.getElementById('taskMeta').textContent=`${taskRows.length} task lines parsed`;
      renderTaskTable();
    }

    function renderTaskTable(){
      taskBody.innerHTML='';
      const indexes = getVisibleIndexes(taskRows, ['trophyLine','arg1','arg2','arg3','arg4']);
      indexes.forEach((rowIndex,pos)=>{
        const r=taskRows[rowIndex];
        const tr=document.createElement('tr');
        tr.className=pos%2?'bg-white':'bg-slate-50';
        tr.innerHTML=`
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="trophyLine" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.trophyLine}"></td>
          <td class="p-2"><input data-f="phase" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.phase}"></td>
          <td class="p-2"><input data-f="taskType" data-i="${rowIndex}" class="w-40 p-1 border rounded" value="${r.taskType}"></td>
          <td class="p-2"><input data-f="arg1" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.arg1}"></td>
          <td class="p-2"><input data-f="arg2" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.arg2}"></td>
          <td class="p-2"><input data-f="arg3" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.arg3}"></td>
          <td class="p-2"><input data-f="arg4" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.arg4}"></td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        taskBody.appendChild(tr);
      });
      taskBody.querySelectorAll('input').forEach(inp=>{
        inp.onchange=()=>{
          const idx = +inp.dataset.i;
          taskRows[idx][inp.dataset.f]=inp.value;
          updateTaskRawLine(idx);
        };
      });
      taskBody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.onclick=()=>{
          const idx = +btn.dataset.del;
          taskRows.splice(idx,1);
          taskRawLines.splice(idx,1);
          renderTaskTable();
        };
      });
      updateRelationshipPanels(rows[selectedRowIndex]?.id);
    }

    document.getElementById('taskFileInput').onchange=e=>{
      const f=e.target.files[0]; if(!f) return;
      const r=new FileReader();
      r.onload=()=>parseTasks(r.result, document.getElementById('taskDelimiter').value);
      r.readAsText(f);
    };

    document.getElementById('taskPasteBtn').onclick=()=>{
      const pa=document.getElementById('taskPasteArea');
      pa.classList.toggle('hidden');
      if(!pa.classList.contains('hidden')) pa.focus();
    };
    document.getElementById('taskPasteArea').onblur=e=>parseTasks(e.target.value, document.getElementById('taskDelimiter').value);

    document.getElementById('taskAddBtn').onclick=()=>{
      taskRows.push({trophyLine:'',phase:'',taskType:'',arg1:'',arg2:'',arg3:'',arg4:''});
      taskRawLines.push(serializeTaskRow(taskRows[taskRows.length-1]));
      renderTaskTable();
    };

    document.getElementById('taskSortBtn').onclick=()=>{
      const combined = taskRows.map((row,idx)=>({row, raw: taskRawLines[idx]}));
      combined.sort((a,b)=>{
        const diff=Number(a.row.trophyLine||0)-Number(b.row.trophyLine||0);
        if(diff!==0) return diff;
        return (a.row.phase || '').localeCompare(b.row.phase || '');
      });
      taskRows = combined.map(item=>item.row);
      taskRawLines = combined.map(item=>item.raw);
      renderTaskTable();
    };

    document.getElementById('taskExportBtn').onclick=()=>{
      const blob=new Blob([taskRawLines.join('\n')],{type:'text/plain'});
      const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='tasks.txt';a.click();
    };

    document.getElementById('taskValidateBtn').onclick=()=>{
      const probs=[];
      taskRows.forEach((r,i)=>{
        if(!r.trophyLine) probs.push(`Line ${i+1}: Missing trophy line`);
        if(!r.phase) probs.push(`Line ${i+1}: Missing phase (start/end)`);
        if(!r.taskType) probs.push(`Line ${i+1}: Missing task type`);
      });
      document.getElementById('taskMessages').innerHTML = probs.length ? probs.join('<br>') : 'No validation issues.';
    };

    /* -----------------------
       Weather Section
    ----------------------- */
    const weatherBody = document.getElementById('weatherBody');

    function updateWeatherMeta(){
      const count = weatherRows.length;
      document.getElementById('weatherMeta').textContent = `${count} weather line${count===1?'':'s'} parsed`;
    }

    function serializeWeatherRow(row){
      return [row.fed ?? '', row.day ?? '', row.type ?? '', row.p1 ?? '', row.p2 ?? '', row.p3 ?? '', row.p4 ?? '', row.start ?? '', row.end ?? ''].join(',');
    }

    function updateWeatherRawLine(index){
      if(index<0 || index>=weatherRawLines.length) return;
      weatherRawLines[index] = serializeWeatherRow(weatherRows[index] ?? {});
    }

    function renderWeatherTable(){
      if(!weatherBody) return;
      weatherBody.innerHTML='';
      const indexes = getVisibleIndexes(weatherRows, ['fed']);
      indexes.forEach((rowIndex,pos)=>{
        const r=weatherRows[rowIndex];
        const tr=document.createElement('tr');
        tr.className=pos%2?'bg-white':'bg-slate-50';
        tr.innerHTML=`
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="fed" data-i="${rowIndex}" class="w-28 p-1 border rounded" value="${r.fed ?? ''}"></td>
          <td class="p-2"><input data-f="day" data-i="${rowIndex}" class="w-20 p-1 border rounded" value="${r.day ?? ''}"></td>
          <td class="p-2"><input data-f="type" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.type ?? ''}"></td>
          <td class="p-2"><input data-f="p1" data-i="${rowIndex}" class="w-20 p-1 border rounded" value="${r.p1 ?? ''}"></td>
          <td class="p-2"><input data-f="p2" data-i="${rowIndex}" class="w-20 p-1 border rounded" value="${r.p2 ?? ''}"></td>
          <td class="p-2"><input data-f="p3" data-i="${rowIndex}" class="w-20 p-1 border rounded" value="${r.p3 ?? ''}"></td>
          <td class="p-2"><input data-f="p4" data-i="${rowIndex}" class="w-20 p-1 border rounded" value="${r.p4 ?? ''}"></td>
          <td class="p-2"><input data-f="start" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.start ?? ''}"></td>
          <td class="p-2"><input data-f="end" data-i="${rowIndex}" class="w-24 p-1 border rounded" value="${r.end ?? ''}"></td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        weatherBody.appendChild(tr);
      });
      weatherBody.querySelectorAll('input').forEach(inp=>{
        inp.onchange=()=>{
          const idx = +inp.dataset.i;
          weatherRows[idx][inp.dataset.f]=inp.value;
          updateWeatherRawLine(idx);
        };
      });
      weatherBody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.onclick=()=>{
          const idx = +btn.dataset.del;
          weatherRows.splice(idx,1);
          weatherRawLines.splice(idx,1);
          renderWeatherTable();
        };
      });
      updateWeatherMeta();
    }

    function parseWeather(text){
      weatherRows=[];
      weatherRawLines=[];
      const rawLines=text.split(/\r?\n/);
      for(const rawLine of rawLines){
        if(!rawLine || !rawLine.trim()) continue;
        const parts=rawLine.split(',');
        while(parts.length<9) parts.push('');
        const trimmedParts = parts.map(s=>s.trim());
        const [fed='', day='', type='', p1='', p2='', p3='', p4='', start='', end=''] = trimmedParts;
        weatherRows.push({fed, day, type, p1, p2, p3, p4, start, end});
        weatherRawLines.push(rawLine);
      }
      renderWeatherTable();
    }

    document.getElementById('weatherFileInput').onchange=e=>{
      const f=e.target.files[0]; if(!f) return;
      const r=new FileReader();
      r.onload=()=>parseWeather(r.result);
      r.readAsText(f);
    };

    document.getElementById('weatherPasteBtn').onclick=()=>{
      const pa=document.getElementById('weatherPasteArea');
      pa.classList.toggle('hidden');
      if(!pa.classList.contains('hidden')) pa.focus();
    };
    document.getElementById('weatherPasteArea').onblur=e=>parseWeather(e.target.value);

    document.getElementById('weatherAddBtn').onclick=()=>{
      weatherRows.push({fed:'',day:'',type:'',p1:'',p2:'',p3:'',p4:'',start:'',end:''});
      weatherRawLines.push(serializeWeatherRow(weatherRows[weatherRows.length-1]));
      renderWeatherTable();
    };

    document.getElementById('weatherExportBtn').onclick=()=>{
      const blob=new Blob([weatherRawLines.join('\n')],{type:'text/plain'});
      const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='weather.txt';a.click();
    };

    document.getElementById('weatherValidateBtn').onclick=()=>{
      const messages=[];
      const ids=new Set(rows.map(r=>String(r.id)));
      const numericFields=[['day','Day ID'],['type','Weather Type'],['p1','Param1'],['p2','Param2'],['p3','Param3'],['p4','Param4'],['start','Start Time'],['end','End Time']];
      weatherRows.forEach((r,i)=>{
        if(r.fed && !ids.has(String(r.fed))) messages.push(`Row ${i+1}: Federation ID ${r.fed} not found in CompObj table`);
        numericFields.forEach(([field,label])=>{
          const value=r[field];
          if(value!=='' && Number.isNaN(Number(value))) messages.push(`Row ${i+1}: ${label} must be numeric`);
        });
      });
      document.getElementById('weatherMessages').innerHTML = messages.length ? messages.join('<br>') : 'No validation issues.';
    };

    updateWeatherMeta();

    /* -----------------------
       Objectives Section
    ----------------------- */

    function updateObjectivesMeta(){
      if(!objectivesMeta) return;
      const count = objectiveRows.length;
      objectivesMeta.textContent = `${count} objective line${count===1?'':'s'} parsed`;
    }

    function serializeObjectiveRow(row){
      return [row.targetId ?? '', row.objective ?? '', row.primary ?? ''].join(',');
    }

    function updateObjectivesRawLine(index){
      if(index<0 || index>=objectiveRawLines.length) return;
      objectiveRawLines[index] = serializeObjectiveRow(objectiveRows[index] ?? {});
    }

    function renderObjectivesTable(){
      if(!objectivesBody) return;
      objectivesBody.innerHTML='';
      const indexes = getVisibleIndexes(objectiveRows, ['targetId']);
      indexes.forEach((rowIndex,pos)=>{
        const r = objectiveRows[rowIndex];
        const tr=document.createElement('tr');
        tr.className = pos%2?'bg-white':'bg-slate-50';
        tr.innerHTML=`
          <td class="p-2">${pos+1}</td>
          <td class="p-2"><input data-f="targetId" data-i="${rowIndex}" class="w-28 p-1 border rounded" value="${r.targetId ?? ''}"></td>
          <td class="p-2"><input data-f="objective" data-i="${rowIndex}" class="w-48 p-1 border rounded" value="${r.objective ?? ''}"></td>
          <td class="p-2"><input data-f="primary" data-i="${rowIndex}" class="w-20 p-1 border rounded" value="${r.primary ?? ''}"></td>
          <td class="p-2"><button data-del="${rowIndex}" class="px-2 py-1 bg-red-500 text-white rounded">Del</button></td>`;
        objectivesBody.appendChild(tr);
      });
      objectivesBody.querySelectorAll('input').forEach(inp=>{
        inp.onchange=()=>{
          const idx = +inp.dataset.i;
          objectiveRows[idx][inp.dataset.f] = inp.value;
          updateObjectivesRawLine(idx);
          updateObjectivesMeta();
        };
      });
      objectivesBody.querySelectorAll('button[data-del]').forEach(btn=>{
        btn.onclick=()=>{
          const idx = +btn.dataset.del;
          objectiveRows.splice(idx,1);
          objectiveRawLines.splice(idx,1);
          renderObjectivesTable();
        };
      });
      updateObjectivesMeta();
    }

    function parseObjectives(text){
      objectiveRows=[];
      objectiveRawLines=[];
      const rawLines=text.split(/\r?\n/);
      for(const rawLine of rawLines){
        if(!rawLine || !rawLine.trim()) continue;
        const parts=rawLine.split(',');
        while(parts.length<3) parts.push('');
        const [targetId='', objective='', primary=''] = parts.map(s=>s.trim());
        objectiveRows.push({targetId, objective, primary});
        objectiveRawLines.push(rawLine);
      }
      renderObjectivesTable();
    }

    const objectivesFileInputEl = document.getElementById('objectivesFileInput');
    if(objectivesFileInputEl){
      objectivesFileInputEl.onchange=e=>{
        const f=e.target.files?.[0];
        if(!f) return;
        const r=new FileReader();
        r.onload=()=>parseObjectives(r.result);
        r.readAsText(f);
      };
    }

    const objectivesPasteBtn = document.getElementById('objectivesPasteBtn');
    if(objectivesPasteBtn){
      objectivesPasteBtn.onclick=()=>{
        const pa=document.getElementById('objectivesPasteArea');
        pa.classList.toggle('hidden');
        if(!pa.classList.contains('hidden')) pa.focus();
      };
    }

    const objectivesPasteArea = document.getElementById('objectivesPasteArea');
    if(objectivesPasteArea){
      objectivesPasteArea.onblur=e=>parseObjectives(e.target.value || '');
    }

    const objectivesAddBtn = document.getElementById('objectivesAddBtn');
    if(objectivesAddBtn){
      objectivesAddBtn.onclick=()=>{
        const newRow={targetId:'',objective:'',primary:'0'};
        objectiveRows.push(newRow);
        objectiveRawLines.push(serializeObjectiveRow(newRow));
        renderObjectivesTable();
      };
    }

    const objectivesExportBtn = document.getElementById('objectivesExportBtn');
    if(objectivesExportBtn){
      objectivesExportBtn.onclick=()=>{
        const blob=new Blob([objectiveRawLines.join('\n')],{type:'text/plain'});
        const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='objectives.txt';a.click();
      };
    }

    const objectivesValidateBtn = document.getElementById('objectivesValidateBtn');
    if(objectivesValidateBtn){
      objectivesValidateBtn.onclick=()=>{
        const messages=[];
        const ids=new Set(rows.map(r=>normalizeId(r.id)));
        objectiveRows.forEach((r,i)=>{
          if(!normalizeId(r.targetId)) messages.push(`Row ${i+1}: Missing target ID`);
          if(r.targetId && !ids.has(normalizeId(r.targetId)) && normalizeId(r.targetId)!=='0'){
            messages.push(`Row ${i+1}: Target ID ${r.targetId} not found in CompObj table`);
          }
          if(!normalizeId(r.objective)) messages.push(`Row ${i+1}: Missing objective code`);
          if(r.primary!=='' && !/^(0|1)$/i.test(String(r.primary).trim())) messages.push(`Row ${i+1}: Primary flag must be 0 or 1`);
        });
        if(objectivesMessages){
          objectivesMessages.innerHTML = messages.length ? messages.join('<br>') : 'No validation issues.';
        }
      };
    }

    updateObjectivesMeta();

    /* -----------------------
       Validation & Repair
    ----------------------- */

    const REFERENCE_ALLOWLIST = new Set(['0', 'GLOBAL', 'DEFAULT', 'NONE', '']);

    function toFileKey(name){
      return String(name || '').toLowerCase().replace(/\.txt$/,'');
    }

    function getFileAdapters(){
      return {
        compobj: {
          key: 'compobj',
          label: 'compobj.txt',
          exportName: 'compobj',
          expectedColumns: 5,
          columnNames: ['ID','Level','Code','Name','Parent'],
          fields: ['id','level','code','name','parent'],
          allowEmptyColumns: new Set([4]),
          numericColumns: new Set([0,1]),
          delimiter: ()=>compDelimiter || ',',
          getRawLines: ()=>compRawLines,
          getRows: ()=>rows,
          updateField: (index, field, value)=>{
            if(!rows[index]) return;
            rows[index][field] = value;
            updateCompRawLine(index);
          },
          serializeAll: ()=>rows.map(serializeCompRow).join('\n')
        },
        advancement: {
          key: 'advancement',
          label: 'advancement.txt',
          exportName: 'advancement',
          expectedColumns: 4,
          columnNames: ['From Group','Qualifier','To Group','Slot'],
          fields: ['fromId','qualifier','toId','slot'],
          allowEmptyColumns: new Set([1,3]),
          numericColumns: new Set([3]),
          delimiter: () => ',',
          getRawLines: ()=>advRawLines,
          getRows: ()=>advRows,
          updateField: (index, field, value)=>{
            if(!advRows[index]) return;
            advRows[index][field] = value;
            updateAdvRawLine(index);
          },
          serializeAll: ()=>advRows.map(serializeAdvRow).join('\n')
        },
        standings: {
          key: 'standings',
          label: 'standings.txt',
          exportName: 'standings',
          expectedColumns: 2,
          columnNames: ['Group','Slot'],
          fields: ['groupId','slot'],
          allowEmptyColumns: new Set([]),
          numericColumns: new Set([1]),
          delimiter: ()=>standingsDelimiter || ',',
          getRawLines: ()=>standingsRawLines,
          getRows: ()=>standingsRows,
          updateField: (index, field, value)=>{
            if(!standingsRows[index]) return;
            standingsRows[index][field] = value;
            updateStandingsRawLine(index);
          },
          serializeAll: ()=>standingsRows.map(serializeStandingsRow).join('\n')
        },
        settings: {
          key: 'settings',
          label: 'settings.txt',
          exportName: 'settings',
          expectedColumns: 3,
          columnNames: ['ID','Key','Value'],
          fields: ['id','key','value'],
          allowEmptyColumns: new Set([2]),
          numericColumns: new Set([]),
          delimiter: ()=>',',
          getRawLines: ()=>settingsRawLines,
          getRows: ()=>settingRows,
          updateField: (index, field, value)=>{
            if(!settingRows[index]) return;
            settingRows[index][field] = value;
            updateSettingsRawLine(index);
          },
          serializeAll: ()=>settingRows.map(serializeSettingRow).join('\n')
        },
        weather: {
          key: 'weather',
          label: 'weather.txt',
          exportName: 'weather',
          expectedColumns: 9,
          columnNames: ['Federation','Day','Type','Param1','Param2','Param3','Param4','Start','End'],
          fields: ['fed','day','type','p1','p2','p3','p4','start','end'],
          allowEmptyColumns: new Set([]),
          numericColumns: new Set([0,1,2,3,4,5,6,7,8]),
          delimiter: ()=>',',
          getRawLines: ()=>weatherRawLines,
          getRows: ()=>weatherRows,
          updateField: (index, field, value)=>{
            if(!weatherRows[index]) return;
            weatherRows[index][field] = value;
            updateWeatherRawLine(index);
          },
          serializeAll: ()=>weatherRows.map(serializeWeatherRow).join('\n')
        },
        objectives: {
          key: 'objectives',
          label: 'objectives.txt',
          exportName: 'objectives',
          expectedColumns: 3,
          columnNames: ['Target','Objective','Primary'],
          fields: ['targetId','objective','primary'],
          allowEmptyColumns: new Set([2]),
          numericColumns: new Set([]),
          delimiter: ()=>',',
          getRawLines: ()=>objectiveRawLines,
          getRows: ()=>objectiveRows,
          updateField: (index, field, value)=>{
            if(!objectiveRows[index]) return;
            objectiveRows[index][field] = value;
            updateObjectivesRawLine(index);
          },
          serializeAll: ()=>objectiveRows.map(serializeObjectiveRow).join('\n')
        }
      };
    }

    function splitWithDelimiter(line, delimiter){
      if(delimiter === '\\t') return String(line ?? '').split('\t');
      return String(line ?? '').split(delimiter);
    }

    function pushIssue(list, fileKey, fileLabel, category, severity, message, lineNumber){
      list.push({
        id: `${fileKey}-${category}-${lineNumber}-${list.length}`,
        fileKey,
        fileLabel,
        category,
        severity,
        message,
        line: lineNumber
      });
    }

    function recordChangelog(entries){
      if(!entries || !entries.length) return;
      const timestamp = new Date().toISOString();
      entries.forEach(entry=>{
        validationState.changelog.push({...entry, timestamp});
      });
      updateChangelogStatus();
    }

    function updateChangelogStatus(){
      if(!changelogStatus) return;
      if(!validationState.changelog.length){
        changelogStatus.textContent = 'No fixes applied yet.';
        return;
      }
      const last = validationState.changelog[validationState.changelog.length-1];
      changelogStatus.textContent = `${validationState.changelog.length} change${validationState.changelog.length===1?'':'s'} recorded. Last update ${new Date(last.timestamp).toLocaleString()}`;
    }

    function queueFix(fileKey, fileLabel, description, applyFn, options={}){
      const suggestion = {
        id: `${fileKey}-fix-${Math.random().toString(36).slice(2)}`,
        fileKey,
        fileLabel,
        description,
        line: options.line ?? null,
        columnName: options.columnName ?? '',
        auto: options.auto !== false,
        category: options.category || 'Format',
        apply: applyFn,
        applied: false
      };
      validationState.suggestions.push(suggestion);
    }

    function applySuggestion(suggestion, {skipConfirm=false}={}){
      if(!suggestion || suggestion.applied) return false;
      if(!skipConfirm){
        const confirmation = confirm(`Apply fix: ${suggestion.description}?`);
        if(!confirmation) return false;
      }
      const result = suggestion.apply?.();
      if(result && Array.isArray(result) && result.length){
        recordChangelog(result);
      }
      suggestion.applied = true;
      return true;
    }

    function applyAllFixes({auto=false, skipConfirmPerItem=false}={}){
      let applied = false;
      validationState.suggestions.forEach(suggestion=>{
        if(suggestion.applied) return;
        if(auto && suggestion.auto){
          const didApply = applySuggestion(suggestion, {skipConfirm:true});
          applied = applied || didApply;
        } else if(!auto){
          const didApply = applySuggestion(suggestion, {skipConfirm:skipConfirmPerItem});
          applied = applied || didApply;
        }
      });
      return applied;
    }

    function downloadBlob(blob, filename){
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=filename;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
    }

    function renderValidationSummary(){
      if(!validationSummaryBody) return;
      const adapters = getFileAdapters();
      const summaryMap = new Map();
      Object.values(adapters).forEach(adapter=>{
        summaryMap.set(adapter.key, {
          fileLabel: adapter.label,
          errors: 0,
          warnings: 0,
          notes: []
        });
      });

      validationState.issues.forEach(issue=>{
        if(!summaryMap.has(issue.fileKey)){
          summaryMap.set(issue.fileKey, {fileLabel: issue.fileLabel, errors:0, warnings:0, notes: []});
        }
        const bucket = summaryMap.get(issue.fileKey);
        if(issue.severity === 'error') bucket.errors += 1;
        else bucket.warnings += 1;
      });

      const diffCounts = new Map();
      validationState.diffs.forEach(diff=>{
        if(!diffCounts.has(diff.fileKey)) diffCounts.set(diff.fileKey,0);
        diffCounts.set(diff.fileKey, diffCounts.get(diff.fileKey)+1);
      });

      const suggestionCounts = new Map();
      validationState.suggestions.forEach(suggestion=>{
        if(suggestion.applied) return;
        if(!suggestionCounts.has(suggestion.fileKey)) suggestionCounts.set(suggestion.fileKey,0);
        suggestionCounts.set(suggestion.fileKey, suggestionCounts.get(suggestion.fileKey)+1);
      });

      summaryMap.forEach((bucket,key)=>{
        if(diffCounts.has(key)) bucket.notes.push(`${diffCounts.get(key)} baseline diff${diffCounts.get(key)===1?'':'s'}`);
        if(suggestionCounts.has(key)) bucket.notes.push(`${suggestionCounts.get(key)} fix${suggestionCounts.get(key)===1?'':'es'} ready`);
      });

      const rowsData = Array.from(summaryMap.entries()).map(([key, bucket])=>({key, ...bucket}));
      rowsData.sort((a,b)=>a.fileLabel.localeCompare(b.fileLabel));

      validationSummaryBody.innerHTML='';
      const fragment=document.createDocumentFragment();
      rowsData.forEach(row=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`
          <td class="p-2 font-medium">${escapeHtml(row.fileLabel)}</td>
          <td class="p-2 text-red-600">${row.errors}</td>
          <td class="p-2 text-amber-500">${row.warnings}</td>
          <td class="p-2 text-slate-600">${row.notes.length ? escapeHtml(row.notes.join('; ')) : '—'}</td>`;
        fragment.appendChild(tr);
      });
      validationSummaryBody.appendChild(fragment);
    }

    function renderValidationLog(){
      if(!validationLog) return;
      validationLog.innerHTML='';
      if(!validationState.issues.length){
        validationLog.innerHTML='<p class="text-slate-500">No validation issues detected.</p>';
        return;
      }
      const fragment=document.createDocumentFragment();
      validationState.issues.forEach(issue=>{
        const div=document.createElement('div');
        div.className = `border-l-4 pl-2 ${issue.severity==='error' ? 'border-red-500 text-red-600' : 'border-amber-400 text-amber-600'}`;
        const lineInfo = issue.line ? `Line ${issue.line}` : 'Line —';
        div.innerHTML = `<div class="font-semibold">${escapeHtml(issue.category)}</div><div class="text-xs text-slate-500">${escapeHtml(issue.fileLabel)} · ${lineInfo}</div><div>${escapeHtml(issue.message)}</div>`;
        fragment.appendChild(div);
      });
      validationLog.appendChild(fragment);
    }

    function renderFixList(){
      if(!fixList) return;
      fixList.innerHTML='';
      const pending = validationState.suggestions.filter(s=>!s.applied);
      if(!pending.length){
        fixList.innerHTML='<p class="text-slate-500">No auto-fix suggestions available.</p>';
        return;
      }
      const fragment=document.createDocumentFragment();
      pending.forEach(suggestion=>{
        const wrapper=document.createElement('div');
        wrapper.className='border border-slate-200 dark:border-slate-700 rounded p-2';
        const lineInfo = suggestion.line ? `Line ${suggestion.line}` : 'Line —';
        wrapper.innerHTML=`<div class="font-medium">${escapeHtml(suggestion.description)}</div><div class="text-xs text-slate-500 mt-1">${escapeHtml(suggestion.fileLabel)} · ${lineInfo}${suggestion.auto?' · auto':' · manual'}</div>`;
        const btn=document.createElement('button');
        btn.className='mt-2 px-2 py-1 bg-blue-600 text-white rounded';
        btn.textContent='Apply Fix';
        btn.onclick=()=>{
          if(applySuggestion(suggestion)){ runValidation(true); }
        };
        wrapper.appendChild(btn);
        fragment.appendChild(wrapper);
      });
      fixList.appendChild(fragment);
    }

    function renderDiffs(){
      if(!diffOutput) return;
      diffOutput.innerHTML='';
      if(!validationState.diffs.length){
        diffOutput.innerHTML='<p class="text-slate-500">No differences detected against the loaded baseline.</p>';
        return;
      }
      const fragment=document.createDocumentFragment();
      validationState.diffs.forEach(diff=>{
        const div=document.createElement('div');
        div.className='border-l-4 border-amber-400 pl-2 text-slate-700 dark:text-slate-200';
        const lineInfo = diff.line ? `Line ${diff.line}` : 'Line —';
        div.innerHTML=`<div class="font-semibold">${escapeHtml(diff.fileLabel)} · ${lineInfo}</div><div class="text-xs text-slate-500">Baseline: ${escapeHtml(diff.baseline)}</div><div class="text-xs text-slate-500">Current: ${escapeHtml(diff.current)}</div>`;
        fragment.appendChild(div);
      });
      diffOutput.appendChild(fragment);
    }

    function updateValidationControls(){
      const hasPendingFixes = validationState.suggestions.some(s=>!s.applied);
      if(applyAllFixesBtn) applyAllFixesBtn.disabled = !hasPendingFixes;
      const hasErrors = validationState.issues.some(issue=>issue.severity==='error');
      if(exportValidatedBtn) exportValidatedBtn.disabled = hasErrors;
      if(viewDifferencesBtn) viewDifferencesBtn.disabled = !validationState.diffs.length;
      if(validationStatus){
        if(!validationState.issues.length){
          validationStatus.textContent = 'No issues detected.';
        } else {
          const errors = validationState.issues.filter(i=>i.severity==='error').length;
          const warnings = validationState.issues.filter(i=>i.severity!=='error').length;
          validationStatus.textContent = `${errors} error${errors===1?'':'s'}, ${warnings} warning${warnings===1?'':'s'} found.`;
        }
      }
    }

    function buildDiffs(adapters){
      const diffs=[];
      validationState.baseline.forEach((baselineEntry, key)=>{
        const adapter = adapters[key];
        if(!adapter) return;
        const currentLines = adapter.getRawLines().map(line=>String(line ?? ''));
        const baselineLines = baselineEntry.lines;
        const max = Math.max(currentLines.length, baselineLines.length);
        for(let i=0;i<max;i+=1){
          const baselineLine = baselineLines[i] ?? '';
          const currentLine = currentLines[i] ?? '';
          if(baselineLine === currentLine) continue;
          diffs.push({
            fileKey: key,
            fileLabel: adapter.label,
            line: i+1,
            baseline: baselineLine,
            current: currentLine
          });
        }
      });
      return diffs;
    }

    function runValidation(autoTriggered=false){
      const adapters = getFileAdapters();
      validationState.issues = [];
      validationState.suggestions = [];
      validationState.validatedOutputs = new Map();

      const compAdapter = adapters.compobj;
      const compRowsRef = compAdapter ? compAdapter.getRows() : [];
      const compIndexMap = new Map();
      const compIdCounts = new Map();
      compRowsRef.forEach((row, index)=>{
        const id = normalizeId(row?.id);
        if(!id) return;
        if(!compIndexMap.has(id)) compIndexMap.set(id, {row, index});
        compIdCounts.set(id, (compIdCounts.get(id) || 0) + 1);
      });

      Object.values(adapters).forEach(adapter=>{
        const rawLines = adapter.getRawLines();
        const delimiter = adapter.delimiter();
        const columnNames = adapter.columnNames;
        const allowEmpty = adapter.allowEmptyColumns || new Set();
        const numericColumns = adapter.numericColumns || new Set();
        const fields = adapter.fields;

        rawLines.forEach((rawLine, index)=>{
          if(!rawLine && rawLine !== '') return;
          const lineNumber = index + 1;
          const segments = splitWithDelimiter(rawLine, delimiter);
          if(segments.length !== adapter.expectedColumns){
            pushIssue(validationState.issues, adapter.key, adapter.label, 'Syntax Error', 'error', `Expected ${adapter.expectedColumns} columns but found ${segments.length}.`, lineNumber);
          }
          if(rawLine.includes(`${delimiter}${delimiter}`)){
            pushIssue(validationState.issues, adapter.key, adapter.label, 'Syntax Error', 'error', 'Detected double delimiter with missing field.', lineNumber);
          }
          const trimmed = segments.map(seg=>seg.trim());
          trimmed.forEach((value, colIndex)=>{
            const colName = columnNames[colIndex] || `Column ${colIndex+1}`;
            const original = segments[colIndex] ?? '';
            if(original !== value){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Format Error', 'warning', `${colName} contains leading or trailing whitespace.`, lineNumber);
              const fieldKey = fields[colIndex];
              queueFix(adapter.key, adapter.label, `Trim whitespace for ${colName}`, ()=>{
                const before = adapter.getRows()[index]?.[fieldKey] ?? original;
                adapter.updateField(index, fieldKey, value);
                return [{file: adapter.label, line: lineNumber, field: colName, before, after: value, description: `Trimmed ${colName}`}];
              }, {line: lineNumber, columnName: colName, auto: true});
            }
            if(!value && !allowEmpty.has(colIndex)){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Syntax Error', 'error', `${colName} is required.`, lineNumber);
            }
            if(value && numericColumns.has(colIndex) && Number.isNaN(Number(value))){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Syntax Error', 'error', `${colName} must be a valid number.`, lineNumber);
            }
          });

          if(adapter.key === 'compobj'){
            const level = trimmed[1];
            const code = trimmed[2];
            const parent = trimmed[4];
            const rowData = compRowsRef[index];
            if(level && !['3','4','5'].includes(level)){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Structure Error', 'error', `Invalid level value "${level}".`, lineNumber);
            }
            if(level === '4'){
              if(!normalizeId(parent)){
                pushIssue(validationState.issues, adapter.key, adapter.label, 'Structure Error', 'error', 'Stage rows require a parent competition ID.', lineNumber);
              } else if(compIndexMap.has(normalizeId(parent))){
                const parentLevel = normalizeId(compIndexMap.get(normalizeId(parent)).row.level);
                if(parentLevel !== '3'){
                  pushIssue(validationState.issues, adapter.key, adapter.label, 'Structure Error', 'error', `Stage parent ${parent} should be level 3 (competition) but is level ${parentLevel || '?'}.`, lineNumber);
                }
              }
              if(code && !/^((LEAGUE|GROUP|PLAYOFF|SEMI_FINAL|FINAL|STAGE|ROUND))_/i.test(code)){
                pushIssue(validationState.issues, adapter.key, adapter.label, 'Format Error', 'warning', `Stage code "${code}" does not follow expected prefix (LEAGUE_, GROUP_, PLAYOFF_, SEMI_FINAL_, FINAL_, STAGE_, ROUND_).`, lineNumber);
                queueFix(adapter.key, adapter.label, `Normalize stage code for line ${lineNumber}`, ()=>{
                  const before = rowData?.code ?? code;
                  const suffixMatch = /(\d+)$/.exec(String(code));
                  const suffix = suffixMatch ? suffixMatch[0] : String(lineNumber).padStart(2,'0');
                  const newCode = `LEAGUE_${suffix}`;
                  adapter.updateField(index, 'code', newCode);
                  return [{file: adapter.label, line: lineNumber, field: 'Code', before, after: newCode, description: 'Normalized stage code'}];
                }, {line: lineNumber, columnName: 'Code', auto: true});
              }
            }
            if(level === '5'){
              if(!normalizeId(parent)){
                pushIssue(validationState.issues, adapter.key, adapter.label, 'Structure Error', 'error', 'Group rows require a parent stage ID.', lineNumber);
              } else if(compIndexMap.has(normalizeId(parent))){
                const parentLevel = normalizeId(compIndexMap.get(normalizeId(parent)).row.level);
                if(parentLevel !== '4'){
                  pushIssue(validationState.issues, adapter.key, adapter.label, 'Structure Error', 'error', `Group parent ${parent} should be level 4 (stage) but is level ${parentLevel || '?'}.`, lineNumber);
                }
              }
            }
            if(level === '3' && code && !/^FCE_/i.test(code)){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Format Error', 'warning', `Competition code "${code}" is missing the FCE_ prefix.`, lineNumber);
              queueFix(adapter.key, adapter.label, `Add FCE_ prefix for competition code on line ${lineNumber}`, ()=>{
                const before = rowData?.code ?? code;
                const newCode = `FCE_${normalizeIdUpper(code)}`;
                adapter.updateField(index, 'code', newCode);
                return [{file: adapter.label, line: lineNumber, field: 'Code', before, after: newCode, description: 'Added FCE_ prefix'}];
              }, {line: lineNumber, columnName: 'Code', auto: true});
            }
          }

          if(adapter.key === 'weather'){
            const fed = trimmed[0];
            if(fed && !REFERENCE_ALLOWLIST.has(normalizeId(fed)) && !compIndexMap.has(normalizeId(fed))){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Reference Error', 'error', `Federation ID ${fed} not found in CompObj.`, lineNumber);
            }
          }
        });

        const sanitized = adapter.serializeAll();
        validationState.validatedOutputs.set(adapter.key, sanitized);
      });

      compIdCounts.forEach((count, id)=>{
        if(count>1){
          const details = compIndexMap.get(id);
          const lineNumber = (details?.index ?? 0) + 1;
          pushIssue(validationState.issues, 'compobj', 'compobj.txt', 'Structure Error', 'error', `Duplicate ID ${id} appears ${count} times.`, lineNumber);
        }
      });

      // Reference validation across files
      const compIds = new Set(Array.from(compIndexMap.keys()));
      const adaptersArray = Object.values(adapters);
      adaptersArray.forEach(adapter=>{
        if(adapter.key==='compobj') return;
        const rawLines = adapter.getRawLines();
        rawLines.forEach((rawLine,index)=>{
          const trimmed = splitWithDelimiter(rawLine, adapter.delimiter()).map(v=>v.trim());
          const lineNumber = index+1;
          if(adapter.key==='advancement'){
            const fromId = normalizeId(trimmed[0]);
            const toId = normalizeId(trimmed[2]);
            if(fromId && !compIds.has(fromId)){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Reference Error', 'error', `From Group ID ${trimmed[0]} not found in CompObj.`, lineNumber);
            }
            if(toId && !compIds.has(toId)){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Reference Error', 'error', `To Group ID ${trimmed[2]} not found in CompObj.`, lineNumber);
            }
          }
          if(adapter.key==='settings'){
            const settingId = normalizeId(trimmed[0]);
            if(settingId && !REFERENCE_ALLOWLIST.has(settingId) && !compIds.has(settingId)){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Reference Error', 'warning', `Setting ID ${trimmed[0]} is not present in CompObj.`, lineNumber);
            }
          }
          if(adapter.key==='objectives'){
            const targetId = normalizeId(trimmed[0]);
            if(targetId && !REFERENCE_ALLOWLIST.has(targetId) && !compIds.has(targetId)){
              pushIssue(validationState.issues, adapter.key, adapter.label, 'Reference Error', 'error', `Objective target ${trimmed[0]} not present in CompObj.`, lineNumber);
            }
          }
        });
      });

      validationState.diffs = buildDiffs(adapters);
      renderValidationSummary();
      renderValidationLog();
      renderFixList();
      updateValidationControls();
      if(validationState.autoRepairEnabled && !autoTriggered && !validationState.runningAutoRepair){
        validationState.runningAutoRepair = true;
        const applied = applyAllFixes({auto:true});
        validationState.runningAutoRepair = false;
        if(applied){
          runValidation(true);
          return;
        }
      }
      validationState.lastRan = new Date();
    }

    async function loadBaselineFiles(fileList){
      validationState.baseline.clear();
      if(!fileList || !fileList.length){
        if(baselineStatus) baselineStatus.textContent='No baseline loaded.';
        return;
      }
      const files = Array.from(fileList);
      const entries = await Promise.all(files.filter(f=>/\.txt$/i.test(f.name)).map(async file=>{
        const text = await file.text();
        const key = toFileKey(file.name);
        const lines = text.split(/\r?\n/).filter(line=>line.trim());
        return {key, name: file.name, lines};
      }));
      entries.forEach(entry=>{
        if(!entry.key) return;
        validationState.baseline.set(entry.key, {name: entry.name, lines: entry.lines});
      });
      if(baselineStatus) baselineStatus.textContent = `Baseline loaded (${validationState.baseline.size} files).`;
    }

    function exportValidatedFiles(){
      const adapters = getFileAdapters();
      Object.values(adapters).forEach(adapter=>{
        const text = adapter.serializeAll();
        const filename = `${adapter.exportName || adapter.key}_validated.txt`;
        downloadBlob(new Blob([text],{type:'text/plain'}), filename);
      });
      if(validationState.changelog.length){
        const changelogBlob = new Blob([JSON.stringify(validationState.changelog, null, 2)],{type:'application/json'});
        downloadBlob(changelogBlob, 'validation-changelog.json');
      }
    }

    if(baselineInput){
      baselineInput.onchange=e=>{
        loadBaselineFiles(e.target.files || []);
      };
    }

    if(runValidationBtn){
      runValidationBtn.onclick=()=>{
        runValidation();
      };
    }

    if(applyAllFixesBtn){
      applyAllFixesBtn.onclick=()=>{
        if(!validationState.suggestions.some(s=>!s.applied)) return;
        const confirmed = confirm('Apply all available fixes?');
        if(!confirmed) return;
        const applied = applyAllFixes({skipConfirmPerItem:true});
        if(applied) runValidation(true);
      };
    }

    if(exportValidatedBtn){
      exportValidatedBtn.onclick=()=>{
        if(validationState.issues.some(issue=>issue.severity==='error')){
          alert('Resolve all errors before exporting validated files.');
          return;
        }
        exportValidatedFiles();
      };
    }

    if(viewDifferencesBtn){
      viewDifferencesBtn.onclick=()=>{
        renderDiffs();
        diffViewer?.classList.remove('hidden');
      };
    }

    if(closeDiffBtn){
      closeDiffBtn.onclick=()=>{
        diffViewer?.classList.add('hidden');
      };
    }

    if(autoRepairToggle){
      autoRepairToggle.onchange=()=>{
        if(autoRepairToggle.checked){
          const confirmed = confirm('Auto repair mode will automatically apply safe fixes after each validation run. Continue?');
          if(!confirmed){
            autoRepairToggle.checked=false;
            validationState.autoRepairEnabled=false;
            return;
          }
          validationState.autoRepairEnabled=true;
        } else {
          validationState.autoRepairEnabled=false;
        }
      };
    }

    updateValidationSummary();
    renderValidationLog();
    renderFixList();
    updateValidationControls();
    updateChangelogStatus();

    /* Theme */
    document.getElementById('themeSelect').onchange=()=>{
      const v=document.getElementById('themeSelect').value;
      if(v==='dark'){document.body.classList.add('bg-slate-900','text-slate-100');}
      else{document.body.classList.remove('bg-slate-900','text-slate-100');}
    };

  </script>
</body>
</html>
