<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CompObj Compact Editor</title>
<style>
  body {
    font-family: "Segoe UI", Tahoma, sans-serif;
    font-size: 12px;
    color: #222;
    background: #f5f6f8;
    margin: 0;
    padding: 20px;
  }

  #container {
    max-width: 1200px;
    margin: auto;
    background: #fff;
    border-radius: 6px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    padding: 12px;
  }

  #sheet-tabs {
    display: flex;
    gap: 6px;
    margin-bottom: 10px;
  }

  #sheet-tabs button {
    flex: 0 0 auto;
    border-radius: 6px 6px 0 0;
    border-bottom: none;
    padding: 6px 14px;
    font-weight: 600;
    background: #e9eef5;
  }

  #sheet-tabs button.active {
    background: #fff;
    border-color: #c5d3e3;
    border-bottom: 1px solid #fff;
  }

  #controls {
    border: 1px solid #e3e7ef;
    border-top: none;
    border-radius: 0 6px 6px 6px;
    background: #fff;
    margin-bottom: 10px;
  }

  #controls .control-set {
    display: none;
    align-items: center;
    flex-wrap: wrap;
    gap: 6px;
    padding: 8px;
  }

  #controls .control-set.active {
    display: flex;
  }

  button {
    font-size: 12px;
    border: 1px solid #ccc;
    background: #fff;
    padding: 4px 8px;
    border-radius: 3px;
    cursor: pointer;
    transition: 0.1s;
  }
  button:hover { background: #f2f2f2; }

  input[type="number"] {
    width: 45px;
    font-size: 12px;
    padding: 2px 4px;
    border: 1px solid #ccc;
    border-radius: 3px;
  }

  input[type="file"] { display: none; }

  .validation-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-bottom: 10px;
    flex-wrap: wrap;
  }

  .btn.btn-info {
    background: #e3f2fd;
    border-color: #64b5f6;
    color: #0d47a1;
  }

  .btn.btn-info:hover {
    background: #d0e6fb;
  }

  .validation-toolbar__actions {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .validation-toolbar__toggle {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    color: #444;
  }

  .validation-summary {
    font-size: 12px;
    margin-bottom: 6px;
    color: #1b5e20;
  }

  .validation-summary.has-errors {
    color: #b00020;
  }

  .validation-summary.has-warnings:not(.has-errors) {
    color: #7a6000;
  }

  .validation-status {
    font-size: 12px;
    color: #1f3a93;
    min-height: 16px;
    white-space: pre-line;
  }

  .validation-status.is-error { color: #b00020; }
  .validation-status.is-warning { color: #7a6000; }
  .validation-status.is-success { color: #1b5e20; }

  #validation-panel {
    position: fixed;
    inset: 0;
    background: rgba(24, 32, 54, 0.35);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 40;
  }

  #validation-panel.is-visible {
    display: flex;
  }

  .validation-panel__content {
    background: #fff;
    width: min(640px, 90vw);
    max-height: 80vh;
    border-radius: 8px;
    box-shadow: 0 16px 32px rgba(0,0,0,0.25);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .validation-panel__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-bottom: 1px solid #e4e7ec;
    background: #f5f7fb;
  }

  .validation-panel__header h2 {
    font-size: 16px;
    margin: 0;
    font-weight: 600;
  }

  .validation-panel__body {
    padding: 16px;
    overflow-y: auto;
    font-size: 12px;
    line-height: 1.4;
    color: #222;
  }

  .validation-panel__body section + section {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid #eef1f7;
  }

  .validation-panel__body h3 {
    margin: 0 0 6px;
    font-size: 13px;
  }

  .sheet-summary {
    margin-bottom: 6px;
    font-weight: 600;
    color: #4a5c79;
  }

  .validation-overview {
    list-style: none;
    padding: 0;
    margin: 0 0 12px;
    display: grid;
    gap: 4px;
  }

  .validation-overview li {
    padding: 6px 8px;
    border-radius: 4px;
    border: 1px solid #e3e8f3;
    background: #f7f9fc;
    font-weight: 500;
    color: #344156;
  }

  .validation-overview li.validation-overview__error {
    border-color: rgba(176, 0, 32, 0.35);
    background: rgba(176, 0, 32, 0.08);
    color: #730012;
  }

  .validation-overview li.validation-overview__warning {
    border-color: rgba(122, 96, 0, 0.35);
    background: rgba(255, 197, 61, 0.18);
    color: #5d4500;
  }

  .validation-overview li.validation-overview__success {
    border-color: rgba(27, 94, 32, 0.35);
    background: rgba(200, 255, 214, 0.4);
    color: #1b5e20;
  }

  .issue-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: 4px;
  }

  .issue {
    padding: 6px 8px;
    border-radius: 4px;
    border: 1px solid transparent;
    background: #f4f6fb;
  }

  .issue--error {
    border-color: rgba(176, 0, 32, 0.35);
    background: rgba(176, 0, 32, 0.08);
    color: #730012;
  }

  .issue--warning {
    border-color: rgba(122, 96, 0, 0.35);
    background: rgba(255, 197, 61, 0.18);
    color: #5d4500;
  }

  .issue--ok {
    border-color: rgba(27, 94, 32, 0.35);
    background: rgba(200, 255, 214, 0.4);
    color: #1b5e20;
  }

  .validation-placeholder {
    margin: 0;
    color: #5f6c85;
  }

  .all-clear {
    margin: 0;
    color: #1b5e20;
    font-weight: 500;
  }

  .validation-panel__close {
    border: none;
    background: none;
    font-size: 16px;
    cursor: pointer;
    color: #44516b;
    padding: 4px;
    border-radius: 4px;
  }

  .validation-panel__close:hover {
    background: rgba(0,0,0,0.05);
  }

  .error-row td {
    background-color: rgba(255, 0, 0, 0.25) !important;
  }

  .warning-row td {
    background-color: rgba(255, 255, 0, 0.25) !important;
  }

  .valid-row td {
    background-color: rgba(0, 255, 0, 0.1) !important;
  }

  #lineCount {
    font-size: 12px;
    color: #666;
    margin-bottom: 6px;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
  }

  th, td {
    border: 1px solid #eee;
    padding: 3px 6px;
    height: 24px;
    text-align: left;
    background: #fff;
  }

  th {
    background: #f9fafb;
    font-weight: 600;
    font-size: 12px;
    color: #555;
    position: sticky;
    top: 0;
    z-index: 2;
  }

  td input {
    width: 100%;
    border: none;
    outline: none;
    font: inherit;
    background: transparent;
    padding: 2px 3px;
    height: 20px;
    color: #222;
  }

  td.num input { text-align: center; color: #333; }

  /* Colored side tags */
  tr.stage td:first-child { border-left: 3px solid #90c4ff; }
  tr.group td:first-child { border-left: 3px solid #ffb870; }
  tr.final td:first-child { border-left: 3px solid #bba7ff; }
  tr.schedule-row td:first-child { border-left: 3px solid #86d4ff; }

  tr:hover td { background: #f5faff; }
  tr.selected td { background: #e9f3ff !important; outline: 1px solid #0078d7; }

  td.highlight-auto { background: #e3f1ff !important; transition: background-color 0.3s ease-in-out; }

  #sheet tr:nth-child(even) td { background: #fdf7ef; }

  #table-wrapper {
    height: 85vh;
    overflow-y: auto;
    border-top: 1px solid #eee;
    border-bottom: 1px solid #eee;
  }
</style>
</head>
<body>

  <div id="container">
    <div class="validation-toolbar" id="validation-toolbar">
      <div class="validation-toolbar__actions">
        <button id="validateButton" class="btn btn-info" type="button">Validate Database</button>
        <label class="validation-toolbar__toggle">
          <input type="checkbox" id="autoValidateToggle">
          Auto-validate on edit
        </label>
      </div>
      <div id="validation-status" class="validation-status"></div>
    </div>
    <div id="validation-summary" class="validation-summary"></div>
    <div id="sheet-tabs">
      <button id="tab-compobj" class="active" onclick="setActiveSheet('compobj')">üß© CompObj</button>
      <button id="tab-schedule" onclick="setActiveSheet('schedule')">üìÖ Schedule</button>
      <button id="tab-advancement" onclick="setActiveSheet('advancement')">üèÜ Advancement</button>
      <button id="tab-standings" onclick="setActiveSheet('standings')">üìä Standings</button>
      <button id="tab-settings" onclick="setActiveSheet('settings')">‚öôÔ∏è Settings</button>
      <button id="tab-tasks" onclick="setActiveSheet('tasks')">üß† Tasks</button>
      <button id="tab-weather" onclick="setActiveSheet('weather')">üå¶Ô∏è Weather</button>
      <button id="tab-objectives" onclick="setActiveSheet('objectives')">üéØ Objectives</button>
    </div>
    <div id="controls">
      <div class="control-set active" data-sheet-controls="compobj">
        <button onclick="triggerFileDialog('compobj','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-compobj-import" accept=".txt,.csv" onchange="importFile(event,false,'compobj')">
        <button onclick="triggerFileDialog('compobj','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-compobj-append" accept=".txt,.csv" onchange="importFile(event,true,'compobj')">
        <button onclick="addRow('compobj')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-compobj" min="1" value="1">
        <button onclick="insertRows('compobj','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('compobj','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('compobj')">‚àí Delete Selected</button>
        <button onclick="exportTxt('compobj')">üíæ Export .txt</button>
      </div>
      <div class="control-set" data-sheet-controls="schedule">
        <button onclick="triggerFileDialog('schedule','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-schedule-import" accept=".txt,.csv" onchange="importFile(event,false,'schedule')">
        <button onclick="triggerFileDialog('schedule','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-schedule-append" accept=".txt,.csv" onchange="importFile(event,true,'schedule')">
        <button onclick="addRow('schedule')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-schedule" min="1" value="1">
        <button onclick="insertRows('schedule','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('schedule','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('schedule')">‚àí Delete Selected</button>
        <button onclick="exportTxt('schedule')">üíæ Export .txt</button>
      </div>
      <div class="control-set" data-sheet-controls="advancement">
        <button onclick="triggerFileDialog('advancement','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-advancement-import" accept=".txt,.csv" onchange="importFile(event,false,'advancement')">
        <button onclick="triggerFileDialog('advancement','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-advancement-append" accept=".txt,.csv" onchange="importFile(event,true,'advancement')">
        <button onclick="addRow('advancement')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-advancement" min="1" value="1">
        <button onclick="insertRows('advancement','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('advancement','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('advancement')">‚àí Delete Selected</button>
        <button onclick="exportTxt('advancement')">üíæ Export .txt</button>
      </div>
      <div class="control-set" data-sheet-controls="standings">
        <button onclick="triggerFileDialog('standings','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-standings-import" accept=".txt,.csv" onchange="importFile(event,false,'standings')">
        <button onclick="triggerFileDialog('standings','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-standings-append" accept=".txt,.csv" onchange="importFile(event,true,'standings')">
        <button onclick="addRow('standings')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-standings" min="1" value="1">
        <button onclick="insertRows('standings','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('standings','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('standings')">‚àí Delete Selected</button>
        <button onclick="exportTxt('standings')">üíæ Export .txt</button>
      </div>
      <div class="control-set" data-sheet-controls="settings">
        <button onclick="triggerFileDialog('settings','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-settings-import" accept=".txt,.csv" onchange="importFile(event,false,'settings')">
        <button onclick="triggerFileDialog('settings','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-settings-append" accept=".txt,.csv" onchange="importFile(event,true,'settings')">
        <button onclick="addRow('settings')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-settings" min="1" value="1">
        <button onclick="insertRows('settings','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('settings','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('settings')">‚àí Delete Selected</button>
        <button onclick="exportTxt('settings')">üíæ Export .txt</button>
      </div>
      <div class="control-set" data-sheet-controls="tasks">
        <button onclick="triggerFileDialog('tasks','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-tasks-import" accept=".txt,.csv" onchange="importFile(event,false,'tasks')">
        <button onclick="triggerFileDialog('tasks','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-tasks-append" accept=".txt,.csv" onchange="importFile(event,true,'tasks')">
        <button onclick="addRow('tasks')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-tasks" min="1" value="1">
        <button onclick="insertRows('tasks','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('tasks','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('tasks')">‚àí Delete Selected</button>
        <button onclick="exportTxt('tasks')">üíæ Export .txt</button>
      </div>
      <div class="control-set" data-sheet-controls="weather">
        <button onclick="triggerFileDialog('weather','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-weather-import" accept=".txt,.csv" onchange="importFile(event,false,'weather')">
        <button onclick="triggerFileDialog('weather','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-weather-append" accept=".txt,.csv" onchange="importFile(event,true,'weather')">
        <button onclick="addRow('weather')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-weather" min="1" value="1">
        <button onclick="insertRows('weather','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('weather','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('weather')">‚àí Delete Selected</button>
        <button onclick="exportTxt('weather')">üíæ Export .txt</button>
      </div>
      <div class="control-set" data-sheet-controls="objectives">
        <button onclick="triggerFileDialog('objectives','import')">üìÇ Import .txt</button>
        <input type="file" id="fileInput-objectives-import" accept=".txt,.csv" onchange="importFile(event,false,'objectives')">
        <button onclick="triggerFileDialog('objectives','append')">‚ûï Append .txt</button>
        <input type="file" id="fileInput-objectives-append" accept=".txt,.csv" onchange="importFile(event,true,'objectives')">
        <button onclick="addRow('objectives')">+ Add Row (End)</button>
        <span>| Insert:</span>
        <input type="number" id="insertCount-objectives" min="1" value="1">
        <button onclick="insertRows('objectives','above')">‚Üë Insert Above</button>
        <button onclick="insertRows('objectives','below')">‚Üì Insert Below</button>
        <button onclick="deleteRow('objectives')">‚àí Delete Selected</button>
        <button onclick="exportTxt('objectives')">üíæ Export .txt</button>
      </div>
    </div>

  <div id="lineCount"></div>

  <div id="table-wrapper">
    <table id="sheet"></table>
  </div>
</div>

<div id="validation-panel">
  <div class="validation-panel__content">
    <div class="validation-panel__header">
      <h2>Database Validation</h2>
      <button id="closeValidationPanel" class="validation-panel__close" type="button" aria-label="Close validation panel">‚úï</button>
    </div>
    <div class="validation-panel__body">
      <div id="validationResults"></div>
    </div>
  </div>
</div>

<script>
let compobj = [];
let schedule = [];
let advancement = [];
let standings = [];
let settings = [];
let tasks = [];
let weather = [];
let objectives = [];
let activeSheet = 'compobj';
const selections = { compobj: null, schedule: null, advancement: null, standings: null, settings: null, tasks: null, weather: null, objectives: null };
let tempIdCounter = 0;
const DYNAMIC_TASK_TYPES = new Set(['updatetable', 'fillfromcomptable']);
const TASK_HIGHLIGHT_DURATION = 5000;
const taskHighlightMap = new Map();

function shouldUpdateTaskRefId(taskType) {
  const normalized = (taskType || '').trim().toLowerCase();
  return DYNAMIC_TASK_TYPES.has(normalized);
}

function markTaskHighlight(rowIndex, columnKey) {
  if (!taskHighlightMap.has(rowIndex)) {
    taskHighlightMap.set(rowIndex, { columns: new Set(), timers: new Map() });
  }
  const entry = taskHighlightMap.get(rowIndex);
  if (!entry.columns.has(columnKey)) {
    entry.columns.add(columnKey);
  }
  const timers = entry.timers;
  const existing = timers.get(columnKey);
  if (existing) {
    clearTimeout(existing);
  }
  const timeoutId = setTimeout(() => {
    const current = taskHighlightMap.get(rowIndex);
    if (!current) return;
    current.columns.delete(columnKey);
    current.timers.delete(columnKey);
    if (current.columns.size === 0) {
      taskHighlightMap.delete(rowIndex);
    }
    if (activeSheet === 'tasks') {
      render();
    }
  }, TASK_HIGHLIGHT_DURATION);
  timers.set(columnKey, timeoutId);
}

function clearTaskHighlights() {
  taskHighlightMap.forEach((entry) => {
    entry.timers.forEach((timeoutId) => clearTimeout(timeoutId));
  });
  taskHighlightMap.clear();
}

function safe(value) {
  return (value ?? '').toString()
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function getRowClass(r) {
  if (!r.code && !r.name) return "";
  const code = (r.code || "").toUpperCase();
  const name = (r.name || "").toUpperCase();
  if (code.startsWith("S")) return "stage";
  if (code.startsWith("G")) return "group";
  if (name.includes("FINAL") || name.includes("PLAYOFF")) return "final";
  return "";
}

function createDefaultCompobjRow() {
  return { id: `__temp-${tempIdCounter++}`, depth: 5, code: '', name: '', parentDisplay: '' };
}

function renumberCompobjIds() {
  const idMap = new Map();

  compobj.forEach((row, index) => {
    const oldId = row.id == null ? '' : String(row.id);
    const newId = String(index);
    if (oldId !== '') {
      idMap.set(oldId, newId);
    }
    row.id = newId;
  });

  compobj.forEach((row) => {
    const parent = row.parentDisplay == null ? '' : String(row.parentDisplay);
    if (parent === '') return;
    const mapped = idMap.get(parent);
    if (mapped !== undefined) {
      row.parentDisplay = mapped;
    }
  });

  schedule = schedule.map((row) => {
    const current = row.stageGroupId == null ? '' : String(row.stageGroupId);
    if (current === '') return row;
    const mapped = idMap.get(current);
    if (mapped === undefined) return row;
    return { ...row, stageGroupId: mapped };
  });

  advancement = advancement.map((row) => {
    const source = row.sourceGroupId == null ? '' : String(row.sourceGroupId);
    const target = row.targetGroupId == null ? '' : String(row.targetGroupId);
    const mappedSource = source !== '' ? idMap.get(source) : undefined;
    const mappedTarget = target !== '' ? idMap.get(target) : undefined;
    if (mappedSource === undefined && mappedTarget === undefined) return row;
    return {
      ...row,
      sourceGroupId: mappedSource !== undefined ? mappedSource : row.sourceGroupId,
      targetGroupId: mappedTarget !== undefined ? mappedTarget : row.targetGroupId
    };
  });

  standings = standings.map((row) => {
    const group = row.groupId == null ? '' : String(row.groupId);
    if (group === '') return row;
    const mapped = idMap.get(group);
    if (mapped === undefined) return row;
    return { ...row, groupId: mapped };
  });

  settings = settings.map((row) => {
    const stageGroup = row.stageGroupId == null ? '' : String(row.stageGroupId);
    if (stageGroup === '') return row;
    const mapped = idMap.get(stageGroup);
    if (mapped === undefined) return row;
    return { ...row, stageGroupId: mapped };
  });

  updateWeatherIds(idMap);
  updateTaskIds(idMap);
  updateObjectivesIds(idMap);
}

function updateWeatherIds(idMap) {
  if (weather.length === 0) return;
  weather = weather.map((row) => {
    const nation = row.nationId == null ? '' : String(row.nationId);
    if (nation === '') return row;
    const mapped = idMap.get(nation);
    if (mapped === undefined) return row;
    return { ...row, nationId: mapped };
  });
}

function updateTaskIds(idMap) {
  if (tasks.length === 0) return;
  tasks = tasks.map((row, index) => {
    let nextRow = row;
    let changed = false;

    const trophy = row.trophyId == null ? '' : String(row.trophyId);
    if (trophy !== '') {
      const mappedTrophy = idMap.get(trophy);
      if (mappedTrophy !== undefined && mappedTrophy !== row.trophyId) {
        if (!changed) nextRow = { ...nextRow };
        nextRow.trophyId = mappedTrophy;
        markTaskHighlight(index, 'trophyId');
        changed = true;
      }
    }

    const target = row.targetId == null ? '' : String(row.targetId);
    if (target !== '') {
      const mappedTarget = idMap.get(target);
      if (mappedTarget !== undefined && mappedTarget !== row.targetId) {
        if (!changed) nextRow = { ...nextRow };
        nextRow.targetId = mappedTarget;
        markTaskHighlight(index, 'targetId');
        changed = true;
      }
    }

    const reference = row.refId == null ? '' : String(row.refId);
    if (reference !== '' && shouldUpdateTaskRefId(row.taskType)) {
      const mappedReference = idMap.get(reference);
      if (mappedReference !== undefined && mappedReference !== row.refId) {
        if (!changed) nextRow = { ...nextRow };
        nextRow.refId = mappedReference;
        markTaskHighlight(index, 'refId');
        changed = true;
      }
    }

    return changed ? nextRow : row;
  });
}

function updateObjectivesIds(idMap) {
  if (!idMap || !(idMap instanceof Map) || objectives.length === 0) return;
  objectives = objectives.map((row) => {
    const current = row.stageGroupId == null ? '' : String(row.stageGroupId);
    if (current === '') return row;
    const mapped = idMap.get(current);
    if (mapped === undefined || mapped === current) return row;
    return { ...row, stageGroupId: mapped };
  });
}

function syncTasksForManualIdChange(previous, next) {
  if (tasks.length === 0) return;
  const prevValue = previous == null ? '' : String(previous);
  const nextValue = next == null ? '' : String(next);
  if (prevValue === nextValue) return;

  tasks = tasks.map((row, index) => {
    let nextRow = row;
    let changed = false;

    const trophy = row.trophyId == null ? '' : String(row.trophyId);
    if (trophy === prevValue) {
      if (!changed) nextRow = { ...nextRow };
      nextRow.trophyId = nextValue;
      markTaskHighlight(index, 'trophyId');
      changed = true;
    }

    const target = row.targetId == null ? '' : String(row.targetId);
    if (target === prevValue) {
      if (!changed) nextRow = { ...nextRow };
      nextRow.targetId = nextValue;
      markTaskHighlight(index, 'targetId');
      changed = true;
    }

    const reference = row.refId == null ? '' : String(row.refId);
    if (reference === prevValue && shouldUpdateTaskRefId(row.taskType)) {
      if (!changed) nextRow = { ...nextRow };
      nextRow.refId = nextValue;
      markTaskHighlight(index, 'refId');
      changed = true;
    }

    return changed ? nextRow : row;
  });
}

function syncReferencesForManualIdChange(oldValue, newValue) {
  const previous = oldValue == null ? '' : String(oldValue);
  const next = newValue == null ? '' : String(newValue);
  if (previous === next) return;

  compobj.forEach((row) => {
    const parent = row.parentDisplay == null ? '' : String(row.parentDisplay);
    if (parent === previous) {
      row.parentDisplay = next;
    }
  });

  schedule = schedule.map((row) => {
    const current = row.stageGroupId == null ? '' : String(row.stageGroupId);
    if (current !== previous) return row;
    return { ...row, stageGroupId: next };
  });

  advancement = advancement.map((row) => {
    const source = row.sourceGroupId == null ? '' : String(row.sourceGroupId);
    const target = row.targetGroupId == null ? '' : String(row.targetGroupId);
    let changed = false;
    let newSource = row.sourceGroupId;
    let newTarget = row.targetGroupId;
    if (source === previous) {
      newSource = next;
      changed = true;
    }
    if (target === previous) {
      newTarget = next;
      changed = true;
    }
    return changed ? { ...row, sourceGroupId: newSource, targetGroupId: newTarget } : row;
  });

  standings = standings.map((row) => {
    const group = row.groupId == null ? '' : String(row.groupId);
    if (group !== previous) return row;
    return { ...row, groupId: next };
  });

  settings = settings.map((row) => {
    const stageGroup = row.stageGroupId == null ? '' : String(row.stageGroupId);
    if (stageGroup !== previous) return row;
    return { ...row, stageGroupId: next };
  });

  weather = weather.map((row) => {
    const nation = row.nationId == null ? '' : String(row.nationId);
    if (nation !== previous) return row;
    return { ...row, nationId: next };
  });

  objectives = objectives.map((row) => {
    const stageGroup = row.stageGroupId == null ? '' : String(row.stageGroupId);
    if (stageGroup !== previous) return row;
    return { ...row, stageGroupId: next };
  });

  syncTasksForManualIdChange(previous, next);
}

function renderObjectivesTable() {
  return `
      <tr>
        <th style="width:40px;">#</th>
        <th style="width:130px;">Stage/Group ID</th>
        <th>Objective Type</th>
        <th style="width:90px;">Value</th>
      </tr>
      ${objectives.map((row, index) => `
        <tr data-row-index="${index}" class="${selections.objectives===index?'selected':''}" onclick="selectRow(${index})">
          <td class="num">${index + 1}</td>
          <td class="num"><input value="${safe(row.stageGroupId)}" oninput="updateField(${index},'stageGroupId',this.value)"></td>
          <td><input value="${safe(row.objectiveType)}" oninput="updateField(${index},'objectiveType',this.value)"></td>
          <td class="num"><input value="${safe(row.value)}" oninput="updateField(${index},'value',this.value)"></td>
        </tr>
      `).join("")}`;
}

function render() {
  const table = document.getElementById("sheet");
  const lineCount = document.getElementById("lineCount");
  document.getElementById('tab-compobj').classList.toggle('active', activeSheet === 'compobj');
  document.getElementById('tab-schedule').classList.toggle('active', activeSheet === 'schedule');
  document.getElementById('tab-advancement').classList.toggle('active', activeSheet === 'advancement');
  document.getElementById('tab-standings').classList.toggle('active', activeSheet === 'standings');
  document.getElementById('tab-settings').classList.toggle('active', activeSheet === 'settings');
  document.getElementById('tab-tasks').classList.toggle('active', activeSheet === 'tasks');
  document.getElementById('tab-weather').classList.toggle('active', activeSheet === 'weather');
  document.getElementById('tab-objectives').classList.toggle('active', activeSheet === 'objectives');
  updateControlVisibility();

  let countLabel = '';
  if (activeSheet === 'compobj') {
    countLabel = `CompObj: ${compobj.length} lines parsed`;
  } else if (activeSheet === 'schedule') {
    countLabel = `Schedule: ${schedule.length} entries parsed`;
  } else if (activeSheet === 'advancement') {
    countLabel = `Advancement: ${advancement.length} links parsed`;
  } else if (activeSheet === 'standings') {
    countLabel = `Standings: ${standings.length} slots parsed`;
  } else if (activeSheet === 'objectives') {
    countLabel = `Objectives: ${objectives.length} goals parsed`;
  } else if (activeSheet === 'weather') {
    countLabel = `Weather: ${weather.length} rows parsed`;
  } else if (activeSheet === 'tasks') {
    countLabel = `Tasks: ${tasks.length} automation rows parsed`;
  } else {
    countLabel = `Settings: ${settings.length} entries parsed`;
  }
  lineCount.textContent = countLabel;

  if (activeSheet === 'compobj') {
    table.innerHTML = `
      <tr>
        <th style="width:32px;">#</th>
        <th style="width:70px;">ID</th>
        <th style="width:60px;">Level</th>
        <th style="width:80px;">Code</th>
        <th>Name</th>
        <th style="width:70px;">Parent</th>
      </tr>
      ${compobj.map((r, i) => `
        <tr data-row-index="${i}" class="${getRowClass(r)} ${selections.compobj===i?'selected':''}" onclick="selectRow(${i})">
          <td class="num">${i+1}</td>
          <td class="num"><input value="${safe(r.id)}" oninput="updateField(${i},'id',this.value)"></td>
          <td class="num"><input value="${safe(r.depth)}" oninput="updateField(${i},'depth',this.value)"></td>
          <td><input value="${safe(r.code)}" oninput="updateField(${i},'code',this.value)"></td>
          <td><input value="${safe(r.name)}" oninput="updateField(${i},'name',this.value)"></td>
          <td class="num"><input value="${safe(r.parentDisplay)}" oninput="updateField(${i},'parentDisplay',this.value)"></td>
        </tr>
      `).join("")}`;
  } else if (activeSheet === 'schedule') {
    table.innerHTML = `
      <tr>
        <th style="width:40px;">#</th>
        <th style="width:110px;">Stage/Group ID</th>
        <th style="width:80px;">Day ID</th>
        <th style="width:90px;">Matchday</th>
        <th style="width:100px;">Min Matches</th>
        <th style="width:100px;">Max Matches</th>
        <th style="width:80px;">Time</th>
      </tr>
      ${schedule.map((r, i) => `
        <tr data-row-index="${i}" class="schedule-row ${selections.schedule===i?'selected':''}" onclick="selectRow(${i})">
          <td class="num">${i+1}</td>
          <td class="num"><input value="${safe(r.stageGroupId)}" oninput="updateField(${i},'stageGroupId',this.value)"></td>
          <td class="num"><input value="${safe(r.dayId)}" oninput="updateField(${i},'dayId',this.value)"></td>
          <td class="num"><input value="${safe(r.matchday)}" oninput="updateField(${i},'matchday',this.value)"></td>
          <td class="num"><input value="${safe(r.minMatches)}" oninput="updateField(${i},'minMatches',this.value)"></td>
          <td class="num"><input value="${safe(r.maxMatches)}" oninput="updateField(${i},'maxMatches',this.value)"></td>
          <td class="num"><input value="${safe(r.time)}" oninput="updateField(${i},'time',this.value)"></td>
        </tr>
      `).join("")}`;
  } else if (activeSheet === 'advancement') {
    table.innerHTML = `
      <tr>
        <th style="width:40px;">#</th>
        <th style="width:110px;">Source Group ID</th>
        <th style="width:90px;">Placement</th>
        <th style="width:120px;">Target Group ID</th>
        <th style="width:100px;">Team Count</th>
      </tr>
      ${advancement.map((r, i) => `
        <tr data-row-index="${i}" class="${selections.advancement===i?'selected':''}" onclick="selectRow(${i})">
          <td class="num">${i+1}</td>
          <td class="num"><input value="${safe(r.sourceGroupId)}" oninput="updateField(${i},'sourceGroupId',this.value)"></td>
          <td class="num"><input value="${safe(r.placement)}" oninput="updateField(${i},'placement',this.value)"></td>
          <td class="num"><input value="${safe(r.targetGroupId)}" oninput="updateField(${i},'targetGroupId',this.value)"></td>
          <td class="num"><input value="${safe(r.teamCount)}" oninput="updateField(${i},'teamCount',this.value)"></td>
        </tr>
      `).join("")}`;
  } else if (activeSheet === 'standings') {
    table.innerHTML = `
      <tr>
        <th style="width:40px;">#</th>
        <th style="width:110px;">Group ID</th>
        <th style="width:110px;">Slot Number</th>
      </tr>
      ${standings.map((r, i) => `
        <tr data-row-index="${i}" class="${selections.standings===i?'selected':''}" onclick="selectRow(${i})">
          <td class="num">${i+1}</td>
          <td class="num"><input value="${safe(r.groupId)}" oninput="updateField(${i},'groupId',this.value)"></td>
          <td class="num"><input value="${safe(r.slotNumber)}" oninput="updateField(${i},'slotNumber',this.value)"></td>
        </tr>
      `).join("")}`;
  } else if (activeSheet === 'tasks') {
    table.innerHTML = `
      <tr>
        <th style="width:40px;">#</th>
        <th style="width:120px;">Trophy ID</th>
        <th style="width:90px;">Task Phase</th>
        <th style="width:150px;">Task Type</th>
        <th style="width:120px;">Target ID</th>
        <th style="width:120px;">Reference ID</th>
        <th style="width:80px;">Arg1</th>
        <th style="width:80px;">Arg2</th>
      </tr>
      ${tasks.map((r, i) => {
        const highlight = taskHighlightMap.get(i);
        const columns = highlight ? highlight.columns : null;
        const trophyClass = columns && columns.has('trophyId') ? 'highlight-auto' : '';
        const targetClass = columns && columns.has('targetId') ? 'highlight-auto' : '';
        const refClass = columns && columns.has('refId') ? 'highlight-auto' : '';
        return `
        <tr data-row-index="${i}" class="${selections.tasks===i?'selected':''}" onclick="selectRow(${i})">
          <td class="num">${i+1}</td>
          <td class="num ${trophyClass}"><input value="${safe(r.trophyId)}" oninput="updateField(${i},'trophyId',this.value)"></td>
          <td><input value="${safe(r.phase)}" oninput="updateField(${i},'phase',this.value)"></td>
          <td><input value="${safe(r.taskType)}" oninput="updateField(${i},'taskType',this.value)"></td>
          <td class="num ${targetClass}"><input value="${safe(r.targetId)}" oninput="updateField(${i},'targetId',this.value)"></td>
          <td class="num ${refClass}"><input value="${safe(r.refId)}" oninput="updateField(${i},'refId',this.value)"></td>
          <td class="num"><input value="${safe(r.arg1)}" oninput="updateField(${i},'arg1',this.value)"></td>
          <td class="num"><input value="${safe(r.arg2)}" oninput="updateField(${i},'arg2',this.value)"></td>
        </tr>`;
      }).join("")}`;
  } else if (activeSheet === 'weather') {
    table.innerHTML = `
      <tr>
        <th style="width:40px;">#</th>
        <th style="width:110px;">Nation ID</th>
        <th style="width:70px;">Entry</th>
        <th style="width:80px;">Temp</th>
        <th style="width:80px;">Cloud</th>
        <th style="width:80px;">Rain</th>
        <th style="width:80px;">Snow</th>
        <th style="width:80px;">Wind</th>
        <th style="width:90px;">Start</th>
        <th style="width:90px;">End</th>
      </tr>
      ${weather.map((r, i) => `
        <tr data-row-index="${i}" class="${selections.weather===i?'selected':''}" onclick="selectRow(${i})">
          <td class="num">${i+1}</td>
          <td class="num"><input value="${safe(r.nationId)}" oninput="updateField(${i},'nationId',this.value)"></td>
          <td class="num"><input value="${safe(r.entry)}" oninput="updateField(${i},'entry',this.value)"></td>
          <td class="num"><input value="${safe(r.temp)}" oninput="updateField(${i},'temp',this.value)"></td>
          <td class="num"><input value="${safe(r.cloud)}" oninput="updateField(${i},'cloud',this.value)"></td>
          <td class="num"><input value="${safe(r.rain)}" oninput="updateField(${i},'rain',this.value)"></td>
          <td class="num"><input value="${safe(r.snow)}" oninput="updateField(${i},'snow',this.value)"></td>
          <td class="num"><input value="${safe(r.wind)}" oninput="updateField(${i},'wind',this.value)"></td>
          <td class="num"><input value="${safe(r.start)}" oninput="updateField(${i},'start',this.value)"></td>
        <td class="num"><input value="${safe(r.end)}" oninput="updateField(${i},'end',this.value)"></td>
      </tr>
      `).join("")}`;
  } else if (activeSheet === 'objectives') {
    table.innerHTML = renderObjectivesTable();
  } else {
    table.innerHTML = `
      <tr>
        <th style="width:40px;">#</th>
        <th style="width:110px;">Stage/Group ID</th>
        <th>Setting Key</th>
        <th>Setting Value</th>
      </tr>
      ${settings.map((r, i) => `
        <tr data-row-index="${i}" class="${selections.settings===i?'selected':''}" onclick="selectRow(${i})">
          <td class="num">${i+1}</td>
          <td class="num"><input value="${safe(r.stageGroupId)}" oninput="updateField(${i},'stageGroupId',this.value)"></td>
          <td><input value="${safe(r.key)}" oninput="updateField(${i},'key',this.value)"></td>
          <td><input value="${safe(r.value)}" oninput="updateField(${i},'value',this.value)"></td>
        </tr>
      `).join("")}`;
  }

  setupTableInteractions(table);
}

function setupTableInteractions(tableElement) {
  if (!tableElement) return;

  highlightSelection();

  const interactiveElements = tableElement.querySelectorAll('input, select, textarea, button');
  interactiveElements.forEach((element) => {
    const stop = (event) => event.stopPropagation();
    element.addEventListener('pointerdown', stop);
    element.addEventListener('mousedown', stop);
    element.addEventListener('click', stop);
    element.addEventListener('focus', () => {
      const row = element.closest('tr[data-row-index]');
      if (!row) return;
      const index = Number.parseInt(row.dataset.rowIndex, 10);
      focusRow(index);
    });
  });
}

function highlightSelection() {
  const tableElement = document.getElementById('sheet');
  if (!tableElement) return;
  const rows = tableElement.querySelectorAll('tr[data-row-index]');
  rows.forEach((row) => {
    const index = Number.parseInt(row.dataset.rowIndex, 10);
    const isSelected = selections[activeSheet] === index;
    row.classList.toggle('selected', isSelected);
  });
}

function focusRow(index) {
  if (typeof index !== 'number' || Number.isNaN(index)) return;
  selections[activeSheet] = index;
  highlightSelection();
}

function setActiveSheet(sheet) {
  if (sheet === activeSheet) return;
  activeSheet = sheet;
  render();
}

function selectRow(i) {
  if (selections[activeSheet] === i) {
    highlightSelection();
    return;
  }
  selections[activeSheet] = i;
  render();
}

function getDataArray(sheet) {
  if (sheet === 'compobj') return compobj;
  if (sheet === 'schedule') return schedule;
  if (sheet === 'advancement') return advancement;
  if (sheet === 'standings') return standings;
  if (sheet === 'objectives') return objectives;
  if (sheet === 'tasks') return tasks;
  if (sheet === 'weather') return weather;
  return settings;
}

function updateField(i, field, value) {
  const target = getDataArray(activeSheet);
  if (!target[i]) return;
  const previousValue = target[i][field];
  target[i][field] = value;
  if (activeSheet === 'compobj' && field === 'id') {
    syncReferencesForManualIdChange(previousValue, value);
  }
}

function getSelectedIndex(sheet = activeSheet) {
  return selections[sheet];
}

function defaultRowForSheet(sheet) {
  if (sheet === 'compobj') {
    return createDefaultCompobjRow();
  }
  if (sheet === 'schedule') {
    return { stageGroupId: '', dayId: '', matchday: '', minMatches: '', maxMatches: '', time: '' };
  }
  if (sheet === 'advancement') {
    return { sourceGroupId: '', placement: '', targetGroupId: '', teamCount: '' };
  }
  if (sheet === 'standings') {
    return { groupId: '', slotNumber: '' };
  }
  if (sheet === 'objectives') {
    return { stageGroupId: '', objectiveType: '', value: '' };
  }
  if (sheet === 'tasks') {
    return { trophyId: '', phase: '', taskType: '', targetId: '', refId: '', arg1: '', arg2: '' };
  }
  if (sheet === 'weather') {
    return { nationId: '', entry: '', temp: '', cloud: '', rain: '', snow: '', wind: '', start: '', end: '' };
  }
  return { stageGroupId: '', key: '', value: '' };
}

function addRow(sheet = activeSheet) {
  if (sheet === 'compobj') {
    compobj.push(createDefaultCompobjRow());
    renumberCompobjIds();
  } else if (sheet === 'schedule') {
    schedule.push(defaultRowForSheet(sheet));
  } else if (sheet === 'advancement') {
    advancement.push(defaultRowForSheet(sheet));
  } else if (sheet === 'standings') {
    standings.push(defaultRowForSheet(sheet));
  } else if (sheet === 'objectives') {
    objectives.push(defaultRowForSheet(sheet));
  } else if (sheet === 'tasks') {
    clearTaskHighlights();
    tasks.push(defaultRowForSheet(sheet));
  } else if (sheet === 'weather') {
    weather.push(defaultRowForSheet(sheet));
  } else {
    settings.push(defaultRowForSheet(sheet));
  }
  render();
}

function triggerFileDialog(sheet, type) {
  const input = document.getElementById(`fileInput-${sheet}-${type}`);
  input.value = '';
  input.click();
}

function insertRows(sheet, position) {
  const selected = getSelectedIndex(sheet);
  if (selected === null) return alert('Select a row first.');
  const insertInput = document.getElementById(`insertCount-${sheet}`);
  const count = parseInt(insertInput.value, 10) || 1;
  const newRows = Array.from({ length: count }, () => ({ ...defaultRowForSheet(sheet) }));

  if (sheet === 'compobj') {
    const index = position === 'above' ? selected : selected + 1;
    compobj.splice(index, 0, ...newRows);
    renumberCompobjIds();
  } else if (sheet === 'schedule') {
    const index = position === 'above' ? selected : selected + 1;
    schedule.splice(index, 0, ...newRows);
  } else if (sheet === 'advancement') {
    const index = position === 'above' ? selected : selected + 1;
    advancement.splice(index, 0, ...newRows);
  } else if (sheet === 'standings') {
    const index = position === 'above' ? selected : selected + 1;
    standings.splice(index, 0, ...newRows);
  } else if (sheet === 'objectives') {
    const index = position === 'above' ? selected : selected + 1;
    objectives.splice(index, 0, ...newRows);
  } else if (sheet === 'tasks') {
    clearTaskHighlights();
    const index = position === 'above' ? selected : selected + 1;
    tasks.splice(index, 0, ...newRows);
  } else if (sheet === 'weather') {
    const index = position === 'above' ? selected : selected + 1;
    weather.splice(index, 0, ...newRows);
  } else {
    const index = position === 'above' ? selected : selected + 1;
    settings.splice(index, 0, ...newRows);
  }
  render();
}

function deleteRow(sheet = activeSheet) {
  const selected = getSelectedIndex(sheet);
  if (selected === null) return alert('Select a row first.');
  if (sheet === 'compobj') {
    compobj.splice(selected, 1);
    selections.compobj = null;
    renumberCompobjIds();
  } else if (sheet === 'schedule') {
    schedule.splice(selected, 1);
    selections.schedule = null;
  } else if (sheet === 'advancement') {
    advancement.splice(selected, 1);
    selections.advancement = null;
  } else if (sheet === 'standings') {
    standings.splice(selected, 1);
    selections.standings = null;
  } else if (sheet === 'tasks') {
    clearTaskHighlights();
    tasks.splice(selected, 1);
    selections.tasks = null;
  } else if (sheet === 'weather') {
    weather.splice(selected, 1);
    selections.weather = null;
  } else if (sheet === 'objectives') {
    objectives.splice(selected, 1);
    selections.objectives = null;
  } else {
    settings.splice(selected, 1);
    selections.settings = null;
  }
  render();
}

function exportTxt(sheet = activeSheet) {
  const activeData = getDataArray(sheet);
  let lines = '';
  let filename = '';
  if (sheet === 'compobj') {
    lines = activeData.map(r => `${r.id},${r.depth},${r.code},${r.name},${r.parentDisplay}`).join('\n');
    filename = 'compobj.txt';
  } else if (sheet === 'schedule') {
    lines = activeData.map(r => `${r.stageGroupId},${r.dayId},${r.matchday},${r.minMatches},${r.maxMatches},${r.time}`).join('\n');
    filename = 'schedule.txt';
  } else if (sheet === 'advancement') {
    lines = activeData.map(r => `${r.sourceGroupId},${r.placement},${r.targetGroupId},${r.teamCount}`).join('\n');
    filename = 'advancement.txt';
  } else if (sheet === 'standings') {
    lines = activeData.map(r => `${r.groupId},${r.slotNumber}`).join('\n');
    filename = 'standings.txt';
  } else if (sheet === 'objectives') {
    lines = activeData.map(r => `${r.stageGroupId},${r.objectiveType},${r.value}`).join('\n');
    filename = 'objectives.txt';
  } else if (sheet === 'weather') {
    lines = activeData.map(r => `${r.nationId},${r.entry},${r.temp},${r.cloud},${r.rain},${r.snow},${r.wind},${r.start},${r.end}`).join('\n');
    filename = 'weather.txt';
  } else if (sheet === 'tasks') {
    lines = activeData.map(r => `${r.trophyId},${r.phase},${r.taskType},${r.targetId},${r.refId},${r.arg1},${r.arg2}`).join('\n');
    filename = 'tasks.txt';
  } else {
    lines = activeData.map(r => `${r.stageGroupId},${r.key},${r.value}`).join('\n');
    filename = 'settings.txt';
  }
  const blob = new Blob([lines], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}

function importFile(e, append = false, sheetOverride = null) {
  const f = e.target.files[0];
  const sheetTarget = sheetOverride || e.target.dataset.sheet || activeSheet;
  if (!f) return;
  const r = new FileReader();
  r.onload = function (ev) {
    const lines = ev.target.result.split(/\r?\n/).filter(l => l.trim() !== '');
    if (sheetTarget === 'compobj') {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          id: p[0] || '',
          depth: p[1] || '',
          code: p[2] || '',
          name: p[3] || '',
          parentDisplay: p[4] || ''
        };
      });
      compobj = append ? [...compobj, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
      renumberCompobjIds();
    } else if (sheetTarget === 'schedule') {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          stageGroupId: p[0] || '',
          dayId: p[1] || '',
          matchday: p[2] || '',
          minMatches: p[3] || '',
          maxMatches: p[4] || '',
          time: p[5] || ''
        };
      });
      schedule = append ? [...schedule, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
    } else if (sheetTarget === 'advancement') {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          sourceGroupId: p[0] || '',
          placement: p[1] || '',
          targetGroupId: p[2] || '',
          teamCount: p[3] || ''
        };
      });
      advancement = append ? [...advancement, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
    } else if (sheetTarget === 'standings') {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          groupId: p[0] || '',
          slotNumber: p[1] || ''
        };
      });
      standings = append ? [...standings, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
    } else if (sheetTarget === 'objectives') {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          stageGroupId: p[0] || '',
          objectiveType: p[1] || '',
          value: p[2] || ''
        };
      });
      objectives = append ? [...objectives, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
    } else if (sheetTarget === 'weather') {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          nationId: p[0] || '',
          entry: p[1] || '',
          temp: p[2] || '',
          cloud: p[3] || '',
          rain: p[4] || '',
          snow: p[5] || '',
          wind: p[6] || '',
          start: p[7] || '',
          end: p[8] || ''
        };
      });
      weather = append ? [...weather, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
    } else if (sheetTarget === 'tasks') {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          trophyId: p[0] || '',
          phase: p[1] || '',
          taskType: p[2] || '',
          targetId: p[3] || '',
          refId: p[4] || '',
          arg1: p[5] || '',
          arg2: p[6] || ''
        };
      });
      clearTaskHighlights();
      tasks = append ? [...tasks, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
    } else {
      const parsed = lines.map(l => {
        const p = l.split(/\t|,/);
        return {
          stageGroupId: p[0] || '',
          key: p[1] || '',
          value: p.slice(2).join(',') || ''
        };
      });
      settings = append ? [...settings, ...parsed] : parsed;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
    }
    render();
  };
  r.readAsText(f);
}

const COLUMN_CONFIG = {
  compobj: { columns: 5, displayName: 'compobj.txt', fieldNames: ['id', 'depth', 'code', 'name', 'parentDisplay'] },
  schedule: { columns: 6, displayName: 'schedule.txt', fieldNames: ['stageGroupId', 'dayId', 'matchday', 'minMatches', 'maxMatches', 'time'] },
  advancement: { columns: 4, displayName: 'advancement.txt', fieldNames: ['sourceGroupId', 'placement', 'targetGroupId', 'teamCount'] },
  standings: { columns: 2, displayName: 'standings.txt', fieldNames: ['groupId', 'slotNumber'] },
  settings: { columns: 3, displayName: 'settings.txt', fieldNames: ['stageGroupId', 'key', 'value'] },
  tasks: { columns: 7, displayName: 'tasks.txt', fieldNames: ['trophyId', 'phase', 'taskType', 'targetId', 'refId', 'arg1', 'arg2'] },
  weather: { columns: 9, displayName: 'weather.txt', fieldNames: ['nationId', 'entry', 'temp', 'cloud', 'rain', 'snow', 'wind', 'start', 'end'] },
  objectives: { columns: 3, displayName: 'objectives.txt', fieldNames: ['stageGroupId', 'objectiveType', 'value'] }
};

const SHEET_ORDER = ['compobj', 'schedule', 'advancement', 'standings', 'settings', 'tasks', 'weather', 'objectives'];

const LEVEL_NAMES = {
  0: 'FIFA Root',
  1: 'Confederation',
  2: 'Nation',
  3: 'Competition/Trophy',
  4: 'Stage',
  5: 'Group',
  6: 'Custom Entry'
};

const LEVEL_PARENT_HINT = {
  1: 'Confederations must reference the FIFA root (level 0).',
  2: 'Nations must reference a Confederation (level 1).',
  3: 'Competitions must reference a Nation (level 2).',
  4: 'Stages must reference a Competition/Trophy (level 3).',
  5: 'Groups must only point to a Stage (level 4).',
  6: 'Custom entries must reference a Nation or Competition (levels 2-3).'
};

const PARENT_LEVEL_RULES = {
  0: [],
  1: [0],
  2: [1],
  3: [2],
  4: [3],
  5: [4],
  6: [2, 3]
};

const CROSS_REFERENCE_RULES = {
  schedule: [
    { field: 'stageGroupId', label: 'Stage/Group ID', allowedLevels: [4, 5], required: true }
  ],
  advancement: [
    { field: 'sourceGroupId', label: 'Source Group ID', allowedLevels: [4, 5], required: true },
    { field: 'targetGroupId', label: 'Target Group ID', allowedLevels: [4, 5], required: true }
  ],
  standings: [
    { field: 'groupId', label: 'Group ID', allowedLevels: [4, 5], required: true }
  ],
  settings: [
    { field: 'stageGroupId', label: 'Stage/Nation ID', allowedLevels: [2, 4], required: true }
  ],
  tasks: [
    { field: 'trophyId', label: 'Trophy ID', allowedLevels: [3], required: true },
    { field: 'targetId', label: 'Target ID', allowedLevels: [4, 5], required: true },
    {
      field: 'refId',
      label: 'Reference ID',
      allowedLevels: [4, 5],
      required: (row) => shouldUpdateTaskRefId(row.taskType),
      conditional: (row) => shouldUpdateTaskRefId(row.taskType)
    }
  ],
  weather: [
    { field: 'nationId', label: 'Nation ID', allowedLevels: [2], required: true }
  ],
  objectives: [
    { field: 'stageGroupId', label: 'Stage/Group ID', allowedLevels: [4, 5], required: true }
  ]
};

const SEVERITY_RANK = { ok: 0, warning: 1, error: 2 };
const SEVERITY_CLASS = { ok: 'valid-row', warning: 'warning-row', error: 'error-row' };
const AUTO_VALIDATE_DELAY = 600;

const validateButton = document.getElementById('validateButton');
const validationSummaryEl = document.getElementById('validation-summary');
const validationStatusEl = document.getElementById('validation-status');
const validationPanelEl = document.getElementById('validation-panel');
const validationResultsEl = document.getElementById('validationResults');
const autoValidateToggle = document.getElementById('autoValidateToggle');
const closeValidationPanelBtn = document.getElementById('closeValidationPanel');

let validationState = null;
let autoValidateEnabled = false;
let autoValidateTimer = null;

const sheetMetadata = {};
SHEET_ORDER.forEach((sheet) => {
  sheetMetadata[sheet] = { detectedBom: false, lastLineEnding: 'ui' };
});

function ensureSheetMetadata(sheet) {
  if (!sheetMetadata[sheet]) {
    sheetMetadata[sheet] = { detectedBom: false, lastLineEnding: 'ui' };
  }
  return sheetMetadata[sheet];
}

function attachRowMeta(row, sheet, overrides = {}) {
  if (!row || typeof row !== 'object') return;
  const spec = COLUMN_CONFIG[sheet] || {};
  const current = row.__meta || {};
  const next = {
    sheet,
    fieldCount: overrides.fieldCount ?? current.fieldCount ?? spec.columns ?? 0,
    separatorType: overrides.separatorType ?? current.separatorType ?? 'ui',
    blankLine: overrides.blankLine ?? current.blankLine ?? false,
    rawLine: overrides.rawLine ?? current.rawLine ?? '',
    lineEnding: overrides.lineEnding ?? current.lineEnding ?? null
  };
  Object.defineProperty(row, '__meta', {
    value: next,
    enumerable: false,
    configurable: true,
    writable: true
  });
}

function markRowEdited(sheet, row) {
  if (!row) return;
  attachRowMeta(row, sheet, {
    fieldCount: COLUMN_CONFIG[sheet]?.columns ?? getRowFields(sheet, row).length,
    separatorType: 'ui',
    blankLine: isRowBlank(sheet, row),
    rawLine: ''
  });
}

function markSheetDirty(sheet) {
  const meta = ensureSheetMetadata(sheet);
  meta.lastLineEnding = 'ui';
  meta.detectedBom = false;
}

function getRowFields(sheet, row) {
  const spec = COLUMN_CONFIG[sheet];
  if (!spec) return [];
  const target = row || {};
  return spec.fieldNames.map((fieldName) => {
    const value = target[fieldName];
    return value == null ? '' : value;
  });
}

function isRowBlank(sheet, row) {
  return getRowFields(sheet, row).every((value) => String(value ?? '').trim() === '');
}

function padFields(rawFields, expected) {
  const result = rawFields.slice(0, expected);
  while (result.length < expected) {
    result.push('');
  }
  return result;
}

function splitLine(rawLine, expectedColumns) {
  const line = rawLine ?? '';
  const hasTab = line.includes('\t');
  const hasComma = line.includes(',');
  if (hasTab && hasComma) {
    return { fields: line.split(/[\t,]/), separatorType: 'mixed' };
  }
  if (hasTab) {
    return { fields: line.split('\t'), separatorType: 'tab' };
  }
  if (hasComma) {
    return { fields: line.split(','), separatorType: 'comma' };
  }
  const trimmed = line.trim();
  if (trimmed === '') {
    return { fields: [''], separatorType: 'none' };
  }
  const spaceFields = trimmed.split(/\s+/);
  if (spaceFields.length > 1) {
    return { fields: spaceFields, separatorType: 'space' };
  }
  return { fields: [line], separatorType: 'none' };
}

function convertFieldsToRow(sheet, rawFields) {
  const spec = COLUMN_CONFIG[sheet];
  if (!spec) return {};
  if (sheet === 'settings') {
    const stageGroupId = rawFields[0] ?? '';
    const key = rawFields[1] ?? '';
    const value = rawFields.length > 2 ? rawFields.slice(2).join(',') : (rawFields[2] ?? '');
    return { stageGroupId, key, value };
  }
  const padded = padFields(rawFields, spec.columns);
  const row = {};
  spec.fieldNames.forEach((fieldName, index) => {
    row[fieldName] = padded[index] ?? '';
  });
  return row;
}

function parseFileContent(content, sheet) {
  const text = typeof content === 'string' ? content : '';
  const usesCRLF = /\r\n/.test(text);
  const usesCR = /\r(?!\n)/.test(text);
  const lines = text.split(/\r\n|\n|\r/);
  const rows = [];
  let detectedBom = false;

  lines.forEach((originalLine, index) => {
    let line = originalLine;
    if (index === 0 && line.charCodeAt(0) === 0xFEFF) {
      detectedBom = true;
      line = line.slice(1);
    }
    const { fields, separatorType } = splitLine(line, COLUMN_CONFIG[sheet]?.columns ?? 0);
    const row = convertFieldsToRow(sheet, fields);
    attachRowMeta(row, sheet, {
      fieldCount: fields.length,
      separatorType,
      blankLine: line.trim() === '',
      rawLine: line
    });
    rows.push(row);
  });

  const lineEnding = usesCRLF ? 'crlf' : (usesCR ? 'cr' : 'lf');

  return { rows, detectedBom, lineEnding };
}

function severityIcon(severity) {
  if (severity === 'error') return '‚ùå';
  if (severity === 'warning') return '‚ö†Ô∏è';
  return '‚úÖ';
}

function escapeHtml(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function recordIssue(sheetResult, severity, message, rowIndex = null) {
  sheetResult.issues.push({ severity, message });
  if (severity === 'error') {
    sheetResult.errorCount += 1;
  } else if (severity === 'warning') {
    sheetResult.warningCount += 1;
  }
  if (typeof rowIndex === 'number') {
    const current = sheetResult.rowStatus.get(rowIndex);
    if (!current || SEVERITY_RANK[severity] > SEVERITY_RANK[current]) {
      sheetResult.rowStatus.set(rowIndex, severity);
    }
    if (!sheetResult.rowMessages.has(rowIndex)) {
      sheetResult.rowMessages.set(rowIndex, []);
    }
    sheetResult.rowMessages.get(rowIndex).push(message);
  }
}

function createSheetResult(sheet, rowCount) {
  return {
    sheet,
    totalRows: rowCount,
    issues: [],
    rowStatus: new Map(),
    rowMessages: new Map(),
    errorCount: 0,
    warningCount: 0,
    okCount: 0
  };
}

function finalizeSheetResult(sheetResult) {
  let okCount = 0;
  for (let index = 0; index < sheetResult.totalRows; index += 1) {
    const status = sheetResult.rowStatus.get(index);
    if (!status) {
      sheetResult.rowStatus.set(index, 'ok');
      okCount += 1;
    } else if (status === 'ok') {
      okCount += 1;
    }
  }
  sheetResult.okCount = okCount;
}

function validateFileFormat(sheet, rows, sheetResult) {
  const spec = COLUMN_CONFIG[sheet] || { columns: 0 };
  rows.forEach((row, index) => {
    const lineNumber = index + 1;
    const meta = row && row.__meta ? row.__meta : {};
    const expectedColumns = spec.columns || 0;
    const actualColumns = typeof meta.fieldCount === 'number' ? meta.fieldCount : expectedColumns;

    if (expectedColumns > 0 && actualColumns !== expectedColumns) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: expected ${expectedColumns} columns (found ${actualColumns})`, index);
    }

    if (expectedColumns > 1 && meta.separatorType === 'mixed') {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: inconsistent separators detected. Use commas consistently.`, index);
    }

    if (expectedColumns > 1 && meta.separatorType === 'none' && actualColumns < expectedColumns) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: missing commas or invalid separator`, index);
    }

    if (meta.separatorType === 'space') {
      recordIssue(sheetResult, 'warning', `Line ${lineNumber}: spaces detected as separators; replace with commas or tabs.`, index);
    }

    if (meta.blankLine || isRowBlank(sheet, row)) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: blank line detected`, index);
    }

    const fields = getRowFields(sheet, row);
    if (fields.some((value) => typeof value === 'string' && value.includes('\uFEFF'))) {
      recordIssue(sheetResult, 'warning', `Line ${lineNumber}: contains hidden BOM character.`, index);
    }
  });

  const metaInfo = sheetMetadata[sheet];
  if (metaInfo?.detectedBom) {
    recordIssue(sheetResult, 'warning', 'Imported file included a UTF-8 BOM. Export will remove it automatically.', null);
  }
  if (metaInfo && metaInfo.lastLineEnding && metaInfo.lastLineEnding !== 'crlf' && metaInfo.lastLineEnding !== 'ui') {
    recordIssue(sheetResult, 'warning', `Detected ${metaInfo.lastLineEnding.toUpperCase()} line endings. Export will normalize to CRLF.`, null);
  }
}

function formatLevelLabel(level) {
  if (typeof level !== 'number' || Number.isNaN(level)) {
    return 'an unknown level';
  }
  const name = LEVEL_NAMES[level];
  if (name) {
    return `${name} (level ${level})`;
  }
  return `level ${level}`;
}

function describeAllowedLevels(levels) {
  if (!Array.isArray(levels) || levels.length === 0) return 'a valid compobj entry';
  if (levels.length === 1) return formatLevelLabel(levels[0]);
  const parts = levels.map((lvl) => formatLevelLabel(lvl));
  const last = parts.pop();
  return `${parts.join(', ')} or ${last}`;
}

function checkParentHierarchy(rows, sheetResult) {
  const lookup = new Map();
  const pending = [];
  let previousId = null;

  rows.forEach((row, index) => {
    const lineNumber = index + 1;
    const idRaw = (row?.id ?? '').toString().trim();
    const idValue = idRaw === '' ? NaN : Number.parseInt(idRaw, 10);

    if (!Number.isInteger(idValue)) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: invalid ID "${idRaw}".`, index);
    } else {
      if (lookup.has(idValue)) {
        recordIssue(sheetResult, 'error', `Line ${lineNumber}: duplicate ID ${idValue}.`, index);
      }
      if (previousId !== null && idValue !== previousId + 1) {
        recordIssue(sheetResult, 'error', `Line ${lineNumber}: expected sequential ID ${previousId + 1} but found ${idValue}.`, index);
      }
      previousId = idValue;
    }

    const depthRaw = (row?.depth ?? '').toString().trim();
    const depthValue = depthRaw === '' ? NaN : Number.parseInt(depthRaw, 10);
    if (!Number.isInteger(depthValue)) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: invalid level "${depthRaw}".`, index);
    }

    const parentRaw = (row?.parentDisplay ?? '').toString().trim();
    const hasParentReference = parentRaw !== '' && parentRaw !== '-1';
    let parentId = null;
    let parentValueInvalid = false;
    if (hasParentReference) {
      const parsedParent = Number.parseInt(parentRaw, 10);
      if (!Number.isInteger(parsedParent)) {
        parentValueInvalid = true;
        recordIssue(sheetResult, 'error', `Line ${lineNumber}: parent ID "${parentRaw}" is not numeric.`, index);
      } else {
        parentId = parsedParent;
      }
    }

    pending.push({
      index,
      lineNumber,
      idValue,
      depthValue,
      parentId,
      parentValueInvalid,
      hasParentReference
    });

    if (Number.isInteger(idValue)) {
      lookup.set(idValue, {
        index,
        level: Number.isInteger(depthValue) ? depthValue : null,
        parentId: Number.isInteger(parentId) ? parentId : null
      });
    }
  });

  pending.forEach((entry) => {
    const { index, lineNumber, idValue, depthValue, parentId, parentValueInvalid, hasParentReference } = entry;

    if (!Number.isInteger(depthValue)) {
      return;
    }

    const allowedParents = PARENT_LEVEL_RULES[depthValue];
    if (!allowedParents) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: unsupported level ${depthValue}.`, index);
      return;
    }

    if (allowedParents.length === 0) {
      if (hasParentReference) {
        recordIssue(
          sheetResult,
          'error',
          `Line ${lineNumber}: ${LEVEL_NAMES[depthValue] || `Level ${depthValue}`} entries cannot define a parent.`,
          index
        );
      }
      return;
    }

    if (!hasParentReference) {
      const hint = LEVEL_PARENT_HINT[depthValue] ? ` ${LEVEL_PARENT_HINT[depthValue]}` : '';
      recordIssue(
        sheetResult,
        'error',
        `Line ${lineNumber}: missing parent reference for ${LEVEL_NAMES[depthValue] || `level ${depthValue}`} entries.${hint}`,
        index
      );
      return;
    }

    if (parentValueInvalid) {
      return;
    }

    if (!lookup.has(parentId)) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: parent ID ${parentId} does not exist in compobj.`, index);
      return;
    }

    if (Number.isInteger(idValue) && parentId === idValue) {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: parent ID cannot reference itself.`, index);
    }

    const parentEntry = lookup.get(parentId);
    const parentLevel = parentEntry?.level;
    if (typeof parentLevel !== 'number') {
      recordIssue(sheetResult, 'error', `Line ${lineNumber}: unable to determine parent level for ID ${parentId}.`, index);
      return;
    }

    if (!allowedParents.includes(parentLevel)) {
      const expectation = describeAllowedLevels(allowedParents);
      const hint = LEVEL_PARENT_HINT[depthValue] ? ` ${LEVEL_PARENT_HINT[depthValue]}` : ` Expected parent level: ${expectation}.`;
      recordIssue(
        sheetResult,
        'error',
        `Line ${lineNumber}: invalid parent ${parentId} (level ${depthValue} ‚Üí parent level ${parentLevel}).${hint}`,
        index
      );
    }
  });

  return lookup;
}

function validateCrossFileReferences(sheet, rows, sheetResult, compobjIndex) {
  const fieldRules = CROSS_REFERENCE_RULES[sheet];
  if (!fieldRules || fieldRules.length === 0) return;

  rows.forEach((row, index) => {
    const lineNumber = index + 1;
    fieldRules.forEach((rule) => {
      const shouldValidate = typeof rule.conditional === 'function' ? rule.conditional(row) : true;
      const rawValue = (row?.[rule.field] ?? '').toString().trim();
      const isRequired = typeof rule.required === 'function' ? rule.required(row) : !!rule.required;
      if (rawValue === '') {
        if (isRequired) {
          recordIssue(sheetResult, 'error', `Line ${lineNumber}: ${rule.label} is required.`, index);
        }
        return;
      }
      if (!shouldValidate) {
        return;
      }
      const parsed = Number.parseInt(rawValue, 10);
      if (!Number.isInteger(parsed)) {
        recordIssue(sheetResult, 'error', `Line ${lineNumber}: ${rule.label} "${rawValue}" is not numeric.`, index);
        return;
      }
      const reference = compobjIndex.get(parsed);
      if (!reference) {
        recordIssue(sheetResult, 'error', `Line ${lineNumber}: ${rule.label} ${parsed} does not exist in compobj.`, index);
        return;
      }
      if (rule.allowedLevels && rule.allowedLevels.length > 0) {
        const referenceLevel = reference.level;
        if (typeof referenceLevel !== 'number' || !rule.allowedLevels.includes(referenceLevel)) {
          const expectation = describeAllowedLevels(rule.allowedLevels);
          recordIssue(
            sheetResult,
            'error',
            `Line ${lineNumber}: ${rule.label} ${parsed} is ${formatLevelLabel(referenceLevel)}. Expected ${expectation}.`,
            index
          );
        }
      }
    });
  });
}

function collectTopIssues(results, limit = 3) {
  if (!results) return [];
  const issues = [];
  for (const sheet of SHEET_ORDER) {
    const sheetResult = results.perSheet?.[sheet];
    if (!sheetResult) continue;
    for (const issue of sheetResult.issues) {
      if (issue.severity === 'error') {
        issues.push(`${COLUMN_CONFIG[sheet].displayName} ‚Üí ${issue.message}`);
        if (issues.length >= limit) return issues;
      }
    }
  }
  return issues;
}

function validateAllSheets() {
  const results = { perSheet: {}, totalErrors: 0, totalWarnings: 0, totalOk: 0 };

  const compobjResult = createSheetResult('compobj', compobj.length);
  validateFileFormat('compobj', compobj, compobjResult);
  const compobjIndex = checkParentHierarchy(compobj, compobjResult);
  finalizeSheetResult(compobjResult);
  results.perSheet.compobj = compobjResult;
  results.totalErrors += compobjResult.errorCount;
  results.totalWarnings += compobjResult.warningCount;
  results.totalOk += compobjResult.okCount;

  SHEET_ORDER.slice(1).forEach((sheet) => {
    const rows = getDataArray(sheet);
    const sheetResult = createSheetResult(sheet, rows.length);
    validateFileFormat(sheet, rows, sheetResult);
    validateCrossFileReferences(sheet, rows, sheetResult, compobjIndex);
    finalizeSheetResult(sheetResult);
    results.perSheet[sheet] = sheetResult;
    results.totalErrors += sheetResult.errorCount;
    results.totalWarnings += sheetResult.warningCount;
    results.totalOk += sheetResult.okCount;
  });

  return results;
}

function renderValidationResults(results) {
  if (!validationResultsEl) return;
  if (!results) {
    validationResultsEl.innerHTML = '<p class="validation-placeholder">Validation results are out of date. Run validation to refresh.</p>';
    return;
  }

  const pluralize = (count, singular, plural = `${singular}s`) => `${count} ${count === 1 ? singular : plural}`;

  const overviewItems = ['<li class="validation-overview__success">‚úÖ Validation complete</li>'];

  const sections = SHEET_ORDER.map((sheet) => {
    const spec = COLUMN_CONFIG[sheet];
    const sheetResult = results.perSheet[sheet];
    if (!sheetResult) return '';
    let overviewIcon = '‚úÖ';
    let overviewClass = 'validation-overview__success';
    let overviewLabel = `${spec.displayName} ‚Äì all checks passed`;
    if (sheetResult.errorCount > 0) {
      overviewIcon = '‚ùå';
      overviewClass = 'validation-overview__error';
      overviewLabel = `${spec.displayName} ‚Äì ${pluralize(sheetResult.errorCount, 'critical error')}`;
    } else if (sheetResult.warningCount > 0) {
      overviewIcon = '‚ö†Ô∏è';
      overviewClass = 'validation-overview__warning';
      overviewLabel = `${spec.displayName} ‚Äì ${pluralize(sheetResult.warningCount, 'warning')}`;
    }
    overviewItems.push(`<li class="${overviewClass}">${overviewIcon} ${overviewLabel}</li>`);

    const summary = `‚úÖ ${sheetResult.okCount}/${sheetResult.totalRows} valid | ‚ö†Ô∏è ${sheetResult.warningCount} warnings | ‚ùå ${sheetResult.errorCount} errors`;
    const issues = sheetResult.issues.length
      ? `<ul class="issue-list">${sheetResult.issues.map((issue) => `<li class="issue issue--${issue.severity}">${severityIcon(issue.severity)} ${escapeHtml(issue.message)}</li>`).join('')}</ul>`
      : '<p class="all-clear">All lines valid.</p>';
    return `<section><h3>${spec.displayName}</h3><div class="sheet-summary">${summary}</div>${issues}</section>`;
  }).join('');

  const overviewHtml = `<ul class="validation-overview">${overviewItems.join('')}</ul>`;

  validationResultsEl.innerHTML = overviewHtml + sections;
}

function updateValidationSummary(results) {
  if (!validationSummaryEl) return;
  if (!results) {
    validationSummaryEl.textContent = 'Validation results pending. Click ‚ÄúValidate Database‚Äù to check all files.';
    validationSummaryEl.classList.remove('has-errors', 'has-warnings');
    return;
  }
  const summaryText = `‚úÖ ${results.totalOk} valid lines | ‚ö†Ô∏è ${results.totalWarnings} warnings | ‚ùå ${results.totalErrors} errors`;
  validationSummaryEl.textContent = summaryText;
  validationSummaryEl.classList.toggle('has-errors', results.totalErrors > 0);
  validationSummaryEl.classList.toggle('has-warnings', results.totalWarnings > 0);
}

function setValidationStatus(message, type = 'info') {
  if (!validationStatusEl) return;
  validationStatusEl.textContent = message || '';
  validationStatusEl.classList.remove('is-error', 'is-warning', 'is-success');
  if (type === 'error') {
    validationStatusEl.classList.add('is-error');
  } else if (type === 'warning') {
    validationStatusEl.classList.add('is-warning');
  } else if (type === 'success') {
    validationStatusEl.classList.add('is-success');
  }
}

function openValidationPanel() {
  if (!validationPanelEl) return;
  validationPanelEl.classList.add('is-visible');
}

function closeValidationPanel() {
  if (!validationPanelEl) return;
  validationPanelEl.classList.remove('is-visible');
}

function clearValidationHighlights() {
  const table = document.getElementById('sheet');
  if (!table) return;
  table.querySelectorAll('.error-row, .warning-row, .valid-row, .success-row').forEach((row) => {
    row.classList.remove('error-row', 'warning-row', 'valid-row', 'success-row');
    row.removeAttribute('title');
  });
}

function applyValidationHighlights() {
  const table = document.getElementById('sheet');
  if (!table) return;
  clearValidationHighlights();
  if (!validationState) return;
  const sheetResult = validationState.perSheet?.[activeSheet];
  if (!sheetResult) return;
  const rows = Array.from(table.querySelectorAll('tr'));
  for (let index = 1; index < rows.length; index += 1) {
    const status = sheetResult.rowStatus.get(index - 1);
    if (!status) continue;
    const rowEl = rows[index];
    const className = SEVERITY_CLASS[status];
    if (className) {
      rowEl.classList.add(className);
    }
    if (status === 'ok') {
      rowEl.removeAttribute('title');
    } else {
      const messages = sheetResult.rowMessages.get(index - 1);
      if (messages && messages.length) {
        rowEl.title = messages.join('\n');
      } else {
        rowEl.removeAttribute('title');
      }
    }
  }
}

function invalidateValidation() {
  if (!validationState) return;
  validationState = null;
  updateValidationSummary(null);
  renderValidationResults(null);
  clearValidationHighlights();
  setValidationStatus('Database modified. Validation results cleared.', 'warning');
}

function scheduleAutoValidation() {
  clearTimeout(autoValidateTimer);
  autoValidateTimer = setTimeout(() => {
    const results = runValidation({ showPanel: false });
    if (results.totalErrors > 0) {
      setValidationStatus(`‚ùå Auto-validation found ${results.totalErrors} critical errors.`, 'error');
    } else if (results.totalWarnings > 0) {
      setValidationStatus(`‚ö†Ô∏è Auto-validation completed with ${results.totalWarnings} warnings.`, 'warning');
    } else {
      setValidationStatus('‚úÖ Auto-validation complete. All files look good.', 'success');
    }
  }, AUTO_VALIDATE_DELAY);
}

function registerDataMutation(sheets) {
  const targets = Array.isArray(sheets) ? sheets : [sheets];
  targets.filter(Boolean).forEach((sheet) => {
    markSheetDirty(sheet);
  });
  invalidateValidation();
  if (autoValidateEnabled) {
    scheduleAutoValidation();
  }
}

function serializeRow(sheet, row) {
  const fields = getRowFields(sheet, row);
  return fields.map((value) => (value == null ? '' : value)).join(',');
}

function runValidation(options = {}) {
  clearTimeout(autoValidateTimer);
  autoValidateTimer = null;
  const results = validateAllSheets();
  validationState = results;
  updateValidationSummary(results);
  renderValidationResults(results);
  applyValidationHighlights();
  if (options.showPanel) {
    openValidationPanel();
  }
  return results;
}

function updateScheduleIdsFromMap(idMap) {
  let changed = false;
  schedule.forEach((row) => {
    const current = row.stageGroupId == null ? '' : String(row.stageGroupId);
    const mapped = idMap.get(current);
    if (mapped !== undefined && mapped !== current) {
      row.stageGroupId = mapped;
      markRowEdited('schedule', row);
      changed = true;
    }
  });
  return changed;
}

function updateAdvancementIdsFromMap(idMap) {
  let changed = false;
  advancement.forEach((row) => {
    const source = row.sourceGroupId == null ? '' : String(row.sourceGroupId);
    const target = row.targetGroupId == null ? '' : String(row.targetGroupId);
    const mappedSource = idMap.get(source);
    const mappedTarget = idMap.get(target);
    let rowChanged = false;
    if (mappedSource !== undefined && mappedSource !== source) {
      row.sourceGroupId = mappedSource;
      rowChanged = true;
    }
    if (mappedTarget !== undefined && mappedTarget !== target) {
      row.targetGroupId = mappedTarget;
      rowChanged = true;
    }
    if (rowChanged) {
      markRowEdited('advancement', row);
      changed = true;
    }
  });
  return changed;
}

function updateStandingsIdsFromMap(idMap) {
  let changed = false;
  standings.forEach((row) => {
    const group = row.groupId == null ? '' : String(row.groupId);
    const mapped = idMap.get(group);
    if (mapped !== undefined && mapped !== group) {
      row.groupId = mapped;
      markRowEdited('standings', row);
      changed = true;
    }
  });
  return changed;
}

function updateSettingsIdsFromMap(idMap) {
  let changed = false;
  settings.forEach((row) => {
    const stage = row.stageGroupId == null ? '' : String(row.stageGroupId);
    const mapped = idMap.get(stage);
    if (mapped !== undefined && mapped !== stage) {
      row.stageGroupId = mapped;
      markRowEdited('settings', row);
      changed = true;
    }
  });
  return changed;
}

updateWeatherIds = function updateWeatherIds(idMap) {
  if (!idMap || !(idMap instanceof Map)) return false;
  let changed = false;
  weather.forEach((row) => {
    const nation = row.nationId == null ? '' : String(row.nationId);
    const mapped = idMap.get(nation);
    if (mapped !== undefined && mapped !== nation) {
      row.nationId = mapped;
      markRowEdited('weather', row);
      changed = true;
    }
  });
  return changed;
};

updateTaskIds = function updateTaskIds(idMap) {
  if (!idMap || !(idMap instanceof Map)) return false;
  let changed = false;
  tasks.forEach((row, index) => {
    let rowChanged = false;
    const trophy = row.trophyId == null ? '' : String(row.trophyId);
    const mappedTrophy = idMap.get(trophy);
    if (mappedTrophy !== undefined && mappedTrophy !== trophy) {
      row.trophyId = mappedTrophy;
      markTaskHighlight(index, 'trophyId');
      rowChanged = true;
    }
    const target = row.targetId == null ? '' : String(row.targetId);
    const mappedTarget = idMap.get(target);
    if (mappedTarget !== undefined && mappedTarget !== target) {
      row.targetId = mappedTarget;
      markTaskHighlight(index, 'targetId');
      rowChanged = true;
    }
    const reference = row.refId == null ? '' : String(row.refId);
    if (reference !== '' && shouldUpdateTaskRefId(row.taskType)) {
      const mappedReference = idMap.get(reference);
      if (mappedReference !== undefined && mappedReference !== reference) {
        row.refId = mappedReference;
        markTaskHighlight(index, 'refId');
        rowChanged = true;
      }
    }
    if (rowChanged) {
      markRowEdited('tasks', row);
      changed = true;
    }
  });
  return changed;
};

updateObjectivesIds = function updateObjectivesIds(idMap) {
  if (!idMap || !(idMap instanceof Map)) return false;
  let changed = false;
  objectives.forEach((row) => {
    const group = row.stageGroupId == null ? '' : String(row.stageGroupId);
    const mapped = idMap.get(group);
    if (mapped !== undefined && mapped !== group) {
      row.stageGroupId = mapped;
      markRowEdited('objectives', row);
      changed = true;
    }
  });
  return changed;
};

syncTasksForManualIdChange = function syncTasksForManualIdChange(previous, next) {
  const prevValue = previous == null ? '' : String(previous);
  const nextValue = next == null ? '' : String(next);
  if (prevValue === nextValue) return false;
  let changed = false;
  tasks.forEach((row, index) => {
    let rowChanged = false;
    if ((row.trophyId == null ? '' : String(row.trophyId)) === prevValue) {
      row.trophyId = nextValue;
      markTaskHighlight(index, 'trophyId');
      rowChanged = true;
    }
    if ((row.targetId == null ? '' : String(row.targetId)) === prevValue) {
      row.targetId = nextValue;
      markTaskHighlight(index, 'targetId');
      rowChanged = true;
    }
    const reference = row.refId == null ? '' : String(row.refId);
    if (reference === prevValue && shouldUpdateTaskRefId(row.taskType)) {
      row.refId = nextValue;
      markTaskHighlight(index, 'refId');
      rowChanged = true;
    }
    if (rowChanged) {
      markRowEdited('tasks', row);
      changed = true;
    }
  });
  return changed;
};

syncReferencesForManualIdChange = function syncReferencesForManualIdChange(oldValue, newValue) {
  const previous = oldValue == null ? '' : String(oldValue);
  const next = newValue == null ? '' : String(newValue);
  if (previous === next) return;

  compobj.forEach((row) => {
    const parent = row.parentDisplay == null ? '' : String(row.parentDisplay);
    if (parent === previous) {
      row.parentDisplay = next;
      markRowEdited('compobj', row);
    }
  });

  schedule.forEach((row) => {
    if ((row.stageGroupId == null ? '' : String(row.stageGroupId)) === previous) {
      row.stageGroupId = next;
      markRowEdited('schedule', row);
    }
  });

  advancement.forEach((row) => {
    let rowChanged = false;
    if ((row.sourceGroupId == null ? '' : String(row.sourceGroupId)) === previous) {
      row.sourceGroupId = next;
      rowChanged = true;
    }
    if ((row.targetGroupId == null ? '' : String(row.targetGroupId)) === previous) {
      row.targetGroupId = next;
      rowChanged = true;
    }
    if (rowChanged) {
      markRowEdited('advancement', row);
    }
  });

  standings.forEach((row) => {
    if ((row.groupId == null ? '' : String(row.groupId)) === previous) {
      row.groupId = next;
      markRowEdited('standings', row);
    }
  });

  settings.forEach((row) => {
    if ((row.stageGroupId == null ? '' : String(row.stageGroupId)) === previous) {
      row.stageGroupId = next;
      markRowEdited('settings', row);
    }
  });

  weather.forEach((row) => {
    if ((row.nationId == null ? '' : String(row.nationId)) === previous) {
      row.nationId = next;
      markRowEdited('weather', row);
    }
  });

  objectives.forEach((row) => {
    if ((row.stageGroupId == null ? '' : String(row.stageGroupId)) === previous) {
      row.stageGroupId = next;
      markRowEdited('objectives', row);
    }
  });

  if (syncTasksForManualIdChange(previous, next)) {
    markSheetDirty('tasks');
  }

  ['compobj', 'schedule', 'advancement', 'standings', 'settings', 'weather', 'objectives'].forEach((sheet) => markSheetDirty(sheet));
};

renumberCompobjIds = function renumberCompobjIds() {
  const touched = new Set();
  const idMap = new Map();

  compobj.forEach((row, index) => {
    const oldId = row.id == null ? '' : String(row.id);
    const newId = String(index);
    if (oldId !== '') {
      idMap.set(oldId, newId);
    }
    if (row.id !== newId) {
      row.id = newId;
      markRowEdited('compobj', row);
      touched.add('compobj');
    }
  });

  compobj.forEach((row) => {
    const parent = row.parentDisplay == null ? '' : String(row.parentDisplay);
    if (!parent) return;
    const mapped = idMap.get(parent);
    if (mapped !== undefined && mapped !== parent) {
      row.parentDisplay = mapped;
      markRowEdited('compobj', row);
      touched.add('compobj');
    }
  });

  if (updateScheduleIdsFromMap(idMap)) touched.add('schedule');
  if (updateAdvancementIdsFromMap(idMap)) touched.add('advancement');
  if (updateStandingsIdsFromMap(idMap)) touched.add('standings');
  if (updateSettingsIdsFromMap(idMap)) touched.add('settings');
  if (updateWeatherIds(idMap)) touched.add('weather');
  if (updateTaskIds(idMap)) touched.add('tasks');
  if (updateObjectivesIds(idMap)) touched.add('objectives');

  return Array.from(touched);
};

createDefaultCompobjRow = (function wrapCreateDefaultCompobjRow(original) {
  return function wrappedCreateDefaultCompobjRow(config = {}) {
    const row = original(config);
    attachRowMeta(row, 'compobj');
    return row;
  };
})(createDefaultCompobjRow);

defaultRowForSheet = (function wrapDefaultRowForSheet(original) {
  return function wrappedDefaultRowForSheet(sheet) {
    const row = original(sheet);
    attachRowMeta(row, sheet);
    return row;
  };
})(defaultRowForSheet);

updateField = function updateField(i, field, value) {
  const target = getDataArray(activeSheet);
  const row = target?.[i];
  if (!row) return;
  const previousValue = row[field];
  if (previousValue === value) return;
  row[field] = value;
  markRowEdited(activeSheet, row);
  if (activeSheet === 'compobj' && field === 'id') {
    syncReferencesForManualIdChange(previousValue, value);
  }
  registerDataMutation(activeSheet);
};

addRow = function addRow(sheet = activeSheet) {
  if (sheet === 'compobj') {
    const newRow = createDefaultCompobjRow();
    compobj.push(newRow);
    const touched = renumberCompobjIds();
    registerDataMutation(['compobj', ...touched]);
  } else {
    const target = getDataArray(sheet);
    if (sheet === 'tasks') {
      clearTaskHighlights();
    }
    target.push(defaultRowForSheet(sheet));
    registerDataMutation(sheet);
  }
  render();
};

insertRows = function insertRows(sheet, position) {
  const selected = getSelectedIndex(sheet);
  if (selected === null) return alert('Select a row first.');
  const insertInput = document.getElementById(`insertCount-${sheet}`);
  const count = parseInt(insertInput.value, 10) || 1;
  const newRows = Array.from({ length: count }, () => defaultRowForSheet(sheet));
  const target = getDataArray(sheet);
  const index = position === 'above' ? selected : selected + 1;

  if (sheet === 'compobj') {
    compobj.splice(index, 0, ...newRows);
    const touched = renumberCompobjIds();
    registerDataMutation(['compobj', ...touched]);
  } else {
    if (sheet === 'tasks') {
      clearTaskHighlights();
    }
    target.splice(index, 0, ...newRows);
    registerDataMutation(sheet);
  }
  render();
};

deleteRow = function deleteRow(sheet = activeSheet) {
  const selected = getSelectedIndex(sheet);
  if (selected === null) return alert('Select a row first.');
  const target = getDataArray(sheet);
  if (!target[selected]) return;

  if (sheet === 'tasks') {
    clearTaskHighlights();
  }

  target.splice(selected, 1);
  selections[sheet] = null;

  if (sheet === 'compobj') {
    const touched = renumberCompobjIds();
    registerDataMutation(['compobj', ...touched]);
  } else {
    registerDataMutation(sheet);
  }

  render();
};

importFile = function importFile(event, append = false, sheetOverride = null) {
  const file = event.target?.files?.[0];
  const sheetTarget = sheetOverride || event.target?.dataset?.sheet || activeSheet;
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function onLoad(ev) {
    const content = ev.target?.result ?? '';
    const { rows, detectedBom, lineEnding } = parseFileContent(content, sheetTarget);
    const meta = ensureSheetMetadata(sheetTarget);
    meta.detectedBom = detectedBom;
    meta.lastLineEnding = lineEnding;

    if (sheetTarget === 'compobj') {
      compobj = append ? [...compobj, ...rows] : rows;
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
      const touched = renumberCompobjIds();
      registerDataMutation(['compobj', ...touched]);
    } else {
      if (sheetTarget === 'schedule') {
        schedule = append ? [...schedule, ...rows] : rows;
      } else if (sheetTarget === 'advancement') {
        advancement = append ? [...advancement, ...rows] : rows;
      } else if (sheetTarget === 'standings') {
        standings = append ? [...standings, ...rows] : rows;
      } else if (sheetTarget === 'settings') {
        settings = append ? [...settings, ...rows] : rows;
      } else if (sheetTarget === 'tasks') {
        clearTaskHighlights();
        tasks = append ? [...tasks, ...rows] : rows;
      } else if (sheetTarget === 'weather') {
        weather = append ? [...weather, ...rows] : rows;
      } else if (sheetTarget === 'objectives') {
        objectives = append ? [...objectives, ...rows] : rows;
      }
      if (activeSheet !== sheetTarget) setActiveSheet(sheetTarget);
      registerDataMutation(sheetTarget);
    }

    render();
  };

  reader.readAsText(file);
};

exportTxt = function exportTxt(sheet = activeSheet) {
  const results = runValidation({ showPanel: false });
  if (results.totalErrors > 0) {
    const topIssues = collectTopIssues(results, 3);
    const detail = topIssues.length ? `\n${topIssues.map((issue) => `- ${issue}`).join('\n')}` : '';
    setValidationStatus(`‚ùå Export aborted ‚Äî ${results.totalErrors} critical errors detected.${detail}`, 'error');
    openValidationPanel();
    return;
  }

  const activeData = getDataArray(sheet);
  const payload = activeData.map((row) => serializeRow(sheet, row)).join('\r\n');
  const blob = new Blob([payload], { type: 'text/plain;charset=utf-8' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `${sheet}.txt`;
  link.click();
  setTimeout(() => URL.revokeObjectURL(link.href), 0);
  setValidationStatus('‚úÖ Export successful! All files validated.', 'success');
};

const originalRender = render;
render = function wrappedRender() {
  originalRender();
  applyValidationHighlights();
};

if (validateButton) {
  validateButton.addEventListener('click', () => {
    const results = runValidation({ showPanel: true });
    if (results.totalErrors > 0) {
      setValidationStatus(`‚ùå Validation found ${results.totalErrors} critical errors.`, 'error');
    } else if (results.totalWarnings > 0) {
      setValidationStatus(`‚ö†Ô∏è Validation completed with ${results.totalWarnings} warnings.`, 'warning');
    } else {
      setValidationStatus('‚úÖ Validation passed. All files look good.', 'success');
    }
  });
}

if (autoValidateToggle) {
  autoValidateToggle.addEventListener('change', (event) => {
    autoValidateEnabled = event.target.checked;
    if (autoValidateEnabled) {
      setValidationStatus('Auto-validation enabled. Edits will trigger background validation.', 'info');
      if (validationState) {
        scheduleAutoValidation();
      }
    } else {
      clearTimeout(autoValidateTimer);
      autoValidateTimer = null;
      setValidationStatus('Auto-validation disabled.', 'info');
    }
  });
}

if (closeValidationPanelBtn) {
  closeValidationPanelBtn.addEventListener('click', closeValidationPanel);
}

if (validationPanelEl) {
  validationPanelEl.addEventListener('click', (event) => {
    if (event.target === validationPanelEl) {
      closeValidationPanel();
    }
  });
}

updateValidationSummary(null);
renderValidationResults(null);
setValidationStatus('', 'info');

function updateControlVisibility() {
  document.querySelectorAll('#controls .control-set').forEach((el) => {
    el.classList.toggle('active', el.dataset.sheetControls === activeSheet);
  });
}

/* Example demo data */
compobj = [
  { id: 0, depth: 0, code: "FIFA", name: "FIFA", parentDisplay: "-1" },
  { id: 1, depth: 3, code: "C990", name: "TrophyName_Abbr15_990", parentDisplay: "0" },
  { id: 2, depth: 4, code: "S1", name: "FCE_Setup_Stage", parentDisplay: "1" },
  { id: 3, depth: 5, code: "G1", name: "", parentDisplay: "2" },
  { id: 4, depth: 5, code: "G2", name: "", parentDisplay: "2" },
  { id: 5, depth: 4, code: "S2", name: "FCE_Group_Stage", parentDisplay: "1" },
  { id: 6, depth: 5, code: "G1", name: "FCE_Group_A", parentDisplay: "5" },
  { id: 7, depth: 5, code: "G2", name: "FCE_Group_B", parentDisplay: "5" },
  { id: 8, depth: 4, code: "S3", name: "FCE_Final", parentDisplay: "1" }
];

schedule = [
  { stageGroupId: '2', dayId: '257', matchday: '1', minMatches: '1', maxMatches: '1', time: '1400' },
  { stageGroupId: '5', dayId: '258', matchday: '2', minMatches: '2', maxMatches: '4', time: '1600' }
];

advancement = [
  { sourceGroupId: '1628', placement: '3', targetGroupId: '1630', teamCount: '1' },
  { sourceGroupId: '1628', placement: '6', targetGroupId: '1630', teamCount: '2' },
  { sourceGroupId: '1628', placement: '4', targetGroupId: '1631', teamCount: '1' },
  { sourceGroupId: '1628', placement: '5', targetGroupId: '1631', teamCount: '2' },
  { sourceGroupId: '1630', placement: '1', targetGroupId: '1633', teamCount: '1' },
  { sourceGroupId: '1628', placement: '1', targetGroupId: '1633', teamCount: '2' },
  { sourceGroupId: '1631', placement: '1', targetGroupId: '1634', teamCount: '1' },
  { sourceGroupId: '1628', placement: '2', targetGroupId: '1634', teamCount: '2' },
  { sourceGroupId: '1633', placement: '1', targetGroupId: '1636', teamCount: '1' },
  { sourceGroupId: '1634', placement: '1', targetGroupId: '1636', teamCount: '2' }
];

standings = [
  { groupId: '1628', slotNumber: '0' },
  { groupId: '1628', slotNumber: '1' },
  { groupId: '1628', slotNumber: '2' },
  { groupId: '1628', slotNumber: '3' },
  { groupId: '1628', slotNumber: '4' },
  { groupId: '1628', slotNumber: '5' },
  { groupId: '1628', slotNumber: '6' },
  { groupId: '1628', slotNumber: '7' },
  { groupId: '1628', slotNumber: '8' },
  { groupId: '1628', slotNumber: '9' },
  { groupId: '1628', slotNumber: '10' },
  { groupId: '1628', slotNumber: '11' },
  { groupId: '1628', slotNumber: '12' },
  { groupId: '1628', slotNumber: '13' },
  { groupId: '1630', slotNumber: '0' },
  { groupId: '1630', slotNumber: '1' },
  { groupId: '1631', slotNumber: '0' },
  { groupId: '1631', slotNumber: '1' },
  { groupId: '1633', slotNumber: '0' },
  { groupId: '1633', slotNumber: '1' },
  { groupId: '1634', slotNumber: '0' },
  { groupId: '1634', slotNumber: '1' },
  { groupId: '1636', slotNumber: '0' },
  { groupId: '1636', slotNumber: '1' }
];

settings = [
  { stageGroupId: '1625', key: 'nation_id', value: '159' },
  { stageGroupId: '1625', key: 'rule_suspension', value: '1625' },
  { stageGroupId: '1625', key: 'schedule_seasonstartmonth', value: 'JUL' },
  { stageGroupId: '1626', key: 'asset_id', value: '2149' },
  { stageGroupId: '1626', key: 'comp_type', value: 'LEAGUE' },
  { stageGroupId: '1626', key: 'rule_numyellowstored', value: '4' },
  { stageGroupId: '1627', key: 'match_matchsituation', value: 'LEAGUE' },
  { stageGroupId: '1628', key: 'num_games', value: '2' },
  { stageGroupId: '1628', key: 'info_label_slot_adv_group', value: '1' },
  { stageGroupId: '1628', key: 'info_label_slot_adv_group', value: '2' },
  { stageGroupId: '1628', key: 'info_label_slot_adv_group', value: '3' },
  { stageGroupId: '1628', key: 'info_label_slot_adv_group', value: '4' },
  { stageGroupId: '1628', key: 'info_label_slot_adv_group', value: '5' },
  { stageGroupId: '1628', key: 'info_label_slot_adv_group', value: '6' },
  { stageGroupId: '1629', key: 'match_matchsituation', value: 'ROUNDX' },
  { stageGroupId: '1629', key: 'match_stagetype', value: 'KO1LEG' },
  { stageGroupId: '1629', key: 'info_prize_money', value: '84920' },
  { stageGroupId: '1629', key: 'info_prize_money_drop', value: '100' },
  { stageGroupId: '1630', key: 'num_games', value: '1' },
  { stageGroupId: '1631', key: 'num_games', value: '1' },
  { stageGroupId: '1632', key: 'match_stagetype', value: 'KO2LEGS' },
  { stageGroupId: '1632', key: 'match_matchsituation', value: 'SEMI' },
  { stageGroupId: '1632', key: 'info_prize_money', value: '169845' },
  { stageGroupId: '1632', key: 'info_prize_money_drop', value: '100' },
  { stageGroupId: '1633', key: 'num_games', value: '2' },
  { stageGroupId: '1634', key: 'num_games', value: '2' },
  { stageGroupId: '1635', key: 'match_stagetype', value: 'KO1LEG' },
  { stageGroupId: '1635', key: 'match_matchsituation', value: 'FINAL' },
  { stageGroupId: '1635', key: 'info_prize_money', value: '905840' },
  { stageGroupId: '1635', key: 'info_prize_money_drop', value: '50' },
  { stageGroupId: '1636', key: 'num_games', value: '1' },
  { stageGroupId: '1636', key: 'info_slot_champ', value: '1' }
];

tasks = [
  { trophyId: '1626', phase: 'start', taskType: 'ClearLeagueStats', targetId: '1627', refId: '2149', arg1: '0', arg2: '0' },
  { trophyId: '1626', phase: 'end', taskType: 'UpdateTable', targetId: '1626', refId: '1636', arg1: '1', arg2: '1' },
  { trophyId: '1626', phase: 'end', taskType: 'UpdateTable', targetId: '1626', refId: '1628', arg1: '2', arg2: '2' },
  { trophyId: '1626', phase: 'end', taskType: 'UpdateTable', targetId: '1626', refId: '1628', arg1: '3', arg2: '3' },
  { trophyId: '1626', phase: 'end', taskType: 'UpdateLeagueStats', targetId: '1627', refId: '2149', arg1: '0', arg2: '0' }
];

weather = [
  { nationId: '1777', entry: '1', temp: '65', cloud: '15', rain: '10', snow: '0', wind: '10', start: '2345', end: '45' },
  { nationId: '1777', entry: '2', temp: '60', cloud: '25', rain: '10', snow: '0', wind: '5', start: '2315', end: '15' },
  { nationId: '1777', entry: '3', temp: '60', cloud: '25', rain: '10', snow: '0', wind: '5', start: '2245', end: '2345' },
  { nationId: '1777', entry: '4', temp: '55', cloud: '20', rain: '15', snow: '0', wind: '10', start: '2200', end: '2300' },
  { nationId: '1777', entry: '5', temp: '45', cloud: '10', rain: '15', snow: '0', wind: '30', start: '2130', end: '2230' },
  { nationId: '1777', entry: '6', temp: '45', cloud: '5', rain: '20', snow: '0', wind: '30', start: '2115', end: '2215' },
  { nationId: '1777', entry: '7', temp: '35', cloud: '15', rain: '10', snow: '0', wind: '40', start: '2130', end: '2230' },
  { nationId: '1777', entry: '8', temp: '40', cloud: '15', rain: '20', snow: '0', wind: '25', start: '2145', end: '2245' },
  { nationId: '1777', entry: '9', temp: '55', cloud: '10', rain: '25', snow: '0', wind: '10', start: '2215', end: '2300' },
  { nationId: '1777', entry: '10', temp: '55', cloud: '25', rain: '10', snow: '0', wind: '10', start: '2230', end: '2330' },
  { nationId: '1777', entry: '11', temp: '65', cloud: '15', rain: '10', snow: '0', wind: '10', start: '2300', end: '15' },
  { nationId: '1777', entry: '12', temp: '80', cloud: '5', rain: '10', snow: '0', wind: '5', start: '2330', end: '45' }
];

objectives = [
  { stageGroupId: '1624', objectiveType: 'FIGHT_FOR_TITLE', value: '3' },
  { stageGroupId: '1624', objectiveType: 'HIGH_FINISH', value: '5' },
  { stageGroupId: '1624', objectiveType: 'MID_TABLE', value: '11' },
  { stageGroupId: '1624', objectiveType: 'AVOID_LOWLY_FINISH', value: '14' },
  { stageGroupId: '1628', objectiveType: 'AVOID_LOWLY_FINISH', value: '11' },
  { stageGroupId: '1630', objectiveType: 'REACH_PLAYOFFS', value: '0' },
  { stageGroupId: '1631', objectiveType: 'REACH_PLAYOFFS', value: '0' },
  { stageGroupId: '1633', objectiveType: 'REACH_SEMI_FINALS', value: '0' },
  { stageGroupId: '1634', objectiveType: 'REACH_SEMI_FINALS', value: '0' },
  { stageGroupId: '1636', objectiveType: 'CHAMPION', value: '1' },
  { stageGroupId: '1636', objectiveType: 'REACH_FINALS', value: '0' }
];

SHEET_ORDER.forEach((sheet) => {
  const rows = getDataArray(sheet);
  rows.forEach((row) => attachRowMeta(row, sheet));
  markSheetDirty(sheet);
});

renumberCompobjIds();
render();
</script>

</body>
</html>
