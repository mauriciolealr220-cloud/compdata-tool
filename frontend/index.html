<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Football Competition Modding Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="bg-slate-950 text-slate-100 min-h-screen">
    <div class="max-w-6xl mx-auto py-10 px-4 space-y-8">
      <header class="space-y-2">
        <h1 class="text-3xl font-semibold">Football Competition Modding Editor</h1>
        <p class="text-slate-300">
          Load the eight database files, inspect the tree, run validations, and export
          updated files. The backend enforces formatting rules and cross-file references.
        </p>
      </header>

      <section class="bg-slate-900/60 border border-slate-800 rounded-xl p-6 space-y-4">
        <h2 class="text-xl font-medium">1. Load Files</h2>
        <p class="text-slate-300">
          Select the <code>.txt</code> files required by the game. The tool normalises the
          filenames, so any casing is accepted.
        </p>
        <input id="file-input" type="file" multiple class="block w-full text-sm" />
        <button
          id="parse-button"
          class="px-4 py-2 bg-emerald-500 text-black rounded-md font-semibold hover:bg-emerald-400 disabled:opacity-40"
        >
          Parse Files
        </button>
        <p id="parse-status" class="text-sm text-slate-400"></p>
      </section>

      <section class="bg-slate-900/60 border border-slate-800 rounded-xl p-6 space-y-4">
        <h2 class="text-xl font-medium">2. Validation</h2>
        <div class="flex gap-3">
          <button
            id="validate-button"
            class="px-4 py-2 bg-sky-500 text-black rounded-md font-semibold hover:bg-sky-400 disabled:opacity-40"
          >
            Run Validation
          </button>
          <button
            id="autofix-button"
            class="px-4 py-2 bg-amber-500 text-black rounded-md font-semibold hover:bg-amber-400 disabled:opacity-40"
          >
            Auto Fix Hygiene
          </button>
        </div>
        <div>
          <h3 class="font-semibold mb-2">Issues</h3>
          <ul id="issue-list" class="space-y-2 text-sm"></ul>
        </div>
      </section>

      <section class="bg-slate-900/60 border border-slate-800 rounded-xl p-6 space-y-4">
        <h2 class="text-xl font-medium">3. Tree</h2>
        <p class="text-slate-300">Select a node to inspect its metadata.</p>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <ul id="tree" class="text-sm space-y-1"></ul>
          </div>
          <div id="detail" class="text-sm text-slate-200"></div>
        </div>
      </section>

      <section class="bg-slate-900/60 border border-slate-800 rounded-xl p-6 space-y-4">
        <h2 class="text-xl font-medium">4. Export</h2>
        <button
          id="export-button"
          class="px-4 py-2 bg-purple-500 text-black rounded-md font-semibold hover:bg-purple-400 disabled:opacity-40"
        >
          Download Zip
        </button>
        <p class="text-slate-300 text-sm">
          Export returns a <code>.zip</code> with the eight files preserved in plain-text
          format without BOMs or trailing whitespace modifications.
        </p>
      </section>
    </div>

    <script>
      const API_BASE = (() => {
        const { protocol, hostname, port } = window.location;
        const isHttp = protocol === 'http:' || protocol === 'https:';
        if (isHttp) {
          const isLocalHost = hostname === 'localhost' || hostname === '127.0.0.1';
          if (!isLocalHost || port === '' || port === '3000') {
            return '';
          }
          return `http://${hostname}:3000`;
        }
        return 'http://localhost:3000';
      })();

      function buildUrl(path) {
        if (!path.startsWith('/')) {
          path = `/${path}`;
        }
        return `${API_BASE}${path}`;
      }

      async function safeFetch(path, options) {
        const url = buildUrl(path);
        try {
          const response = await fetch(url, options);
          return { response, url };
        } catch (error) {
          if (error && error.name === 'TypeError') {
            throw new Error(`Unable to reach backend at ${url}. Please ensure the server is running.`);
          }
          throw error;
        }
      }

      async function fetchJson(path, options) {
        const { response, url } = await safeFetch(path, options);
        const data = await response.json();
        return { response, url, data };
      }

      const state = {
        files: {},
        model: null,
        issues: [],
      };

      function readFiles(input) {
        const fileList = input.files;
        if (!fileList || !fileList.length) {
          return Promise.resolve({});
        }
        const promises = Array.from(fileList).map(file =>
          file.text().then(text => [file.name, text])
        );
        return Promise.all(promises).then(entries => Object.fromEntries(entries));
      }

      function renderTree(model) {
        const treeRoot = document.getElementById('tree');
        treeRoot.innerHTML = '';
        if (!model) {
          return;
        }
        const nodesByParent = new Map();
        model.compobj.entries.forEach(entry => {
          const parent = entry.parentId || 0;
          if (!nodesByParent.has(parent)) {
            nodesByParent.set(parent, []);
          }
          nodesByParent.get(parent).push(entry);
        });
        const fragment = document.createDocumentFragment();

        function createNode(entry, depth) {
          const li = document.createElement('li');
          li.className = 'flex flex-col border border-slate-800 rounded-lg px-3 py-2 bg-slate-950/60 hover:bg-slate-900 transition';
          li.style.marginLeft = `${depth * 12}px`;
          li.innerHTML = `
            <div class="flex justify-between items-center">
              <span class="font-semibold">${entry.code || '(no code)'} · ${entry.name || '(no name)'}</span>
              <span class="text-xs text-slate-400">ID ${entry.id} · L${entry.level}</span>
            </div>
          `;
          li.addEventListener('click', event => {
            event.stopPropagation();
            renderDetail(entry);
          });
          fragment.appendChild(li);
          const children = nodesByParent.get(entry.id) || [];
          children.forEach(child => createNode(child, depth + 1));
        }

        (nodesByParent.get(0) || []).forEach(rootEntry => createNode(rootEntry, 0));
        treeRoot.appendChild(fragment);
      }

      function renderDetail(entry) {
        const detail = document.getElementById('detail');
        if (!entry) {
          detail.textContent = '';
          return;
        }
        detail.innerHTML = `
          <div class="space-y-2">
            <h3 class="text-lg font-semibold">Node ${entry.id}</h3>
            <dl class="grid grid-cols-2 gap-2">
              <dt class="text-slate-400">Level</dt>
              <dd>${entry.level}</dd>
              <dt class="text-slate-400">Code</dt>
              <dd>${entry.code || '<em>blank</em>'}</dd>
              <dt class="text-slate-400">Name</dt>
              <dd>${entry.name || '<em>blank</em>'}</dd>
              <dt class="text-slate-400">Parent ID</dt>
              <dd>${entry.parentId || 0}</dd>
              <dt class="text-slate-400">Line</dt>
              <dd>${entry.lineNumber}</dd>
            </dl>
            <p class="text-xs text-slate-400">Raw: <code>${entry.raw}</code></p>
          </div>
        `;
      }

      function renderIssues(issues) {
        const list = document.getElementById('issue-list');
        list.innerHTML = '';
        if (!issues.length) {
          const li = document.createElement('li');
          li.textContent = 'No issues detected.';
          li.className = 'text-emerald-400';
          list.appendChild(li);
          return;
        }
        issues.forEach(issue => {
          const li = document.createElement('li');
          const tone = issue.severity === 'error' ? 'text-rose-400' : 'text-amber-300';
          li.className = `border border-slate-800 rounded-md px-3 py-2 bg-slate-950/60 ${tone}`;
          li.innerHTML = `
            <div class="font-semibold">${issue.severity.toUpperCase()} · ${issue.code}</div>
            <div>${issue.message}</div>
            <div class="text-xs text-slate-500">${issue.file} · line ${issue.line}</div>
          `;
          list.appendChild(li);
        });
      }

      function setLoading(button, loading) {
        button.disabled = loading;
        button.textContent = loading ? 'Working…' : button.dataset.label;
      }

      document.querySelectorAll('button').forEach(button => {
        button.dataset.label = button.textContent;
      });

      document.getElementById('parse-button').addEventListener('click', async () => {
        const input = document.getElementById('file-input');
        const status = document.getElementById('parse-status');
        status.textContent = '';
        const localFiles = await readFiles(input);
        if (!Object.keys(localFiles).length) {
          status.textContent = 'Select the eight required files before parsing.';
          return;
        }
        state.files = localFiles;
        setLoading(document.getElementById('parse-button'), true);
        try {
          const { data } = await fetchJson('/parse', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: localFiles }),
          });
          if (!data.ok) {
            throw new Error(data.error || 'Unable to parse files.');
          }
          state.model = data.model;
          renderTree(state.model);
          renderDetail(null);
          status.textContent = 'Files parsed successfully.';
        } catch (error) {
          console.error(error);
          status.textContent = error.message;
        } finally {
          setLoading(document.getElementById('parse-button'), false);
        }
      });

      document.getElementById('validate-button').addEventListener('click', async () => {
        const button = document.getElementById('validate-button');
        if (!Object.keys(state.files).length) {
          renderIssues([{ severity: 'error', code: 'NO_FILES', message: 'Load files first.', file: 'N/A', line: 0 }]);
          return;
        }
        setLoading(button, true);
        try {
          const { response, data } = await fetchJson('/validate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: state.files }),
          });
          if (!response.ok) {
            throw new Error(data.error || 'Validation failed.');
          }
          state.issues = data.issues || [];
          renderIssues(state.issues);
        } catch (error) {
          renderIssues([{ severity: 'error', code: 'REQUEST_FAILED', message: error.message, file: 'N/A', line: 0 }]);
        } finally {
          setLoading(button, false);
        }
      });

      document.getElementById('autofix-button').addEventListener('click', async () => {
        const button = document.getElementById('autofix-button');
        if (!Object.keys(state.files).length) {
          alert('Load files before requesting auto-fix.');
          return;
        }
        setLoading(button, true);
        try {
          const { data } = await fetchJson('/autofix', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: state.files }),
          });
          if (!data.ok) {
            throw new Error(data.error || 'Auto-fix failed.');
          }
          state.files = data.files;
          alert('Auto-fix applied. Re-run validation to review the updated issues.');
        } catch (error) {
          alert(error.message);
        } finally {
          setLoading(button, false);
        }
      });

      document.getElementById('export-button').addEventListener('click', async () => {
        if (!Object.keys(state.files).length) {
          alert('Load files before exporting.');
          return;
        }
        try {
          const { response } = await safeFetch('/export', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: state.files }),
          });
          if (!response.ok) {
            const data = await response.json().catch(() => ({}));
            throw new Error(data.error || 'Export failed.');
          }
          const blob = await response.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'mod-export.zip';
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (error) {
          alert(error.message);
        }
      });
    </script>
  </body>
</html>
