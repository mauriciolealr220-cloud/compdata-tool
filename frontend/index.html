<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Competition Data Studio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --sidebar-width: 280px;
        --bg: #050910;
        --bg-panel: #0c1729;
        --bg-elevated: #101d32;
        --border: rgba(148, 163, 184, 0.12);
        --border-strong: rgba(148, 163, 184, 0.24);
        --text: #f1f5f9;
        --text-subtle: #94a3b8;
        --accent: #38bdf8;
        --success: #34d399;
        --warning: #fbbf24;
        --error: #f87171;
        font-size: 15px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.08), transparent 40%),
          radial-gradient(circle at 80% 0%, rgba(129, 140, 248, 0.12), transparent 45%),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .app-shell {
        flex: 1;
        display: flex;
        min-height: 0;
      }

      aside {
        width: var(--sidebar-width);
        border-right: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(15, 23, 42, 0.65), rgba(2, 6, 23, 0.95));
        padding: 1.75rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1.75rem;
      }

      .brand h1 {
        font-size: 1.3rem;
        margin: 0;
        font-weight: 600;
      }

      .brand p {
        margin: 0.25rem 0 0;
        font-size: 0.85rem;
        color: var(--text-subtle);
      }

      .nav {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .nav button {
        all: unset;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 0.85rem;
        border-radius: 0.85rem;
        cursor: pointer;
        color: var(--text-subtle);
        border: 1px solid transparent;
        transition: background 160ms ease, color 160ms ease, border-color 160ms ease;
      }

      .nav button:hover,
      .nav button:focus-visible {
        background: rgba(56, 189, 248, 0.12);
        color: var(--text);
        border-color: rgba(56, 189, 248, 0.3);
      }

      .nav button.active {
        background: rgba(56, 189, 248, 0.22);
        color: var(--text);
        border-color: rgba(56, 189, 248, 0.6);
      }

      .nav button span.icon {
        width: 2.5rem;
        height: 2.5rem;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.35rem;
        border-radius: 0.9rem;
        background: rgba(15, 118, 110, 0.15);
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        background: rgba(15, 23, 42, 0.55);
        backdrop-filter: blur(18px);
      }

      .main-header {
        padding: 1.5rem 2rem 1.25rem;
        border-bottom: 1px solid var(--border);
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 1rem;
      }

      .main-header h2 {
        margin: 0;
        font-weight: 600;
        font-size: 1.35rem;
      }

      .main-header .subtitle {
        margin-top: 0.35rem;
        font-size: 0.9rem;
        color: var(--text-subtle);
      }

      .status-line {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        color: var(--text-subtle);
        font-size: 0.82rem;
      }

      .status-line span.indicator {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
      }

      .status-line .indicator::before {
        content: '';
        width: 0.6rem;
        height: 0.6rem;
        border-radius: 999px;
        background: var(--success);
        opacity: 0.7;
      }

      .status-line .indicator.unsaved::before {
        background: var(--warning);
        animation: pulse 1.3s ease-in-out infinite alternate;
      }

      @keyframes pulse {
        from {
          opacity: 0.35;
        }
        to {
          opacity: 1;
        }
      }

      .action-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .action-bar button {
        all: unset;
        padding: 0.5rem 0.9rem;
        border-radius: 0.7rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(30, 41, 59, 0.55);
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        color: var(--text);
        transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      }

      .action-bar button.primary {
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.85), rgba(99, 102, 241, 0.85));
        border-color: transparent;
      }

      .action-bar button:hover,
      .action-bar button:focus-visible {
        transform: translateY(-1px);
        border-color: rgba(56, 189, 248, 0.45);
      }

      .workspace {
        flex: 1;
        padding: 1.5rem 2rem 1.5rem;
        min-height: 0;
        overflow: hidden;
      }

      .workspace-card {
        height: 100%;
        background: var(--bg-panel);
        border: 1px solid var(--border);
        border-radius: 1.25rem;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }

      .editor-grid {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(260px, 320px) minmax(220px, 1fr) minmax(240px, 320px);
        gap: 1rem;
        min-height: 0;
      }

      .panel {
        background: rgba(15, 23, 42, 0.45);
        border: 1px solid var(--border);
        border-radius: 1rem;
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }

      .panel-header {
        padding: 1rem 1.1rem 0.75rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      }

      .panel-header h3 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }

      .panel-body {
        padding: 1rem 1.1rem;
        flex: 1;
        overflow: auto;
      }

      .tree {
        list-style: none;
        margin: 0;
        padding-left: 0;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .tree li {
        border-radius: 0.75rem;
        border: 1px solid transparent;
        padding: 0.45rem 0.6rem 0.45rem 0.95rem;
        background: rgba(15, 23, 42, 0.25);
        cursor: pointer;
        transition: border 150ms ease, background 150ms ease, transform 150ms ease;
      }

      .tree li:hover {
        border-color: rgba(56, 189, 248, 0.35);
        transform: translateX(2px);
      }

      .tree li.selected {
        border-color: rgba(56, 189, 248, 0.75);
        background: rgba(56, 189, 248, 0.15);
      }

      .tree li .meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.75rem;
        color: var(--text-subtle);
      }

      .tree li .label {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .tree li .label strong {
        font-size: 0.9rem;
        color: var(--text);
      }

      .tree-children {
        list-style: none;
        margin: 0.3rem 0 0 0.75rem;
        padding-left: 0.75rem;
        border-left: 1px dashed rgba(148, 163, 184, 0.25);
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .field-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.75rem;
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .field label {
        font-size: 0.78rem;
        color: var(--text-subtle);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .field input,
      .field select,
      .field textarea {
        width: 100%;
        padding: 0.55rem 0.7rem;
        border-radius: 0.65rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.55);
        color: var(--text);
        font-size: 0.9rem;
        font-family: inherit;
      }

      .field textarea {
        min-height: 160px;
        resize: vertical;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.88rem;
      }

      thead th {
        text-align: left;
        font-weight: 600;
        padding: 0.55rem 0.65rem;
        color: var(--text-subtle);
        border-bottom: 1px solid rgba(148, 163, 184, 0.12);
        background: rgba(15, 23, 42, 0.35);
        position: sticky;
        top: 0;
        z-index: 1;
      }
      tbody tr {
        border-bottom: 1px solid rgba(148, 163, 184, 0.08);
      }

      tbody tr:hover {
        background: rgba(56, 189, 248, 0.07);
      }

      td {
        padding: 0.45rem 0.55rem;
        vertical-align: middle;
      }

      td input,
      td select {
        width: 100%;
        border-radius: 0.55rem;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.65);
        padding: 0.4rem 0.55rem;
        color: var(--text);
        font-size: 0.86rem;
        font-family: inherit;
      }

      .table-actions {
        display: flex;
        gap: 0.35rem;
      }

      .table-actions button,
      .inline-button {
        all: unset;
        padding: 0.35rem 0.6rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(148, 163, 184, 0.2);
        background: rgba(15, 23, 42, 0.4);
        cursor: pointer;
        font-size: 0.75rem;
        font-weight: 500;
      }

      .inline-button.primary {
        background: rgba(56, 189, 248, 0.25);
        border-color: rgba(56, 189, 248, 0.35);
      }

      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
        margin-bottom: 0.85rem;
      }

      .toolbar .search-field {
        flex: 1;
        min-width: 180px;
        display: flex;
        align-items: center;
        gap: 0.55rem;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.2);
        padding: 0.45rem 0.6rem;
        border-radius: 0.7rem;
        color: var(--text-subtle);
      }

      .toolbar .search-field input {
        all: unset;
        flex: 1;
        font-size: 0.86rem;
        color: var(--text);
      }

      .console {
        border-top: 1px solid var(--border);
        padding: 1.2rem 2rem 1.6rem;
        background: rgba(2, 6, 23, 0.82);
        max-height: 260px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .console-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      .console-header h3 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }

      .console-stream {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        border-radius: 0.85rem;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.55);
        padding: 0.65rem;
        display: flex;
        flex-direction: column-reverse;
        gap: 0.5rem;
      }

      .console-entry {
        border-radius: 0.75rem;
        padding: 0.6rem 0.8rem;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.16);
        font-size: 0.85rem;
      }

      .console-entry.info {
        border-color: rgba(56, 189, 248, 0.3);
      }

      .console-entry.success {
        border-color: rgba(52, 211, 153, 0.35);
      }

      .console-entry.warning {
        border-color: rgba(251, 191, 36, 0.4);
      }

      .console-entry.error {
        border-color: rgba(248, 113, 113, 0.4);
      }

      .console-entry header {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
        align-items: center;
        font-weight: 600;
      }

      .console-entry ul {
        margin: 0;
        padding-left: 1.1rem;
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.25rem 0.55rem;
        border-radius: 999px;
        font-size: 0.72rem;
        background: rgba(148, 163, 184, 0.15);
        color: var(--text-subtle);
      }

      .badge.success {
        background: rgba(34, 197, 94, 0.18);
        color: var(--success);
      }

      .badge.warning {
        background: rgba(251, 191, 36, 0.16);
        color: var(--warning);
      }

      .badge.error {
        background: rgba(248, 113, 113, 0.16);
        color: var(--error);
      }

      @media (max-width: 1280px) {
        :root {
          --sidebar-width: 220px;
        }
        .editor-grid {
          grid-template-columns: minmax(200px, 280px) 1fr;
          grid-auto-rows: minmax(220px, 1fr);
        }
        .editor-grid .panel:last-child {
          grid-column: 1 / -1;
          min-height: 220px;
        }
      }

      @media (max-width: 960px) {
        aside {
          display: none;
        }
        .main-header,
        .workspace,
        .console {
          padding-left: 1.25rem;
          padding-right: 1.25rem;
        }
      }

      @media (max-width: 720px) {
        .editor-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <aside>
        <div class="brand">
          <h1>Competition Data Studio</h1>
          <p>Full-stack editor for FIFA-style tournaments</p>
        </div>
        <nav class="nav" id="editor-nav"></nav>
        <div class="sidebar-footer">
          <div class="badge">Render ready</div>
          <p style="margin: 0; font-size: 0.75rem; color: var(--text-subtle);">
            API routes auto-detect the static frontend when deployed to Render.
          </p>
        </div>
      </aside>
      <main>
        <header class="main-header">
          <div>
            <h2 id="active-file-heading">Select a file</h2>
            <p class="subtitle" id="active-file-subtitle"></p>
            <div class="status-line">
              <span class="indicator" id="sync-indicator">Idle</span>
              <span id="meta-summary"></span>
            </div>
          </div>
          <div class="action-bar">
            <button id="action-load">Reload</button>
            <button id="action-save" class="primary">Save</button>
            <button id="action-validate">Validate</button>
            <button id="action-autofix">Auto-Fix</button>
            <button id="action-compare">Compare</button>
            <button id="action-export">Export ZIP</button>
          </div>
        </header>
        <section class="workspace">
          <div class="workspace-card" id="workspace-card">
            <div class="placeholder" style="margin: auto; text-align: center; max-width: 480px;">
              <h3 style="font-size: 1.3rem; margin-bottom: 0.5rem;">Pick a dataset to begin</h3>
              <p style="margin: 0; color: var(--text-subtle);">
                Use the sidebar to choose between competition objects, metadata, schedule, standings rules, tasks, and weather
                profiles. The editor panel updates instantly and can validate, auto-fix, compare, and save changes back to disk.
              </p>
            </div>
          </div>
        </section>
        <section class="console">
          <div class="console-header">
            <h3>Console &amp; Validation Log</h3>
            <div class="action-bar">
              <button id="action-validate-all">Validate All</button>
              <button id="action-clear-console">Clear Log</button>
            </div>
          </div>
          <div class="console-stream" id="console-stream"></div>
        </section>
      </main>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" integrity="sha384-nok0L+mHJHZ9frN7kYMboWWAOPw7Ov7BTIzRv5J4zVfOLm8sEzrBc8eCzQEr1Aun" crossorigin="anonymous"></script>
    <script type="module">
      const FILES = [
        {
          name: 'compobj.txt',
          icon: '🏆',
          title: 'CompObj Editor',
          description: 'Hierarchy and stage definitions for the competition.',
          render: renderCompobjEditor,
        },
        {
          name: 'compdata.txt',
          icon: '🧮',
          title: 'CompData Editor',
          description: 'Key/value metadata for the tournament.',
          render: ctx => renderCsvEditor(ctx, {
            title: 'Property Grid',
            subtitle: 'Edit key/value metadata entries.',
            columns: [
              { key: 'key', label: 'Key' },
              { key: 'value', label: 'Value' },
            ],
            filterable: true,
            reorderable: false,
            newRow: () => [`property_${Date.now()}`, ''],
            summaryBuilder: rows => [`${rows.length} editable properties`],
          }),
        },
        {
          name: 'schedule.txt',
          icon: '🗓️',
          title: 'Schedule Editor',
          description: 'Round, group, and fixture definitions.',
          render: ctx => renderCsvEditor(ctx, {
            title: 'Match Schedule',
            subtitle: 'Maintain stage, round, and kickoff details.',
            columns: [
              { key: 'stage', label: 'Stage ID', datalist: 'stage-codes' },
              { key: 'round', label: 'Round' },
              { key: 'group', label: 'Group' },
              { key: 'home', label: 'Home' },
              { key: 'away', label: 'Away' },
              { key: 'date', label: 'Date/Time' },
            ],
            filterable: true,
            reorderable: false,
            datalist: () => ({ 'stage-codes': getStageCodes() }),
            newRow: () => {
              const codes = getStageCodes();
              return [codes[0] || 'S1', '1', '1', '0', '0', '1200'];
            },
            summaryBuilder: rows => {
              const stages = new Set(rows.map(row => row.parts?.[0]).filter(Boolean));
              return [`${rows.length} fixtures`, `${stages.size} stages`];
            },
          }),
        },
        {
          name: 'standings.txt',
          icon: '📊',
          title: 'Standings Editor',
          description: 'Tie-breaker and ranking rule order.',
          render: ctx => renderCsvEditor(ctx, {
            title: 'Rule Order',
            subtitle: 'Arrange ranking and tie-breaker rules.',
            columns: [
              { key: 'ruleSet', label: 'Rule Set' },
              { key: 'rule', label: 'Rule Key' },
            ],
            filterable: false,
            reorderable: true,
            newRow: () => ['6', '0'],
            summaryBuilder: rows => [`${rows.length} rules`, 'Drag buttons to reorder'],
          }),
        },
        {
          name: 'tasks.txt',
          icon: '⚙️',
          title: 'Tasks Editor',
          description: 'Automation commands and sequencing.',
          render: ctx => renderCsvEditor(ctx, {
            title: 'Task Sequence',
            subtitle: 'Configure automation commands for stage population.',
            columns: [
              { key: 'stage', label: 'Stage' },
              { key: 'trigger', label: 'Trigger' },
              { key: 'command', label: 'Command' },
              { key: 'param1', label: 'Param 1' },
              { key: 'param2', label: 'Param 2' },
              { key: 'param3', label: 'Param 3' },
              { key: 'param4', label: 'Param 4' },
            ],
            filterable: true,
            reorderable: true,
            newRow: () => ['0', 'start', 'FillWithTeam', '0', '0', '0', '0'],
            summaryBuilder: rows => [`${rows.length} automation steps configured`],
          }),
        },
        {
          name: 'weather.txt',
          icon: '☁️',
          title: 'Weather Editor',
          description: 'Federation weather profiles by season.',
          render: ctx => renderCsvEditor(ctx, {
            title: 'Weather Profiles',
            subtitle: 'Define seasonal weather weights.',
            columns: [
              { key: 'federation', label: 'Federation' },
              { key: 'season', label: 'Season' },
              { key: 'condition', label: 'Condition' },
              { key: 'precip', label: 'Precip%' },
              { key: 'wind', label: 'Wind%' },
              { key: 'storm', label: 'Storm%' },
              { key: 'temp', label: 'Temp°' },
              { key: 'start', label: 'Start' },
              { key: 'end', label: 'End' },
            ],
            filterable: true,
            reorderable: false,
            newRow: () => ['0', '1', '80', '0', '0', '0', '20', '1600', '1900'],
            summaryBuilder: rows => [`${rows.length} seasonal records`],
          }),
        },
      ];

      const api = {
        async load(name) {
          const res = await fetch(`/api/file/${name}`);
          if (!res.ok) {
            throw new Error(`Unable to load ${name}: ${await res.text()}`);
          }
          return res.text();
        },
        async save(name, content) {
          const res = await fetch(`/api/file/${name}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content }),
          });
          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            throw new Error(payload.error || `Unable to save ${name}`);
          }
        },
        async validate(name) {
          const res = await fetch(`/api/validate/${name}`);
          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            throw new Error(payload.error || `Unable to validate ${name}`);
          }
          return res.json();
        },
        async validateAll() {
          const res = await fetch('/api/validate/all');
          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            throw new Error(payload.error || 'Unable to validate all files');
          }
          return res.json();
        },
        async autofix(name, content) {
          const res = await fetch(`/api/autofix/${name}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content }),
          });
          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            throw new Error(payload.error || `Unable to auto-fix ${name}`);
          }
          return res.json();
        },
        async compare(name) {
          const res = await fetch(`/api/compare/${name}`);
          if (!res.ok) {
            const payload = await res.json().catch(() => ({}));
            throw new Error(payload.error || `Unable to compare ${name}`);
          }
          return res.json();
        },
      };

      const appState = {
        activeFile: null,
        files: {},
        logs: [],
        loadToken: 0,
      };

      const navEl = document.getElementById('editor-nav');
      const workspaceCard = document.getElementById('workspace-card');
      const headingEl = document.getElementById('active-file-heading');
      const subtitleEl = document.getElementById('active-file-subtitle');
      const syncIndicator = document.getElementById('sync-indicator');
      const metaSummary = document.getElementById('meta-summary');
      const consoleStream = document.getElementById('console-stream');

      document.getElementById('action-load').addEventListener('click', () => loadActiveFile(true));
      document.getElementById('action-save').addEventListener('click', saveActiveFile);
      document.getElementById('action-validate').addEventListener('click', () => validateActiveFile());
      document.getElementById('action-autofix').addEventListener('click', autoFixActiveFile);
      document.getElementById('action-compare').addEventListener('click', compareActiveFile);
      document.getElementById('action-validate-all').addEventListener('click', validateAllFiles);
      document.getElementById('action-clear-console').addEventListener('click', () => {
        appState.logs = [];
        renderConsole();
      });
      document.getElementById('action-export').addEventListener('click', exportAllFiles);

      renderSidebar();
      setActiveFile(FILES[0].name);
      function ensureFileState(name) {
        if (!appState.files[name]) {
          appState.files[name] = {
            content: '',
            dirty: false,
            lastLoaded: null,
            lastSaved: null,
            cache: {},
          };
        }
        return appState.files[name];
      }

      function renderSidebar() {
        navEl.innerHTML = '';
        FILES.forEach(file => {
          const button = document.createElement('button');
          button.dataset.file = file.name;
          if (appState.activeFile === file.name) {
            button.classList.add('active');
          }
          button.innerHTML = `
            <span class="icon">${file.icon}</span>
            <span class="label">
              <strong>${escapeHtml(file.title)}</strong>
              <small style="display:block; font-size:0.75rem; color:var(--text-subtle);">${escapeHtml(file.name)}</small>
            </span>
          `;
          button.addEventListener('click', () => setActiveFile(file.name));
          navEl.appendChild(button);
        });
      }

      function normaliseNewlines(value) {
        return (value || '').replace(/\r\n/g, '\n');
      }

      function escapeHtml(value) {
        return (value ?? '')
          .toString()
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      function formatRelativeTime(date) {
        if (!date) return '';
        const diff = Date.now() - date.getTime();
        if (diff < 45 * 1000) return 'just now';
        const minutes = Math.round(diff / 60000);
        if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
        const hours = Math.round(minutes / 60);
        if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
        const days = Math.round(hours / 24);
        if (days < 7) return `${days} day${days === 1 ? '' : 's'} ago`;
        const weeks = Math.round(days / 7);
        return `${weeks} week${weeks === 1 ? '' : 's'} ago`;
      }

      function formatTimestamp(date) {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      }

      function logMessage(type, message, details = []) {
        const entry = {
          id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
          type,
          message,
          details,
          timestamp: new Date(),
        };
        appState.logs.push(entry);
        if (appState.logs.length > 120) {
          appState.logs.shift();
        }
        renderConsole();
      }

      function renderConsole() {
        consoleStream.innerHTML = '';
        if (!appState.logs.length) {
          const empty = document.createElement('div');
          empty.style.color = 'var(--text-subtle)';
          empty.style.fontSize = '0.85rem';
          empty.textContent = 'Console ready. Actions, validation, and comparison results will appear here.';
          consoleStream.appendChild(empty);
          return;
        }
        const fragment = document.createDocumentFragment();
        appState.logs.forEach(entry => {
          const wrapper = document.createElement('article');
          wrapper.className = `console-entry ${entry.type || 'info'}`;
          const header = document.createElement('header');
          header.innerHTML = `
            <span>${escapeHtml(entry.message)}</span>
            <span class="badge">${formatTimestamp(entry.timestamp)}</span>
          `;
          wrapper.appendChild(header);
          if (entry.details && entry.details.length) {
            const list = document.createElement('ul');
            entry.details.forEach(detail => {
              const li = document.createElement('li');
              li.textContent = detail;
              list.appendChild(li);
            });
            wrapper.appendChild(list);
          }
          fragment.appendChild(wrapper);
        });
        consoleStream.appendChild(fragment);
      }

      function setFileContent(name, content, options = {}) {
        const { markDirty = true, silent = false } = options;
        const state = ensureFileState(name);
        state.content = normaliseNewlines(content);
        if (markDirty) {
          state.dirty = true;
        }
        if (!silent && appState.activeFile === name) {
          updateMetaSummary();
        }
        return state.content;
      }

      function renderWorkspace() {
        if (!appState.activeFile) {
          workspaceCard.innerHTML = '<p style="color: var(--text-subtle); text-align:center;">Select a file to start editing.</p>';
          return;
        }
        const config = FILES.find(file => file.name === appState.activeFile);
        const state = ensureFileState(appState.activeFile);
        workspaceCard.innerHTML = '';
        const context = {
          container: workspaceCard,
          fileName: appState.activeFile,
          fileConfig: config,
          fileState: state,
          setContent: (value, opts) => setFileContent(appState.activeFile, value, opts),
          refresh: () => renderWorkspace(),
          log: logMessage,
        };
        config.render(context);
      }

      function updateMetaSummary() {
        if (!appState.activeFile) {
          metaSummary.textContent = '';
          return;
        }
        const state = ensureFileState(appState.activeFile);
        const lineCount = state.content ? state.content.split(/\n/).filter(Boolean).length : 0;
        const bits = [];
        if (state.lastLoaded) bits.push(`Loaded ${formatRelativeTime(state.lastLoaded)}`);
        if (state.lastSaved) bits.push(`Saved ${formatRelativeTime(state.lastSaved)}`);
        bits.push(`${lineCount} lines`);
        metaSummary.textContent = bits.join(' • ');
        if (state.dirty) {
          syncIndicator.textContent = 'Unsaved changes';
          syncIndicator.classList.add('unsaved');
        } else {
          syncIndicator.textContent = 'In sync';
          syncIndicator.classList.remove('unsaved');
        }
      }

      function getStageCodes() {
        const comp = ensureFileState('compobj.txt');
        if (!comp.content) return [];
        return parseCompobjRows(comp.content)
          .filter(row => row.code && row.code.startsWith('S'))
          .map(row => row.code);
      }
      async function setActiveFile(name) {
        const config = FILES.find(file => file.name === name);
        if (!config) {
          logMessage('error', `Unknown file: ${name}`);
          return;
        }
        appState.activeFile = name;
        headingEl.textContent = `${config.icon} ${config.title}`;
        subtitleEl.textContent = config.description;
        renderSidebar();
        updateMetaSummary();
        await loadActiveFile(!ensureFileState(name).lastLoaded);
      }

      async function loadActiveFile(force = false) {
        if (!appState.activeFile) return;
        const name = appState.activeFile;
        const state = ensureFileState(name);
        if (!force && state.lastLoaded) {
          renderWorkspace();
          updateMetaSummary();
          return;
        }
        const token = ++appState.loadToken;
        try {
          syncIndicator.textContent = 'Loading…';
          const content = await api.load(name);
          if (token !== appState.loadToken) return;
          state.content = normaliseNewlines(content);
          state.dirty = false;
          state.lastLoaded = new Date();
          renderWorkspace();
          updateMetaSummary();
          const lines = state.content.split(/\n/).filter(Boolean).length;
          logMessage('success', `Loaded ${name}`, [`${lines} lines available`]);
        } catch (error) {
          if (token !== appState.loadToken) return;
          logMessage('error', error.message);
          syncIndicator.textContent = 'Error';
        }
      }

      async function saveActiveFile() {
        if (!appState.activeFile) return;
        const name = appState.activeFile;
        const state = ensureFileState(name);
        try {
          await api.save(name, state.content);
          state.dirty = false;
          state.lastSaved = new Date();
          updateMetaSummary();
          const lines = state.content.split(/\n/).filter(Boolean).length;
          logMessage('success', `Saved ${name}`, [`${lines} lines written`]);
        } catch (error) {
          logMessage('error', error.message);
        }
      }

      async function validateActiveFile() {
        if (!appState.activeFile) return;
        const name = appState.activeFile;
        try {
          const result = await api.validate(name);
          const issues = result.issues || [];
          if (!issues.length) {
            logMessage('success', `Validation passed for ${name}`);
          } else {
            const severity = issues.some(issue => issue.type === 'error') ? 'error' : 'warning';
            const details = issues.map(issue => `Line ${issue.line ?? '?'} — ${issue.type || 'issue'}: ${issue.message}`);
            logMessage(severity, `Validation found ${issues.length} issues in ${name}`, details);
          }
        } catch (error) {
          logMessage('error', error.message);
        }
      }

      async function validateAllFiles() {
        try {
          const summary = await api.validateAll();
          const entries = Object.entries(summary.summaries || {});
          const details = entries.map(([fileName, result]) => {
            const status = result.ok ? '✅' : '⚠️';
            const issueCount = result.issues?.length || 0;
            return `${status} ${fileName} — ${issueCount} issue${issueCount === 1 ? '' : 's'}`;
          });
          logMessage(summary.ok ? 'success' : 'warning', 'Validation complete', details);
        } catch (error) {
          logMessage('error', error.message);
        }
      }

      async function autoFixActiveFile() {
        if (!appState.activeFile) return;
        const name = appState.activeFile;
        const state = ensureFileState(name);
        try {
          const result = await api.autofix(name, state.content);
          if (result.content !== undefined) {
            state.content = normaliseNewlines(result.content);
            state.dirty = true;
            renderWorkspace();
            updateMetaSummary();
          }
          if (result.fixes && result.fixes.length) {
            const details = result.fixes.map(fix => `Line ${fix.line}: ${fix.message}`);
            logMessage('info', `Auto-fix applied ${result.fixes.length} adjustments`, details);
          } else {
            logMessage('info', `Auto-fix processed ${name}`, ['No automatic changes were necessary.']);
          }
        } catch (error) {
          logMessage('error', error.message);
        }
      }

      async function compareActiveFile() {
        if (!appState.activeFile) return;
        const name = appState.activeFile;
        try {
          const result = await api.compare(name);
          if (!result.ok) {
            logMessage('warning', `Comparison unavailable for ${name}`, [result.error]);
            return;
          }
          const diffs = result.differences || [];
          if (!diffs.length) {
            logMessage('success', `${name} matches the default reference`);
            return;
          }
          const details = diffs.slice(0, 12).map(diff => {
            const type = diff.type || 'changed';
            const baseline = diff.baseline ?? '∅';
            const current = diff.current ?? '∅';
            return `${type.toUpperCase()} line ${diff.line}: ${baseline} → ${current}`;
          });
          if (diffs.length > 12) {
            details.push(`…and ${diffs.length - 12} more differences`);
          }
          logMessage('warning', `${diffs.length} differences detected in ${name}`, details);
        } catch (error) {
          logMessage('error', error.message);
        }
      }

      async function exportAllFiles() {
        try {
          if (typeof JSZip === 'undefined') {
            logMessage('warning', 'JSZip library not loaded', ['The export feature requires network access to cdn.jsdelivr.net.']);
            return;
          }
          const zip = new JSZip();
          await Promise.all(
            FILES.map(async file => {
              const state = ensureFileState(file.name);
              const content = state.content || (await api.load(file.name));
              zip.file(file.name, content);
            })
          );
          const blob = await zip.generateAsync({ type: 'blob' });
          const url = URL.createObjectURL(blob);
          const anchor = document.createElement('a');
          anchor.href = url;
          anchor.download = `competition-data-${Date.now()}.zip`;
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          URL.revokeObjectURL(url);
          logMessage('success', 'Exported all files as ZIP');
        } catch (error) {
          logMessage('error', error.message);
        }
      }
      function createPanelElement(title, subtitle) {
        const section = document.createElement('section');
        section.className = 'panel';
        const header = document.createElement('div');
        header.className = 'panel-header';
        const heading = document.createElement('h3');
        heading.textContent = title;
        header.appendChild(heading);
        if (subtitle) {
          const sub = document.createElement('p');
          sub.style.margin = '0.35rem 0 0';
          sub.style.fontSize = '0.78rem';
          sub.style.color = 'var(--text-subtle)';
          sub.textContent = subtitle;
          header.appendChild(sub);
        }
        const body = document.createElement('div');
        body.className = 'panel-body';
        section.append(header, body);
        return { section, body, header };
      }

      function parseCompobjRows(content) {
        const lines = normaliseNewlines(content).split(/\n/);
        const rows = [];
        lines.forEach((line, index) => {
          const trimmed = line.trim();
          if (!trimmed) return;
          const parts = line.split(',');
          while (parts.length < 5) {
            parts.push('');
          }
          const [idRaw, levelRaw, codeRaw, nameRaw, parentRaw] = parts;
          rows.push({
            index,
            order: rows.length,
            id: Number(idRaw),
            level: Number(levelRaw),
            code: (codeRaw || '').trim(),
            name: (nameRaw || '').trim(),
            parent: parentRaw !== undefined && parentRaw.trim() !== '' ? Number(parentRaw) : NaN,
            raw: trimmed,
          });
        });
        return rows;
      }

      function serialiseCompobjRows(rows) {
        return rows
          .map(row => [
            Number.isFinite(row.id) ? row.id : '',
            Number.isFinite(row.level) ? row.level : '',
            row.code ?? '',
            row.name ?? '',
            Number.isFinite(row.parent) ? row.parent : '',
          ].join(','))
          .join('\n');
      }
      function renderCompobjEditor(ctx) {
        const { container, fileState } = ctx;
        container.innerHTML = '';
        let rows = parseCompobjRows(fileState.content);
        const cache = fileState.cache;
        if (!cache.expanded) {
          cache.expanded = new Set(rows.filter(row => Number.isFinite(row.level) && row.level <= 1).map(row => row.id));
        }
        if (cache.filter === undefined) cache.filter = '';
        if (cache.selectedId == null && rows.length) cache.selectedId = rows[0].id;

        const grid = document.createElement('div');
        grid.className = 'editor-grid';
        container.appendChild(grid);

        const treePanel = createPanelElement('Competition Tree', 'Browse and select nodes');
        const detailPanel = createPanelElement('Node Details', 'Edit the selected entry');
        const actionsPanel = createPanelElement('Quick Actions', 'Generate, duplicate, or edit raw data');
        grid.append(treePanel.section, detailPanel.section, actionsPanel.section);

        const toolbar = document.createElement('div');
        toolbar.className = 'toolbar';
        const searchField = document.createElement('label');
        searchField.className = 'search-field';
        searchField.innerHTML = '<span>🔍</span>';
        const searchInput = document.createElement('input');
        searchInput.type = 'search';
        searchInput.placeholder = 'Filter by code, name, or ID';
        searchInput.value = cache.filter || '';
        searchField.appendChild(searchInput);
        toolbar.appendChild(searchField);
        const expandButton = document.createElement('button');
        expandButton.className = 'inline-button';
        expandButton.textContent = 'Expand all';
        toolbar.appendChild(expandButton);
        const collapseButton = document.createElement('button');
        collapseButton.className = 'inline-button';
        collapseButton.textContent = 'Collapse all';
        toolbar.appendChild(collapseButton);
        treePanel.body.appendChild(toolbar);

        const treeList = document.createElement('ul');
        treeList.className = 'tree';
        treePanel.body.appendChild(treeList);

        const summaryList = document.createElement('ul');
        summaryList.style.listStyle = 'none';
        summaryList.style.margin = '1rem 0 0';
        summaryList.style.padding = '0';
        summaryList.style.display = 'flex';
        summaryList.style.flexDirection = 'column';
        summaryList.style.gap = '0.35rem';
        actionsPanel.body.appendChild(summaryList);

        const rawField = document.createElement('div');
        rawField.className = 'field';
        const rawLabel = document.createElement('label');
        rawLabel.textContent = 'Raw compobj.txt';
        const rawTextarea = document.createElement('textarea');
        rawTextarea.value = fileState.content;
        rawField.append(rawLabel, rawTextarea);
        const rawButtons = document.createElement('div');
        rawButtons.className = 'table-actions';
        const applyRaw = document.createElement('button');
        applyRaw.className = 'inline-button primary';
        applyRaw.textContent = 'Apply Raw Changes';
        rawButtons.appendChild(applyRaw);
        actionsPanel.body.append(rawField, rawButtons);

        const actionRow = document.createElement('div');
        actionRow.className = 'table-actions';
        const addStageBtn = document.createElement('button');
        addStageBtn.className = 'inline-button primary';
        addStageBtn.textContent = 'Add Stage';
        const addGroupBtn = document.createElement('button');
        addGroupBtn.className = 'inline-button';
        addGroupBtn.textContent = 'Add Group';
        const duplicateBtn = document.createElement('button');
        duplicateBtn.className = 'inline-button';
        duplicateBtn.textContent = 'Duplicate';
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'inline-button';
        deleteBtn.textContent = 'Delete';
        actionRow.append(addStageBtn, addGroupBtn, duplicateBtn, deleteBtn);
        actionsPanel.body.insertBefore(actionRow, summaryList);

        function buildHierarchy() {
          const map = new Map();
          rows.forEach(row => {
            map.set(row.id, { row, children: [] });
          });
          const roots = [];
          map.forEach(node => {
            if (!Number.isFinite(node.row.parent) || !map.has(node.row.parent) || node.row.parent < 0) {
              roots.push(node);
            } else {
              map.get(node.row.parent).children.push(node);
            }
          });
          const sortNodes = list => list.sort((a, b) => (a.row.order ?? 0) - (b.row.order ?? 0));
          sortNodes(roots);
          map.forEach(node => sortNodes(node.children));
          return roots;
        }

        function shouldDisplay(node) {
          const filter = (cache.filter || '').toLowerCase();
          if (!filter) return true;
          const target = `${node.row.code} ${node.row.name} ${node.row.id}`.toLowerCase();
          if (target.includes(filter)) return true;
          return node.children.some(child => shouldDisplay(child));
        }

        function createTreeNode(node) {
          const li = document.createElement('li');
          li.dataset.id = node.row.id;
          if (cache.selectedId === node.row.id) {
            li.classList.add('selected');
          }

          const label = document.createElement('div');
          label.className = 'label';
          const title = document.createElement('strong');
          title.textContent = node.row.code || '(no code)';
          const name = document.createElement('span');
          name.textContent = node.row.name || '—';
          label.append(title, name);

          const meta = document.createElement('div');
          meta.className = 'meta';
          if (node.children.length && !cache.filter) {
            const toggle = document.createElement('button');
            toggle.className = 'inline-button';
            toggle.style.padding = '0.15rem 0.45rem';
            toggle.textContent = cache.expanded.has(node.row.id) ? '−' : '+';
            toggle.addEventListener('click', event => {
              event.stopPropagation();
              if (cache.expanded.has(node.row.id)) {
                cache.expanded.delete(node.row.id);
              } else {
                cache.expanded.add(node.row.id);
              }
              renderTree();
            });
            meta.appendChild(toggle);
          }
          const metaText = document.createElement('span');
          metaText.textContent = `ID ${Number.isFinite(node.row.id) ? node.row.id : '?'} • Level ${Number.isFinite(node.row.level) ? node.row.level : '?'}`;
          meta.appendChild(metaText);

          li.append(label, meta);

          li.addEventListener('click', event => {
            event.stopPropagation();
            cache.selectedId = node.row.id;
            renderTree();
            renderDetails();
          });

          const expanded = cache.filter ? true : cache.expanded.has(node.row.id);
          if (node.children.length && expanded) {
            const childList = document.createElement('ul');
            childList.className = 'tree-children';
            node.children.forEach(child => {
              if (shouldDisplay(child)) {
                childList.appendChild(createTreeNode(child));
              }
            });
            if (childList.children.length) {
              li.appendChild(childList);
            }
          }
          return li;
        }

        function renderTree() {
          treeList.innerHTML = '';
          const roots = buildHierarchy();
          roots.forEach(node => {
            if (shouldDisplay(node)) {
              treeList.appendChild(createTreeNode(node));
            }
          });
          updateSummary();
        }

        function renderDetails() {
          detailPanel.body.innerHTML = '';
          if (!rows.length) {
            detailPanel.body.innerHTML = '<p style="color: var(--text-subtle);">File is empty. Use Quick Actions to create nodes.</p>';
            return;
          }
          const selected = rows.find(row => row.id === cache.selectedId) || rows[0];
          if (!selected) {
            cache.selectedId = rows[0]?.id ?? null;
            renderTree();
            return;
          }
          cache.selectedId = selected.id;

          const fieldGrid = document.createElement('div');
          fieldGrid.className = 'field-grid';

          const idField = document.createElement('div');
          idField.className = 'field';
          const idLabel = document.createElement('label');
          idLabel.textContent = 'ID';
          const idInput = document.createElement('input');
          idInput.type = 'number';
          idInput.value = Number.isFinite(selected.id) ? String(selected.id) : '';
          idField.append(idLabel, idInput);

          const levelField = document.createElement('div');
          levelField.className = 'field';
          const levelLabel = document.createElement('label');
          levelLabel.textContent = 'Level';
          const levelInput = document.createElement('input');
          levelInput.type = 'number';
          levelInput.value = Number.isFinite(selected.level) ? String(selected.level) : '';
          levelField.append(levelLabel, levelInput);

          const codeField = document.createElement('div');
          codeField.className = 'field';
          const codeLabel = document.createElement('label');
          codeLabel.textContent = 'Code';
          const codeInput = document.createElement('input');
          codeInput.value = selected.code || '';
          codeField.append(codeLabel, codeInput);

          const nameField = document.createElement('div');
          nameField.className = 'field';
          const nameLabel = document.createElement('label');
          nameLabel.textContent = 'Name';
          const nameInput = document.createElement('input');
          nameInput.value = selected.name || '';
          nameField.append(nameLabel, nameInput);

          const parentField = document.createElement('div');
          parentField.className = 'field';
          const parentLabel = document.createElement('label');
          parentLabel.textContent = 'Parent ID';
          const parentInput = document.createElement('input');
          parentInput.type = 'number';
          parentInput.value = Number.isFinite(selected.parent) ? String(selected.parent) : '';
          parentField.append(parentLabel, parentInput);

          fieldGrid.append(idField, levelField, codeField, nameField, parentField);
          detailPanel.body.appendChild(fieldGrid);

          const info = document.createElement('p');
          info.style.fontSize = '0.8rem';
          info.style.color = 'var(--text-subtle)';
          info.style.marginTop = '0.85rem';
          info.textContent = `Line ${selected.index + 1}`;
          detailPanel.body.appendChild(info);

          idInput.addEventListener('change', () => {
            const newId = Number(idInput.value);
            if (!Number.isInteger(newId)) {
              idInput.value = Number.isFinite(selected.id) ? String(selected.id) : '';
              return;
            }
            if (rows.some(row => row !== selected && row.id === newId)) {
              logMessage('warning', `ID ${newId} already exists`, []);
              idInput.value = Number.isFinite(selected.id) ? String(selected.id) : '';
              return;
            }
            const oldId = selected.id;
            selected.id = newId;
            rows.forEach(row => {
              if (row.parent === oldId) {
                row.parent = newId;
              }
            });
            cache.selectedId = newId;
            ctx.setContent(serialiseCompobjRows(rows));
            renderTree();
            renderDetails();
          });

          levelInput.addEventListener('change', () => {
            const newLevel = Number(levelInput.value);
            if (!Number.isInteger(newLevel)) {
              levelInput.value = Number.isFinite(selected.level) ? String(selected.level) : '';
              return;
            }
            selected.level = newLevel;
            ctx.setContent(serialiseCompobjRows(rows));
            renderTree();
          });

          codeInput.addEventListener('input', () => {
            selected.code = codeInput.value.trim();
            ctx.setContent(serialiseCompobjRows(rows), { silent: true });
            renderTree();
          });
          codeInput.addEventListener('change', () => {
            selected.code = codeInput.value.trim();
            ctx.setContent(serialiseCompobjRows(rows));
            renderTree();
          });

          nameInput.addEventListener('input', () => {
            selected.name = nameInput.value;
            ctx.setContent(serialiseCompobjRows(rows), { silent: true });
            renderTree();
          });
          nameInput.addEventListener('change', () => {
            selected.name = nameInput.value;
            ctx.setContent(serialiseCompobjRows(rows));
            renderTree();
          });

          parentInput.addEventListener('change', () => {
            const value = parentInput.value.trim();
            selected.parent = value === '' ? NaN : Number(value);
            ctx.setContent(serialiseCompobjRows(rows));
            renderTree();
          });
        }

        function generateNextId() {
          let maxId = 0;
          rows.forEach(row => {
            if (Number.isFinite(row.id) && row.id > maxId) {
              maxId = row.id;
            }
          });
          return maxId + 1;
        }

        function updateSummary() {
          summaryList.innerHTML = '';
          if (!rows.length) {
            const empty = document.createElement('li');
            empty.textContent = 'No nodes loaded.';
            summaryList.appendChild(empty);
            return;
          }
          const totalStages = rows.filter(row => row.code && row.code.startsWith('S')).length;
          const totalGroups = rows.filter(row => row.code && row.code.startsWith('G')).length;
          const competitions = rows.filter(row => Number.isFinite(row.level) && row.level === 0).length;
          const stats = [
            `${rows.length} total nodes`,
            `${totalStages} stages`,
            `${totalGroups} groups`,
            `${competitions} competitions`,
          ];
          stats.forEach(text => {
            const li = document.createElement('li');
            li.textContent = text;
            summaryList.appendChild(li);
          });
        }

        searchInput.addEventListener('input', () => {
          cache.filter = searchInput.value;
          renderTree();
        });

        expandButton.addEventListener('click', () => {
          cache.expanded = new Set(rows.map(row => row.id));
          renderTree();
        });

        collapseButton.addEventListener('click', () => {
          cache.expanded = new Set(rows.filter(row => !Number.isFinite(row.level) || row.level <= 0).map(row => row.id));
          renderTree();
        });

        addStageBtn.addEventListener('click', () => {
          const base = rows.find(row => row.id === cache.selectedId) || rows.find(row => row.level === 0);
          const newId = generateNextId();
          const parentId = base ? base.id : -1;
          const newRow = {
            index: rows.length,
            order: rows.length,
            id: newId,
            level: base ? (Number.isFinite(base.level) ? base.level + 1 : 1) : 1,
            code: `S${newId}`,
            name: `FCE_STAGE_${newId}`,
            parent: parentId,
            raw: '',
          };
          rows.push(newRow);
          cache.expanded.add(parentId);
          cache.selectedId = newId;
          ctx.setContent(serialiseCompobjRows(rows));
          ctx.refresh();
        });

        addGroupBtn.addEventListener('click', () => {
          const base = rows.find(row => row.id === cache.selectedId) || rows.find(row => row.code && row.code.startsWith('S'));
          const newId = generateNextId();
          const parentId = base ? base.id : -1;
          const newRow = {
            index: rows.length,
            order: rows.length,
            id: newId,
            level: base ? (Number.isFinite(base.level) ? base.level + 1 : 1) : 1,
            code: `G${newId}`,
            name: `Group_${newId}`,
            parent: parentId,
            raw: '',
          };
          rows.push(newRow);
          cache.expanded.add(parentId);
          cache.selectedId = newId;
          ctx.setContent(serialiseCompobjRows(rows));
          ctx.refresh();
        });

        duplicateBtn.addEventListener('click', () => {
          const base = rows.find(row => row.id === cache.selectedId);
          if (!base) {
            logMessage('warning', 'Select a node to duplicate');
            return;
          }
          const newId = generateNextId();
          const copy = {
            index: rows.length,
            order: rows.length,
            id: newId,
            level: base.level,
            code: base.code ? `${base.code}_COPY` : `N${newId}`,
            name: base.name ? `${base.name} Copy` : '',
            parent: base.parent,
            raw: '',
          };
          const insertIndex = rows.indexOf(base) + 1;
          rows.splice(insertIndex, 0, copy);
          cache.expanded.add(base.parent);
          cache.selectedId = newId;
          ctx.setContent(serialiseCompobjRows(rows));
          ctx.refresh();
        });

        deleteBtn.addEventListener('click', () => {
          const selected = rows.find(row => row.id === cache.selectedId);
          if (!selected) {
            logMessage('warning', 'Select a node to delete');
            return;
          }
          if (!window.confirm('Delete the selected node and all of its children?')) {
            return;
          }
          const toRemove = new Set([selected.id]);
          let changed = true;
          while (changed) {
            changed = false;
            rows.forEach(row => {
              if (!toRemove.has(row.id) && toRemove.has(row.parent)) {
                toRemove.add(row.id);
                changed = true;
              }
            });
          }
          rows = rows.filter(row => !toRemove.has(row.id));
          cache.selectedId = rows[0]?.id ?? null;
          ctx.setContent(serialiseCompobjRows(rows));
          ctx.refresh();
        });

        applyRaw.addEventListener('click', () => {
          const value = rawTextarea.value;
          ctx.setContent(value);
          rows = parseCompobjRows(value);
          cache.selectedId = rows[0]?.id ?? null;
          ctx.refresh();
          logMessage('info', 'Applied raw compobj.txt changes');
        });

        renderTree();
        renderDetails();
      }
      function parseCsvRows(content, columnCount) {
        const lines = normaliseNewlines(content).split(/\n/);
        const rows = [];
        lines.forEach(line => {
          const trimmed = line.trim();
          if (!trimmed) return;
          if (trimmed.startsWith('#')) {
            rows.push({ isComment: true, raw: trimmed });
            return;
          }
          const parts = line.split(',').map(part => part.trim());
          while (parts.length < columnCount) {
            parts.push('');
          }
          rows.push({ isComment: false, parts });
        });
        return rows;
      }

      function serialiseCsvRows(rows) {
        return rows
          .map(row => (row.isComment ? row.raw : row.parts.join(',')))
          .join('\n');
      }

      function renderCsvEditor(ctx, config) {
        const { container, fileState } = ctx;
        container.innerHTML = '';
        const columnCount = config.columns.length;
        let rows = parseCsvRows(fileState.content, columnCount);
        const cache = fileState.cache;
        if (cache.filter === undefined) cache.filter = '';

        const grid = document.createElement('div');
        grid.className = 'editor-grid';
        container.appendChild(grid);

        const tablePanel = createPanelElement(config.title, config.subtitle);
        const rawPanel = createPanelElement('Raw Preview', `Direct edit of ${ctx.fileName}`);
        const summaryPanel = createPanelElement('Summary', 'Dataset snapshot');
        grid.append(tablePanel.section, rawPanel.section, summaryPanel.section);

        const datalistMap = config.datalist ? config.datalist() || {} : {};
        Object.entries(datalistMap).forEach(([id, options]) => {
          let list = document.getElementById(id);
          if (!list) {
            list = document.createElement('datalist');
            list.id = id;
            document.body.appendChild(list);
          }
          list.innerHTML = '';
          options.forEach(value => {
            const option = document.createElement('option');
            option.value = value;
            list.appendChild(option);
          });
        });

        const toolbar = document.createElement('div');
        toolbar.className = 'toolbar';
        let searchInput = null;
        if (config.filterable) {
          const searchField = document.createElement('label');
          searchField.className = 'search-field';
          searchField.innerHTML = '<span>🔍</span>';
          searchInput = document.createElement('input');
          searchInput.type = 'search';
          searchInput.placeholder = 'Filter rows';
          searchInput.value = cache.filter || '';
          searchField.appendChild(searchInput);
          toolbar.appendChild(searchField);
        }
        const addButton = document.createElement('button');
        addButton.className = 'inline-button primary';
        addButton.textContent = 'Add Row';
        toolbar.appendChild(addButton);
        tablePanel.body.appendChild(toolbar);

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headRow = document.createElement('tr');
        config.columns.forEach(col => {
          const th = document.createElement('th');
          th.textContent = col.label;
          headRow.appendChild(th);
        });
        const actionTh = document.createElement('th');
        actionTh.textContent = 'Actions';
        headRow.appendChild(actionTh);
        if (config.reorderable) {
          const orderTh = document.createElement('th');
          orderTh.textContent = 'Order';
          headRow.appendChild(orderTh);
        }
        thead.appendChild(headRow);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        table.appendChild(tbody);
        tablePanel.body.appendChild(table);

        const rawField = document.createElement('div');
        rawField.className = 'field';
        const rawLabel = document.createElement('label');
        rawLabel.textContent = `${ctx.fileName} raw`;
        const rawTextarea = document.createElement('textarea');
        rawTextarea.value = fileState.content;
        rawField.append(rawLabel, rawTextarea);
        const rawActions = document.createElement('div');
        rawActions.className = 'table-actions';
        const applyRaw = document.createElement('button');
        applyRaw.className = 'inline-button primary';
        applyRaw.textContent = 'Apply Raw Changes';
        rawActions.appendChild(applyRaw);
        rawPanel.body.append(rawField, rawActions);

        function updateSummary() {
          summaryPanel.body.innerHTML = '';
          const list = document.createElement('ul');
          list.style.listStyle = 'none';
          list.style.margin = '0';
          list.style.padding = '0';
          list.style.display = 'flex';
          list.style.flexDirection = 'column';
          list.style.gap = '0.35rem';
          const dataRows = rows.filter(row => !row.isComment);
          const summaryLines = config.summaryBuilder ? config.summaryBuilder(dataRows) : [`${dataRows.length} rows`];
          summaryLines.forEach(line => {
            const li = document.createElement('li');
            li.textContent = line;
            list.appendChild(li);
          });
          summaryPanel.body.appendChild(list);
        }

        function syncRawTextarea() {
          rawTextarea.value = serialiseCsvRows(rows);
        }

        function refreshTable() {
          tbody.innerHTML = '';
          const filter = (cache.filter || '').toLowerCase();
          rows.forEach((row, idx) => {
            if (row.isComment) {
              return;
            }
            if (filter && !row.parts.some(part => part.toLowerCase().includes(filter))) {
              return;
            }
            const tr = document.createElement('tr');
            tr.dataset.index = String(idx);
            config.columns.forEach((col, colIndex) => {
              const td = document.createElement('td');
              const input = document.createElement('input');
              input.value = row.parts[colIndex] ?? '';
              input.dataset.columnIndex = String(colIndex);
              if (col.datalist && datalistMap[col.datalist]) {
                input.setAttribute('list', col.datalist);
              }
              td.appendChild(input);
              tr.appendChild(td);
            });
            const actionTd = document.createElement('td');
            actionTd.className = 'table-actions';
            const duplicateBtn = document.createElement('button');
            duplicateBtn.className = 'inline-button';
            duplicateBtn.dataset.action = 'duplicate';
            duplicateBtn.textContent = 'Duplicate';
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'inline-button';
            deleteBtn.dataset.action = 'delete';
            deleteBtn.textContent = 'Delete';
            actionTd.append(duplicateBtn, deleteBtn);
            tr.appendChild(actionTd);
            if (config.reorderable) {
              const orderTd = document.createElement('td');
              orderTd.className = 'table-actions';
              const upBtn = document.createElement('button');
              upBtn.className = 'inline-button';
              upBtn.dataset.action = 'up';
              upBtn.textContent = '▲';
              const downBtn = document.createElement('button');
              downBtn.className = 'inline-button';
              downBtn.dataset.action = 'down';
              downBtn.textContent = '▼';
              orderTd.append(upBtn, downBtn);
              tr.appendChild(orderTd);
            }
            tbody.appendChild(tr);
          });
          updateSummary();
          syncRawTextarea();
        }

        function moveRow(fromIndex, direction) {
          const targetIndex = (() => {
            let idx = fromIndex + direction;
            while (idx >= 0 && idx < rows.length) {
              if (!rows[idx].isComment) return idx;
              idx += direction;
            }
            return -1;
          })();
          if (targetIndex < 0 || targetIndex >= rows.length) {
            return;
          }
          const [row] = rows.splice(fromIndex, 1);
          rows.splice(targetIndex, 0, row);
          ctx.setContent(serialiseCsvRows(rows));
          refreshTable();
        }

        if (searchInput) {
          searchInput.addEventListener('input', () => {
            cache.filter = searchInput.value;
            refreshTable();
          });
        }

        addButton.addEventListener('click', () => {
          const newParts = config.newRow ? config.newRow() : new Array(columnCount).fill('');
          rows.push({ isComment: false, parts: newParts });
          ctx.setContent(serialiseCsvRows(rows));
          refreshTable();
        });

        tbody.addEventListener('input', event => {
          const input = event.target;
          if (!(input instanceof HTMLInputElement)) return;
          const tr = input.closest('tr');
          if (!tr) return;
          const rowIndex = Number(tr.dataset.index);
          const colIndex = Number(input.dataset.columnIndex);
          if (!Number.isInteger(rowIndex) || !Number.isInteger(colIndex)) return;
          const row = rows[rowIndex];
          if (!row || row.isComment) return;
          row.parts[colIndex] = input.value;
          ctx.setContent(serialiseCsvRows(rows), { silent: true });
        });

        tbody.addEventListener('change', () => {
          ctx.setContent(serialiseCsvRows(rows));
          updateSummary();
        });

        tbody.addEventListener('click', event => {
          const button = event.target.closest('button[data-action]');
          if (!button) return;
          const tr = button.closest('tr');
          if (!tr) return;
          const rowIndex = Number(tr.dataset.index);
          if (!Number.isInteger(rowIndex)) return;
          const action = button.dataset.action;
          if (action === 'delete') {
            rows.splice(rowIndex, 1);
            ctx.setContent(serialiseCsvRows(rows));
            refreshTable();
          } else if (action === 'duplicate') {
            const clone = { isComment: false, parts: [...rows[rowIndex].parts] };
            rows.splice(rowIndex + 1, 0, clone);
            ctx.setContent(serialiseCsvRows(rows));
            refreshTable();
          } else if (action === 'up') {
            moveRow(rowIndex, -1);
          } else if (action === 'down') {
            moveRow(rowIndex, 1);
          }
        });

        applyRaw.addEventListener('click', () => {
          const value = rawTextarea.value;
          ctx.setContent(value);
          rows = parseCsvRows(value, columnCount);
          cache.filter = '';
          if (searchInput) searchInput.value = '';
          refreshTable();
          logMessage('info', `Applied raw changes to ${ctx.fileName}`);
        });

        refreshTable();
      }
    </script>
  </body>
</html>
